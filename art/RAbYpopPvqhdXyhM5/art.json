{
  "_id": "RAbYpopPvqhdXyhM5",
  "owner": {
    "username": "anon"
  },
  "createdAt": {
    "$date": {
      "$numberLong": "1585503633143"
    }
  },
  "modifiedAt": {
    "$date": {
      "$numberLong": "1585503633143"
    }
  },
  "origId": "72Qyo6BcBD6bt9NDW",
  "name": "adv_Sphere",
  "notes": "",
  "rank": {
    "$numberDouble": "1.8799563788976879"
  },
  "private": false,
  "unlisted": false,
  "username": "-anon-",
  "avatarUrl": "",
  "settings": {
    "num": 100000,
    "mode": "TRIANGLES",
    "sound": "https://soundcloud.com/chibi-tech/lolitazia-season",
    "lineSize": "NATIVE",
    "backgroundColor": [
      0.403921568627451,
      0.403921568627451,
      0.403921568627451,
      1
    ],
    "shader": "\n/*                                                              \n                                                                \n                                                                  \n                 .___               __ .                        \n                 [__ .  , _.._     /  `|_  _ ._                 \n                 [___ \\/ (_][ )____\\__.[ )(/,[ )                \n                                                                \n                                                                \n                                                                \n                                                                \n                                                                \n                                                                \n                                                                \n                                                              \n                                                                \n                                                                \n                                                                \n                                                                \n                                                                \n                                                              \n                                                                \n                                                                \n                                                                \n                                                                \n                                                                \n                                                              \n                                                                \n                                                                \n                                                                \n                                                                \n                                                                \n                                                              \n                                                                \n                                                                \n                                                                \n                                                                \n                                                                \n                                                              \n                                                                \n                                                                \n                                                                \n                                                                \n                                                                \n                                                              \n                                                                \n                                                                \n                                                                \n                                                                \n                                                                \n                                                              \n                                                                \n                                                                \n                                                                \n                                                                \n                                                                \n                                                              \n                                                                \n                                                                \n                                                                \n                                                                \n                                                                \n                                                              \n                                                                \n                                                                \n                                                                \n                                                                \n                                                                \n                                                              \n                                                                \n                                                                \n                                                                  \n                                                                \n01/01/2019\n@BestRegard \n*/                                                              \n\n#define COLOR_VIVID\n\n#ifdef COLOR_PASTEL\n\nvec3 gSunColor = vec3(1.0, 0.9, 0.1) * 10.0;  \n\nvec3 gSkyTop =  vec3( 0.1, 0.2, 0.8 ) * 4.0;\nvec3 gSkyBottom = vec3( 0.5, 0.8, 1.0 ) * 5.0;\n\nfloat gFogDensity = 0.01;\n\n\tvec3 gFloorColor = vec3(0.5, 0.1, 0.2);\nvec3 gCubeColor = vec3(1.0, 0.8, 0.8);\nfloat gExposure = 1.0;\n\nfloat gCubeColorRandom = 0.4;\n\n#endif\n\n#ifdef COLOR_VIVID\n\nvec3 gSunColor = vec3(1.0, 0.9, 0.1) * 10.0;  \n\nvec3 gSkyTop =  vec3( 0.1, 0.2, 0.8 ) * 0.5;\nvec3 gSkyBottom = vec3( 0.5, 0.8, 1.0 ) * 1.5;\n\nfloat gFogDensity = 0.05;\n\n\tvec3 gFloorColor = vec3(0.5, 0.1, 0.2);\nvec3 gCubeColor = vec3(1.0, 0.1, 1.0);\nfloat gExposure = 1.0;\n\nfloat gCubeColorRandom = 0.9;\n\n#endif \n\n#pragma region Pre_Define\n\t#define PI radians(180.)\n#pragma endregion \n\n#pragma region const\n\tconst float FARCLIPPED = 1000.  ;\n\tconst float NEARCLIPPED = 0.1\t  ; \n    float g_cameraFar = 1000.0;\n\n#pragma endregion \n\n\n#pragma region MatrixConverte \n\t\n  mat4 mAspect = mat4\n  (\n    1, 0, 0, 0,\n    0, resolution.x / resolution.y, 0, 0,\n    0, 0, 1, 0,\n    0, 0, 0, 1\n  ); \n  vec3 hsv2rgb(vec3 c) {\n    c = vec3(c.x, clamp(c.yz, 0.0, 1.0));\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n  }\n\n\n  mat4 rotY( float angle ) {\n      float s = sin( angle );\n      float c = cos( angle );\n\n      return mat4( \n        c, 0,-s, 0,\n        0, 1, 0, 0,\n        s, 0, c, 0,\n        0, 0, 0, 1);  \n  }\n\n\n  mat4 rotZ( float angle ) {\n      float s = sin( angle );\n      float c = cos( angle );\n\n      return mat4( \n        c,-s, 0, 0, \n        s, c, 0, 0,\n        0, 0, 1, 0,\n        0, 0, 0, 1); \n  }\n\n  mat4 trans(vec3 trans) {\n    return mat4(\n      1, 0, 0, 0,\n      0, 1, 0, 0,\n      0, 0, 1, 0,\n      trans, 1);\n  }\n\n  mat4 ident() {\n    return mat4(\n      1, 0, 0, 0,\n      0, 1, 0, 0,\n      0, 0, 1, 0,\n      0, 0, 0, 1);\n  }\n\n  mat4 scale(vec3 s) {\n    return mat4(\n      s[0], 0, 0, 0,\n      0, s[1], 0, 0,\n      0, 0, s[2], 0,\n      0, 0, 0, 1);\n  }\n\n  mat4 uniformScale(float s) {\n    return mat4(\n      s, 0, 0, 0,\n      0, s, 0, 0,\n      0, 0, s, 0,\n      0, 0, 0, 1);\n  }\n\n  mat4 persp(float fov, float aspect, float zNear, float zFar) {\n    float f = tan(PI * 0.5 - 0.5 * fov);\n    float rangeInv = 1.0 / (zNear - zFar);\n\n    return mat4(\n      f / aspect, 0, 0, 0,\n      0, f, 0, 0,\n      0, 0, (zNear + zFar) * rangeInv, -1,\n      0, 0, zNear * zFar * rangeInv * 2., 0);\n  }\n\n  mat4 trInv(mat4 m) {\n    mat3 i = mat3(\n      m[0][0], m[1][0], m[2][0], \n      m[0][1], m[1][1], m[2][1], \n      m[0][2], m[1][2], m[2][2]);\n    vec3 t = -i * m[3].xyz;\n\n    return mat4(\n      i[0], t[0], \n      i[1], t[1],\n      i[2], t[2],\n      0, 0, 0, 1);\n  }\n\n  mat4 transpose(mat4 m) {\n    return mat4(\n      m[0][0], m[1][0], m[2][0], m[3][0], \n      m[0][1], m[1][1], m[2][1], m[3][1],\n      m[0][2], m[1][2], m[2][2], m[3][2],\n      m[0][3], m[1][3], m[2][3], m[3][3]);\n  }\n\n  mat4 lookAt(vec3 eye, vec3 target, vec3 up) {\n    vec3 zAxis = normalize(eye - target);\n    vec3 xAxis = normalize(cross(up, zAxis));\n    vec3 yAxis = cross(zAxis, xAxis);\n\n    return mat4(\n      xAxis, 0,\n      yAxis, 0,\n      zAxis, 0,\n      eye, 1);\n  }\n\n  mat4 inverse(mat4 m) {\n    float\n        a00 = m[0][0], a01 = m[0][1], a02 = m[0][2], a03 = m[0][3],\n        a10 = m[1][0], a11 = m[1][1], a12 = m[1][2], a13 = m[1][3],\n        a20 = m[2][0], a21 = m[2][1], a22 = m[2][2], a23 = m[2][3],\n        a30 = m[3][0], a31 = m[3][1], a32 = m[3][2], a33 = m[3][3],\n\n        b00 = a00 * a11 - a01 * a10,\n        b01 = a00 * a12 - a02 * a10,\n        b02 = a00 * a13 - a03 * a10,\n        b03 = a01 * a12 - a02 * a11,\n        b04 = a01 * a13 - a03 * a11,\n        b05 = a02 * a13 - a03 * a12,\n        b06 = a20 * a31 - a21 * a30,\n        b07 = a20 * a32 - a22 * a30,\n        b08 = a20 * a33 - a23 * a30,\n        b09 = a21 * a32 - a22 * a31,\n        b10 = a21 * a33 - a23 * a31,\n        b11 = a22 * a33 - a23 * a32,\n\n        det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;\n\n    return mat4(\n        a11 * b11 - a12 * b10 + a13 * b09,\n        a02 * b10 - a01 * b11 - a03 * b09,\n        a31 * b05 - a32 * b04 + a33 * b03,\n        a22 * b04 - a21 * b05 - a23 * b03,\n        a12 * b08 - a10 * b11 - a13 * b07,\n        a00 * b11 - a02 * b08 + a03 * b07,\n        a32 * b02 - a30 * b05 - a33 * b01,\n        a20 * b05 - a22 * b02 + a23 * b01,\n        a10 * b10 - a11 * b08 + a13 * b06,\n        a01 * b08 - a00 * b10 - a03 * b06,\n        a30 * b04 - a31 * b02 + a33 * b00,\n        a21 * b02 - a20 * b04 - a23 * b00,\n        a11 * b07 - a10 * b09 - a12 * b06,\n        a00 * b09 - a01 * b07 + a02 * b06,\n        a31 * b01 - a30 * b03 - a32 * b00,\n        a20 * b03 - a21 * b01 + a22 * b00) / det;\n  }\n#pragma region \n\n#pragma region Func \n   mat4 cameraLookAt(vec3 eye, vec3 target, vec3 up)\n   {\n    #if 1\n    return inverse(lookAt(eye, target, up));\n    #else\n    vec3 zAxis = normalize(target - eye);\n    vec3 xAxis = normalize(cross(up, zAxis));\n    vec3 yAxis = cross(zAxis, xAxis);\n\n    return mat4(\n      xAxis, 0,\n      yAxis, 0,\n      zAxis, 0,\n      -dot(xAxis, eye), -dot(yAxis, eye), -dot(zAxis, eye), 1);  \n    #endif\n\n  }\n  // hash function from https://www.shadertoy.com/view/4djSRW\n  float hash(float p) \n  {\n      vec2 p2 = fract(vec2(p * 5.3983, p * 5.4427));\n      p2 += dot(p2.yx, p2.xy + vec2(21.5351, 14.3137));\n      return fract(p2.x * p2.y * 95.4337);\n  }\n\n  float m1p1(float v) //normalize to NDC \n  {\n    return v * 2. - 1.;\n  }\n\n  float inv(float v) \n  {\n    return 1. - v;\n  }  \n\n\n\t\n#pragma endregion \n\n\n#pragma region Scene_Vertex_Collection \n  struct SceneVertex\n  {\n      vec3 vWorldPos;\n      vec3 vColor;\n      float fAlpha;\n  };\n\n  struct SurfaceInfo \n  {\n      vec3 vPos;\n      vec3 vNormal;\n      float fGloss;\n  };\n  struct SphereInfo\n  {\t\n\t  \n      vec3 vOrigin;\n      float fRadius ;  \n    \n    \n      \n      float fSlices ; \n      float fSegments ; \n  }; \n#pragma endregion  \n    \n\n\n#pragma region GetInfo \n\n\nvec3 GetSunDir()\n{\n  \treturn normalize( vec3( 1.0, 0.3, -0.5 ) );\n}\n\n\nvoid GetMatrixFromZY( const vec3 vZ, const vec3 vY, out mat3 m )\n{\n   vec3 vX = normalize( cross( vY, vZ ) );\n   vec3 vOrthoY = normalize( cross( vZ, vX ) );\n   m[0] = vX;\n   m[1] = vOrthoY;\n   m[2] = vZ;\n}\n\n\nvoid GetMatrixFromZ( vec3 vZAxis, out mat3 m )\n{\n  \tvec3 vZ = normalize(vZAxis);\n   \tvec3 vY = vec3( 0.0, 1.0, 0.0 );\n  \tif ( abs(vZ.y) > 0.99 )\n    {\n       vY = vec3( 1.0, 0.0, 0.0 );\n    }\n  \tGetMatrixFromZY( vZ, vY, m );\n}\n\n\nvoid GetQuadInfo(const float vertexIndex,\n                 out vec2 quadVertId,\n                 \n                 out float quadId )\n{\n    float twoTriVertexIndex = mod( vertexIndex, 6.0 );\n    float triVertexIndex = mod( vertexIndex, 3.0 );\n  \n    if \t\t( twoTriVertexIndex < 0.5 ) quadVertId = vec2( 0.0, 0.0 );\n    else if\t( twoTriVertexIndex < 1.5 )\tquadVertId = vec2( 1.0, 0.0 );\n    else if ( twoTriVertexIndex < 2.5 )\tquadVertId = vec2( 0.0, 1.0 );\n    else if ( twoTriVertexIndex < 3.5 )\tquadVertId = vec2( 1.0, 0.0 );\n    else if ( twoTriVertexIndex < 4.5 )\tquadVertId = vec2( 1.0, 1.0 );\n    else \t\t\t\t\t\t\t\tquadVertId = vec2( 0.0, 1.0 );\n\n    quadId = floor( vertexIndex / 6.0 );\n}\n\t\nvoid GetQuadTileInfo(const vec2 quadVertId,\n                     const float quadId,\n                     const vec2 vDim,\n                     \n                     out vec2 vQuadTileIndex,\n                     out vec2 vQuadUV )\n{\n    vQuadTileIndex.x = floor( mod( quadId, vDim.x ) );\n    vQuadTileIndex.y = floor( quadId / vDim.x );\n\n  \tvQuadUV.x = floor(quadVertId.x + vQuadTileIndex.x);\n    vQuadUV.y = floor(quadVertId.y + vQuadTileIndex.y);\n\n    vQuadUV = vQuadUV * (1.0 / vDim);\n}\n\n\nvoid GetQuadTileInfo(const float vertexIndex,\n                     const vec2 vDim,\n                     \n                     out vec2 vQuadTileIndex,\n                     out vec2 vQuadUV )\n{\n  \tvec2 quadVertId;\n  \tfloat quadId;\n\tGetQuadInfo( vertexIndex, quadVertId, quadId );  \n  \tGetQuadTileInfo( quadVertId, quadId, vDim, vQuadTileIndex, vQuadUV );   \n}\n\n\nfloat GetCosSunRadius()\n{\n  return 0.01;\n}\n\n\nfloat GetSunIntensity()\n{  \t\n  \treturn 0.001;\n}\n\nvec3 GetNormalToWorld(SphereInfo in_SI, vec3 in_Normal)\n{\n  return in_Normal ; \n}\nvec3 GetPosToWorld(SphereInfo in_SI, vec3 vPos)\n{\n  return in_SI.vOrigin + vPos ; \n}\nfloat GetSphereQuadCount(const SphereInfo in_SI)\n{\n    return in_SI.fSegments * in_SI.fSlices; \n}\nfloat GetSphereVertexCount(const SphereInfo in_SI)\n{   \n    return GetSphereQuadCount(in_SI) * 6.; \n}\n\nvec3 GetSunPosition()\n{\n  \tfloat fSunDistance = 14000.0;\n  \treturn vec3( 0.0, 0.1, 1.0 ) * fSunDistance;\n}\nvec3 GetSunDir( vec3 vCameraPos )\n{\n  \treturn normalize( GetSunPosition() - vCameraPos );\n}\n\n// From Shadertoy \"Hash without sine - Dave Hoskins\"\n// https://www.shadertoy.com/view/4djSRW\n#define MOD3 vec3(.1031,.11369,.13787)\n#define MOD4 vec4(.1031,.11369,.13787, .09987)\nfloat hash11(float p)\n{\n\tvec3 p3  = fract(vec3(p) * MOD3);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nvec4 hash41(float p)\n{\n\tvec4 p4 = fract(vec4(p) * MOD4);\n    p4 += dot(p4, p4.wzxy+19.19);\n    return fract(vec4((p4.x + p4.y)*p4.z, (p4.x + p4.z)*p4.y, (p4.y + p4.z)*p4.w, (p4.z + p4.w)*p4.x));\n    \n}\nfloat SmoothNoise(in vec2 o) \n{\n\tvec2 p = floor(o);\n\tvec2 f = fract(o);\n\t\t\n\tfloat n = p.x + p.y*57.0;\n\n\tfloat a = hash11(n+  0.0);\n\tfloat b = hash11(n+  1.0);\n\tfloat c = hash11(n+ 57.0);\n\tfloat d = hash11(n+ 58.0);\n\t\n\tvec2 f2 = f * f;\n\tvec2 f3 = f2 * f;\n\t\n\tvec2 t = 3.0 * f2 - 2.0 * f3;\n\t\n\tfloat u = t.x;\n\tfloat v = t.y;\n\n\tfloat res = a + (b-a)*u +(c-a)*v + (a-b+d-c)*u*v;\n    \n    return res;\n}\n\n//FBM step  \n#define k_fmbSteps 10\nfloat FBM( vec2 p, float repeat, float ps ) {\n\tfloat f = 0.0;\n    float tot = 0.0;\n    float a = 1.0;  \t\n    for( int i=0; i<k_fmbSteps; i++)\n    {\n        f += SmoothNoise( fract(p / repeat) * repeat ) * a;\n        p *= 2.0;\n        tot += a;\n        a *= ps;\n    }\n    return f / tot;\n}\n#pragma endregion      \n    \n#pragma region DrawScreen   \n    #define WidthX 16.0\n    #define HeightY 16.0\n    #define floorTileCount (WidthX * HeightY) \n    #define floorVertexCount (floorTileCount * 6.)\n    \n    #define aStrength 1. \n    #define dStrength 0.9  \n    #define sStrength 1.   \n    #define vLightPos vec3(0, 20, 0.)\n    #define vSunColor  vec3( 1.0, 0.8, 0.5 ) * 100.0\n    #define vFloorColor vec3(0.9, 0.8, 0.6) \n\tvoid ApplyLightC(const vec3 viewPos , vec3 in_normal , vec3 in_Pos,\n                     inout vec3 in_Color )\n    {\n      vec3 lightD = GetSunDir() ; \n      vec3 lightC = vSunColor ; \n      vec3 lightP = vLightPos ; \n      /*ambient*/\n\t  vec3 ambient = lightC * aStrength ;   \n      /*diffuse*/\n      vec3 l2SD = normalize(vLightPos - in_Pos);\n      float diff = max( dot(in_normal , l2SD), 0.);\n      vec3 diffuse = diff * dStrength * lightC;\n      /*specular*/\n      vec3 viewD = normalize(viewPos - in_Pos);\n      vec3 refDir = reflect(-l2SD , in_normal);\n\t  float spec = pow(max(dot(refDir , viewPos), 0.) , 64.0) ;\n      vec3 specualr = spec * sStrength * lightC ; \n      in_Color += ambient + diffuse + specualr ; \n      in_Color += vFloorColor ; \n    }\n    void AddDirectionalLight(vec3 vLightDir, vec3 vLightColor,const SurfaceInfo in_SI, const vec3 vCameraPos, \n                            inout vec3 vDiffuse, \n                            inout vec3 vSpecualr)\n    {\n      vec3 vViewDir = normalize(vCameraPos - in_SI.vPos) ; \n      \n      float normalDotLihgtDir = max(0.  , dot(vLightDir, in_SI.vPos));\n      \n      vec3 vHalfAngle = normalize(vViewDir + vLightDir);\n      \n      float normalDotheight = max(0. , dot(vHalfAngle, in_SI.vNormal)) ; \n      \n      vDiffuse += normalDotLihgtDir * vLightColor ; \n      \n      float fPower = in_SI.fGloss ; \n      \n      vSpecualr += pow( normalDotheight, fPower) *2. * normalDotLihgtDir * vLightColor; \n    }\n \tvec3 LightSurface(const SurfaceInfo in_SI,\n                      const vec3 vCamerapos,\n                      const vec3 vAlbedo, const float fShadow )\n    {\n      vec3 vDiffuseLight = vec3(0.) ; \n      vec3 vSpecLight = vec3(0.) ; \n      \n      AddDirectionalLight(GetSunDir(vCamerapos) , vSunColor * 0.01 * fShadow,\n                         in_SI, vCamerapos, \n                         vDiffuseLight, vSpecLight);\n      \n      vec3 vViewDir = normalize(vCamerapos - in_SI.vPos ) ; \n      \n      float fNdotD = clamp(dot(in_SI.vNormal, vViewDir) , 0. , 1.) ; \n      vec3 vR0 = vec3(0.04) ; \n      vec3 vFresnel = vR0 + (1.0 - vR0) * pow(1.0 - fNdotD, 5.0);  \n      \n    vec3 vColor = mix( vDiffuseLight * vAlbedo, vSpecLight, vFresnel );\n      \n      \n      return vColor; \n    }\n\tvoid GenSunSphere(const vec3 in_VertexId, const vec3 in_ViewPos, inout SceneVertex out_SceneVertex)\n    {\n      \n    }\n\t\n    void GenFloor( const vec3 in_ViewPos, const float vertexIndex, inout SceneVertex outSceneVertex )\n    { \n\t\tvec2 vDim = vec2( WidthX, HeightY );\n        vec2 vQuadTileIndex;\n\t\tvec2 vQuadUV; \n      /*Get the Current TileInfo*/\n\t\tGetQuadTileInfo( vertexIndex, vDim, vQuadTileIndex, vQuadUV );  \n        outSceneVertex.vWorldPos.xz = (vQuadUV * 2.0 - 1.0) * 100.0;  \n\t\toutSceneVertex.vWorldPos.y = 0.; \n\t\toutSceneVertex.fAlpha = 1.0;\n\t\toutSceneVertex.vColor = vec3(0.);\n\n\t\tvec3 vNormal = vec3( 0.0, 1.0, 0.0 );\n      /*Get the Surface Info*/\n      \tSurfaceInfo s_FloorS ; \n      \ts_FloorS.vPos = outSceneVertex.vWorldPos ; \n      \ts_FloorS.vNormal = vNormal ; \n      \ts_FloorS.fGloss = 5. ; \n      /*Apply the Color to hte scene color*/\n      \tApplyLightC(in_ViewPos , s_FloorS.vNormal , s_FloorS.vPos , outSceneVertex.vColor) ;  \n    }\n     \n\t#define f_Segments 64. \n\t#define f_Slices   48.  \n\t#define f_Origin   vec3(0.) \n\t#define f_Radius   5. \n\tvoid GenSphere(const float in_vertexIndex, const SphereInfo in_SI , const vec3 in_CamPos,\n                   out SceneVertex outSceneVertex)\n    {\n      vec2 vDim = vec2(in_SI.fSegments , in_SI.fSlices);\n      \n      vec2 vQuadTileIndex ; \n      vec2 vUV ; \n      GetQuadTileInfo(in_vertexIndex, vDim ,\n                      vQuadTileIndex,\n                      vUV);\n      \n      vec3 vSpherePos ; \n      float fElevation = vUV.y * PI ;  \n      vSpherePos.y = cos(fElevation);\n     /*setting up the Heading*/\n      float fHeading = vUV.x * PI * 2.  ; \n      float fSliceRadius = sqrt(1. - vSpherePos.y * vSpherePos.y);\n      vSpherePos.x = sin(fHeading ) * fSliceRadius  ; \n      vSpherePos.z = cos(fHeading ) * fSliceRadius  ; \n      \n      vec3 vSphereNormal = normalize(vSpherePos);\n      \n      vec3 vWorldNormal = GetNormalToWorld(in_SI , vSphereNormal);\n      outSceneVertex.vWorldPos = GetPosToWorld(in_SI, vSpherePos * in_SI.fRadius); \n      \n      /*Setting up the color view */ \n      SurfaceInfo t_SI ; \n      t_SI.vPos = outSceneVertex.vWorldPos ; \n      t_SI.vNormal  = vWorldNormal ; \n      t_SI.fGloss = 5. ;\n      \n      /*apply the light*/\n     // outSceneVertex.vColor = LightSurface(t_SI, in_CamPos, vec3(1.), 1.); ;\n      outSceneVertex.vColor = vec3(vWorldNormal) ; \n      outSceneVertex.fAlpha = 1. ; \n          \n    }\n#pragma endregion \n\n/* -------------------------------- display ------------------------------- */\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n/* -------------------------------- display ------------------------------- */\n\nvoid main()\n{ \n  #pragma region screenSetting \n\tSceneVertex sv ; \n\tvec2 vMouse = mouse ; \n  \tfloat vertexIndex = vertexId ; \n  #pragma endregion \n  \n  #pragma region Sphereinfo \n  \tSphereInfo sphereInfo ; \n \tsphereInfo.fSegments = 64.  ; //设置面数\n    sphereInfo.fSlices = 48.  ; // 设置细节\n    sphereInfo.vOrigin = vec3(0. ) ; //设置起始位置\n    sphereInfo.fRadius = 5. ; //设置半径 \n  #pragma endregion \n  \n  \n  \n  #pragma region ProjectionSetUp \n     mat4 m  = persp(radians(60.),\n                     resolution.x/ resolution.y, \n                     NEARCLIPPED , \n                     FARCLIPPED); \n  #pragma endregion \n\n  #pragma region CameraSetUp/ViewSetUp\n      vec3 target = vec3(0. ) ;\n      vec3 up = vec3(0. ,1. , 0. ) ;\n\t  //target = sv.vWorldPos; \n      vec3 camTarget = target ; \n      vec3 camPos = vec3(90. ,90. ,0.);  \n      vec3 camForward = normalize(camTarget - camPos);\n      m *= cameraLookAt(camPos , camTarget, normalize(up));\n  #pragma endregion \n\n  #pragma region model \n      m *= uniformScale(10.);\n    //  m *= trans(vec3(0.)) ;\n      m *= rotY(1. * time);\n  \t //m *= rotZ(sin(1. * time)); \n  #pragma endregion \n   \n\n  #pragma region Start to draw something \n/*\n    if(vertexIndex >= 0. && vertexIndex < floorVertexCount)\n      GenFloor(camPos , vertexId, sv) ; \n    vertexIndex -= floorTileCount ;  \n */\n  /*draw the sphere*/ \n  \tfloat fSphereVertexCount = GetSphereVertexCount(sphereInfo);\n    if(vertexIndex >= 0. && vertexIndex < fSphereVertexCount)\n    {\n      GenSphere(vertexIndex, sphereInfo, camPos,\n                sv);\n    }\n  \tvertexIndex -= fSphereVertexCount ; \n  \n  #pragma endregion \n  \n  \n  #pragma region add to glsl\n  \n    gl_Position = m * vec4(sv.vWorldPos, 1.); \n  \tgl_PointSize = 10. ; \n    v_color = vec4(sv.vColor * sv.fAlpha, sv.fAlpha);\n  #pragma endregion \n}"
  },
  "screenshotURL": "data/images/images-5wd2wj4qz4xdseqd6-thumbnail.jpg",
  "hasSound": true,
  "views": {
    "$numberInt": "97"
  },
  "likes": {
    "$numberInt": "0"
  },
  "revisionId": "sDb5oz5yeQwK3boix"
}