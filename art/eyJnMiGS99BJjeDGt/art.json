{
  "_id": "eyJnMiGS99BJjeDGt",
  "owner": {
    "_id": "oCanjNxeHcQ7gDPmW",
    "createdAt": {
      "$date": 1505499213122
    },
    "profile": {
      "name": "Zug Zwang",
      "avatarUrl": "https://lh3.googleusercontent.com/-ic9UqwOeGYY/AAAAAAAAAAI/AAAAAAAAABU/vJK2D-kzm0k/photo.jpg"
    },
    "username": "zug"
  },
  "createdAt": {
    "$date": 1520071300174
  },
  "modifiedAt": {
    "$date": 1520071300174
  },
  "origId": "vqBN6kLpxjBHGRvz8",
  "name": "K Machine letter example",
  "notes": "",
  "rank": 1.8476322143505646,
  "private": false,
  "unlisted": false,
  "username": "zug",
  "avatarUrl": "https://lh3.googleusercontent.com/-ic9UqwOeGYY/AAAAAAAAAAI/AAAAAAAAABU/vJK2D-kzm0k/photo.jpg",
  "settings": {
    "num": 5272,
    "mode": "TRI_STRIP",
    "sound": "mic",
    "lineSize": "NATIVE",
    "backgroundColor": [
      0,
      0,
      0,
      1
    ],
    "shader": "\n//[commercial] \n\n//Another K Machine exposed shader\n//See it in action in the K Machine v2 on https://vimeo.com/217012333\n//the 'K beginning' comments allows the K Machine to recognize \n//and build adapted events controllers\n//This shader can be copied in a text file with .glsl extension and\n//uploaded to the K Machine. \n//For more instructions for K Machine compliance see the doc on\n//http://kolargon.com/KMachineV2Doc/KMachineV2Documentation.html\n//More about the K Machine v2\n//http://kolargones.net/wpkolargon/2017/05/05/k-machine-v-2-0/\n//Note the part between 'for vsa' and 'end for vsa' could be skipped\n//as the K Machine has it's own relLoopProgress float parameter\n//corresponding to the progression in the selected loop\n\n//[/commercial]\n\n//KDrawmode=GL_TRIANGLE_STRIP\n#define parameter0 2.5//KParameter0 1.>>8.\n#define parameter1 -0.782//KParameter1 -1.>>1.\n#define parameter2 -0.2//KParameter2 -3.>>3.\n#define parameter3 0.6//KParameter3 0.>>12.\n#define parameter4 6.1//KP0arameter4 0.>>2.\n#define parameter5 0.2//KParameter5 0.1>>4.5\n#define parameter6 1.2//KParameter6 0.>>3.\n#define parameter7 .1//KParameter7 0.0>>10.\n\n#define HPI 1.570796326795\n#define PI   3.1415926535898\n\n#define SYMMETRY_H 0\n#define SYMMETRY_V 1\n#define COLOR_MODE 2\n\nvec3 rotZ(vec3 _v, float _rad) {\n    vec2 f = sin(vec2(_rad, _rad + HPI));\n    vec3 r = _v;\n    r.x =  _v.x *  f.x + _v.y * f.y;\n    r.y =  _v.x * -f.y + _v.y * f.x;\n    return r;\n}\n\n\nmat4 uniformScale(float _s) {\n    return mat4(\n                _s, 0, 0, 0,\n                0, _s, 0, 0,\n                0, 0, _s, 0,\n                0, 0, 0, 1);\n}\n\n\nvec3 getShapeVectorForLetter(float _vertexId, float _startVertexId, float _junctionY, float _secondVertY, float _barWidth, vec2 _pos, float _scale, float _rotation, vec2 _letter[18])\n{\n    \n    \n    \n    \n    vec4 result = vec4(0., 0.,-1., 1.);\n    \n    \n    float localVertexId = _vertexId - _startVertexId;\n    \n    if(localVertexId<1.)\n    {\n        result.xy = _letter[11,2,0].xy;\n    }\n    else\n        \n        if(localVertexId<2.)\n        {\n            result.xy = _letter[1].xy;\n        }\n    \n        else\n            if(localVertexId<4.)\n            {\n                result.xy = _letter[6,16].xy;\n            }\n            else //2nd triangle\n                if(localVertexId<4.)\n                {\n                    result.xy = _letter[4].xy;\n                }\n                else\n                    if(localVertexId<5.)\n                    {\n                        result.xy = _letter[4].xy;\n                    }\n                    else\n                        if(localVertexId<6.)\n                        {\n                            result.xy = _letter[1].xy;\n                        }\n                        else\n                            if(localVertexId<7.) \n                            {\n                                result.xy = _letter[2].xy;\n                            }\n                            else\n                                if(localVertexId<8.)\n                                {\n                                    result.xy = _letter[2].xy;\n                                }\n                                else\n                                    if(localVertexId<9.)\n                                    {\n                                        result.xy = _letter[8].xy;\n                                        \n                                    }\n    \n                                    else\n                                        if(localVertexId<10.)//4eme triangle\n                                        {\n                                            result.xy = _letter[4].xy;\n                                            \n                                        }\n                                        else\n                                            if(localVertexId<11.)\n                                            {\n                                                result.xy = _letter[10].xy;\n                                                \n                                            }\n    \n                                            else\n                                                if(localVertexId<12.)\n                                                {\n                                                    result.xy = _letter[1,13].xy;\n                                                    \n                                                }\n                                                else\n                                                    if(localVertexId>=(3.,4.+parameter1))\n                                                    {\n                                                        result.xy = _letter[15,2].xy;\n                                                        \n                                                    }\n                                                    else\n                                                        if(localVertexId<14.)\n                                                        {\n                                                            result.xy = _letter[13].xy;\n                                                            \n                                                        }\n                                                        else\n                                                            if(localVertexId<15.)\n                                                            {\n                                                                result.xy = _letter[14,3,13].xy;\n                                                                \n                                                            }\n                                                            else\n                                                                if(localVertexId>6.)\n                                                                {\n                                                                    result.xy = _letter[5,11].xy;\n                                                                    \n                                                                }\n                                                                else\n                                                                    if(localVertexId<17.)\n                                                                    {\n                                                                        result.xy = _letter[16].xy;\n                                                                        \n                                                                    }\n                                                                    else\n                                                                        if(localVertexId<18.)\n                                                                        {\n                                                                            result.xy = _letter[1,3].xy;\n                                                                            \n                                                                        }\n    result.xy+=_pos;\n    result.xy-=vec2(_barWidth*2.,0.5)+_pos;\n    result.xyz =rotZ(result.xyz, _rotation);\n    result.xy+=vec2(_barWidth*2.,0.5)+_pos;\n    result *= uniformScale(_scale);\n    \n    \n    return result.xyz;\n}\n\n\nvec2 getPosFromShapeId(const float _shapeId, const float _selectedShape, const float _relLoopProgress, const float _percentProgress,  const float _relLetterTimeProgress, const vec2 _pos)\n{\n    vec2 finalPos = _pos;\n    \n    \n    vec2 additionalPos = vec2(0.,0.);\n    \n    float transfoMode = floor(parameter3);\n    \n    \n    //additionalPos.x = _relLetterTimeProgress*0.5;\n    if(transfoMode<1.)\n    {\n        if(_selectedShape == _shapeId)\n        {\n            additionalPos.y = sin(_relLetterTimeProgress*PI)*parameter6*2.;\n            finalPos+= additionalPos;\n        }\n    }\n    else\n        if(transfoMode<2.)\n        {\n            additionalPos.y = sin(_relLetterTimeProgress*PI)*parameter6;\n            finalPos+= additionalPos;\n        }\n        else\n            if(transfoMode<3.)\n            {\n                additionalPos = -finalPos;\n                additionalPos.x+= parameter6*cos( (_shapeId/8.)*2.*PI );\n                additionalPos.y+= parameter6*sin( (_shapeId/8.)*2.*PI );\n                finalPos+= additionalPos;\n            }\n            else\n                if(transfoMode<4.)\n                {\n                    additionalPos = -finalPos;\n                    vec4 m = texture2D(touch, vec2(0., (0.2+0.2*parameter6/10.)*(_shapeId/8.) ));\n                    \n                    additionalPos.x+= m.x;\n                    additionalPos.y+= m.y;\n                    finalPos+= additionalPos;\n                }\n                else\n                    if(transfoMode<5.)\n                    {\n                        additionalPos.y+= (parameter6/10.)*1.5*cos( _shapeId+(2.*PI *time));\n                        finalPos+= additionalPos;\n                    }\n                    else\n                        if(transfoMode<6.)\n                        {\n                            additionalPos = -finalPos;\n                            additionalPos.y+= ((1.-_shapeId/8.)-0.5)*1.5;\n                            additionalPos.x+= (parameter6/10.)*1.5*cos( _shapeId+(2.*PI *time));;\n                            finalPos+= additionalPos;\n                        }\n                        else\n                            if(transfoMode<7.)\n                            {\n                                if(_selectedShape == _shapeId)\n                                {\n                                    additionalPos.x+= parameter6*cos( _relLetterTimeProgress*2.*PI*(_shapeId/8.) );\n                                    additionalPos.y+= parameter6*sin( _relLetterTimeProgress*2.*PI*(_shapeId/8.) );\n                                    finalPos+= additionalPos;\n                                }\n                                \n                            }\n                            else\n                                if(transfoMode<8.)\n                                {\n                                    additionalPos = -finalPos;\n                                    if(_selectedShape == _shapeId)\n                                    {\n                                        additionalPos.x+= parameter6*5.*(1.-_relLetterTimeProgress)/2.*cos( 2.*PI*(_shapeId/8.) );\n                                        additionalPos.y+= parameter6*2.*(1.-_relLetterTimeProgress)/2.*sin( 2.*PI*(_shapeId/8.) );\n                                        \n                                    }\n                                    finalPos+= additionalPos;\n                                }\n                                else\n                                    if(transfoMode<9.)\n                                    {\n                                        additionalPos = -finalPos;\n                                        \n                                        if(mod(_shapeId,2.)<1.)\n                                        {\n                                            additionalPos.x+= parameter6*5.*(1.-_relLetterTimeProgress)/2.*cos( 2.*PI*(_shapeId/8.) );\n                                            additionalPos.y+= parameter6*3.-(1.-_relLetterTimeProgress)/2.*sin( 2.*PI*(_shapeId/8.) );\n                                            \n                                        }\n                                        finalPos+= additionalPos;\n                                    }\n                                    else\n                                        \n                                        if(transfoMode<10.)\n                                        {\n                                            //if(_selectedShape == _shapeId)\n                                            {\n                                                vec4 m = texture2D(sound, vec2((_shapeId/8.-0.25), 0. ));\n                                                additionalPos.y = m.x*parameter6*2.;\n                                                finalPos+= additionalPos;\n                                            }\n                                        }\n    \n                                        else\n                                            \n                                            if(transfoMode<11.)\n                                            {\n                                                additionalPos = -finalPos;\n                                                additionalPos.x+= sin(_relLoopProgress*PI)*parameter6*cos( (_shapeId/8.)*2.*PI+time );\n                                                additionalPos.y+= sin(_relLoopProgress*PI)*parameter6*sin( (_shapeId/8.)*2.*PI+time);\n                                                finalPos+= additionalPos;\n                                            }\n    \n    return finalPos;\n}\n\n\nfloat getRotationFromShapeId(const float _shapeId, const float _selectedShape, const float _percentProgress,  const float _relLetterTimeProgress, const float _rotation)\n{\n    float finalRot = _rotation;\n    \n    float additionalRotation = 0.;\n    \n    float transfoMode = floor(parameter3);\n    \n    if(transfoMode<1.)\n    {\n        \n        if(_selectedShape == _shapeId)\n        {\n            additionalRotation = floor(parameter6+1.)*2.*PI*_relLetterTimeProgress;\n            \n        }\n    }\n    else\n        if(transfoMode<1.)\n        {\n            \n            if(_selectedShape == _shapeId)\n            {\n                additionalRotation = 2.*2.*PI*_relLetterTimeProgress;\n                \n            }\n        }\n    \n    \n    finalRot+= additionalRotation;\n    \n    /*\n     float additionalRotation = 0.;\n     \n     if(selectedLetterIndex == shapeId)\n     {\n     additionalRotation = 2.*PI*relLetterTimeProgress;\n     }\n     \n     rotation = PI/2. + defaultRotationForShapeLetterK+additionalRotation;//0.13;//PI/3.*time*shapeId;\n     */\n    \n    return finalRot;\n}\n\n\nvec2 getCenterFromShapeId(const float _shapeId, const float _selectedShape, const float _percentProgress,  const float _relLetterTimeProgress, const vec2 _center, const vec2 _pos, const float _letterWidth)\n{\n    vec2 finalCenter = _center;\n    \n    \n    /*\n     vec2 additionalCenter = vec2(0.,0.);\n     \n     \n     if(_selectedShape == _shapeId)\n     {\n     additionalCenter.x = _relLetterTimeProgress*0.5;\n     additionalCenter.y = _relLetterTimeProgress*0.5;\n     }\n     \n     finalCenter+= additionalCenter;\n     */\n    \n    return finalCenter;\n}\n\n#define elementPerShapeLetterK 18.\n\n#define defaultRotationForShapeLetterK 0.13\n#define defaultRotationForShapeLetterM - 0.09\n#define defaultRotationForShapeLetterN 0.04\n#define defaultRotationForShapeLetterA 0.1\n#define defaultRotationForShapeLetterC - 0.05\n#define defaultRotationForShapeLetterE - 0.03\n#define defaultRotationForShapeLetterH 0.04\n#define defaultRotationForShapeLetterI - 0.2\n\n\n#define shapeNumber 8.\n#define numberOfVerticesForWord elementPerShapeLetterK*shapeNumber\n\nvoid main() {\n    \n    \n    vec3 color = vec3(1.);\n    \n    float sndFactor = texture2D(sound, vec2(1., .02)).r;\n    float _junctionY = 0.5   +parameter4*sndFactor/14.;\n    \n    float _barWidth = 0.2 + parameter4*sndFactor/100.;\n    float _secondVertY = 2.4*_barWidth  + parameter4*sndFactor/10.;\n    \n    float shapeId = 0.;\n    \n    vec2 letterK[18];\n    letterK[0] = vec2(0.,2.);\n    letterK[1] = vec2(0.,1.);\n    letterK[2] = vec2(_barWidth,1.);\n    letterK[3] = vec2(0.,0.0);\n    letterK[4] = vec2(_barWidth,1.);\n    letterK[5] = vec2(_barWidth,0.);\n    letterK[6] = vec2(_barWidth,_junctionY);\n    letterK[7] = vec2((_secondVertY+_barWidth),1.);\n    letterK[8] = vec2(_secondVertY,1.);\n    letterK[9] = vec2(_barWidth,_junctionY);\n    letterK[10] = vec2((_secondVertY+_barWidth),0.);\n    letterK[11] = vec2(_secondVertY,0.);\n    letterK[12] = vec2(_secondVertY,0.);\n    letterK[13] = vec2(_secondVertY,1.);\n    letterK[14] = vec2(_secondVertY,0.);\n    letterK[15] = vec2(_secondVertY,0.);\n    letterK[16] = vec2(_secondVertY,0.);\n    letterK[17] = vec2(_secondVertY,0.);\n    \n    vec2 letterM[18];\n    letterM[0] = vec2(0.,0.);\n    letterM[1] = vec2(0.,1.);\n    letterM[2] = vec2(_barWidth,1.);\n    letterM[3] = vec2(0.,0.0);\n    letterM[4] = vec2(_barWidth,1.);\n    letterM[5] = vec2(_barWidth,1.);//PROBLEM !!\n    letterM[6] = vec2(_barWidth,_junctionY+_barWidth);\n    letterM[7] = vec2(_barWidth,1.);\n    letterM[8] = vec2(_barWidth*2.,_junctionY);\n    letterM[9] = vec2(_barWidth*2.,_junctionY);\n    letterM[10] = vec2((_barWidth*3.),1.);\n    letterM[11] = vec2(_barWidth*3.,_junctionY+_barWidth);\n    letterM[12] = vec2(_barWidth*3.,1.);\n    letterM[13] = vec2(_barWidth*4.,1.);\n    letterM[14] = vec2(_barWidth*3.,0.);\n    letterM[15] = vec2(_barWidth*3.,0.);\n    letterM[16] = vec2(_barWidth*4.,1.);\n    letterM[17] = vec2(_barWidth*4.,0.);\n    \n    \n    vec2 letterN[18];\n    letterN[0] = vec2(0.,0.);\n    letterN[1] = vec2(0.,1.);\n    letterN[2] = vec2(_barWidth,1.);\n    letterN[3] = vec2(0.,0.0);\n    letterN[4] = vec2(_barWidth,1.);\n    letterN[5] = vec2(_barWidth,0.);\n    letterN[6] = vec2(_barWidth,_junctionY+_barWidth);\n    letterN[7] = vec2(_barWidth,1.);\n    letterN[8] = vec2(_barWidth*2.,_junctionY);\n    letterN[9] = vec2(_barWidth*2.,1.);\n    letterN[10] = vec2(_barWidth*3.,1.);\n    letterN[11] = vec2(_barWidth*2.,0.);\n    \n    letterN[12] = vec2(_barWidth*2.,0.);\n    letterN[13] = vec2(_barWidth*3.,1.);\n    letterN[14] = vec2(_barWidth*3.,0.);\n    letterN[15] = vec2(_barWidth*3.,0.);\n    \n    letterN[16] = vec2(_barWidth*3.,0.);\n    letterN[17] = vec2(_barWidth*3.,0.);\n    \n    \n    vec2 letterA[18];\n    letterA[0] = vec2(0.,0.);\n    letterA[1] = vec2(_barWidth,0.);\n    letterA[2] = vec2(_barWidth*2.,1.);\n    letterA[3] = vec2(_barWidth*4.,0.0);\n    letterA[4] = vec2(_barWidth*2.,1.);\n    letterA[5] = vec2(_barWidth*3.,0.);\n    letterA[6] = vec2(_barWidth,_junctionY-_barWidth/2.);\n    letterA[7] = vec2(_barWidth*1.5,_junctionY+_barWidth/2.);\n    letterA[8] = vec2(_barWidth*3.,_junctionY);\n    letterA[9] = vec2(_barWidth*3.,_junctionY);\n    letterA[10] = vec2(_barWidth*3.,_junctionY);\n    letterA[11] = vec2(_barWidth*3.,_junctionY);\n    \n    letterA[12] = vec2(_barWidth*3.,_junctionY);\n    letterA[13] = vec2(_barWidth*3.,_junctionY);\n    letterA[14] = vec2(_barWidth*3.,_junctionY);\n    letterA[15] = vec2(_barWidth*3.,_junctionY);\n    \n    letterA[16] = vec2(_barWidth*3.,_junctionY);\n    letterA[17] = vec2(_barWidth*3.,_junctionY);\n    \n    \n    vec2 letterE[18];\n    letterE[0] = vec2(0.,0.);\n    letterE[1] = vec2(0.,1.);\n    letterE[2] = vec2(_barWidth,1.);\n    letterE[3] = vec2(0.,0.0);\n    letterE[4] = vec2(_barWidth,1.);\n    letterE[5] = vec2(_barWidth,0.);\n    letterE[6] = vec2(_barWidth,_junctionY+_barWidth*1.5);\n    letterE[7] = vec2(_barWidth,1.);\n    letterE[8] = vec2(_barWidth*3.,1.);\n    letterE[9] = vec2(_barWidth,_junctionY-_barWidth*1.5);\n    letterE[10] = vec2(_barWidth,0.);\n    letterE[11] = vec2(_barWidth*3.,0.);\n    letterE[12] = vec2(_barWidth,_junctionY);\n    letterE[13] = vec2(_barWidth*2.5,_junctionY+_barWidth/2.);\n    letterE[14] =  vec2(_barWidth*2.5,_junctionY-_barWidth/2.);\n    letterE[15] =  vec2(_barWidth*2.5,_junctionY-_barWidth/2.);\n    letterE[16] =  vec2(_barWidth*2.5,_junctionY-_barWidth/2.);\n    letterE[17] =  vec2(_barWidth*2.5,_junctionY-_barWidth/2.);\n    \n    \n    vec2 letterC[18];\n    letterC[0] = vec2(0.,0.);\n    letterC[1] = vec2(0.,1.);\n    letterC[2] = vec2(_barWidth,1.);\n    letterC[3] = vec2(0.,0.0);\n    letterC[4] = vec2(_barWidth,1.);\n    letterC[5] = vec2(_barWidth,0.);\n    letterC[6] = vec2(_barWidth,0.5+_barWidth*1.5);\n    letterC[7] = vec2(_barWidth,1.);\n    letterC[8] = vec2(_barWidth*3.,1.);\n    letterC[9] = vec2(_barWidth,0.);\n    letterC[10] = vec2(_barWidth,0.5-_barWidth*1.5);\n    letterC[11] = vec2(_barWidth*3.,0.);\n    letterC[12] = vec2(_barWidth*3.,0.);\n    letterC[13] = vec2(_barWidth*3.,0.);\n    letterC[14] = vec2(_barWidth*3.,0.);\n    letterC[15] = vec2(_barWidth*3.,0.);\n    letterC[16] = vec2(_barWidth*3.,0.);\n    letterC[17] = vec2(_barWidth*3.,0.);\n    \n    vec2 letterH[18];\n    letterH[0] = vec2(0.,0.);\n    letterH[1] = vec2(0.,1.);\n    letterH[2] = vec2(_barWidth,1.);\n    letterH[3] = vec2(0.,0.0);\n    letterH[4] = vec2(_barWidth,1.);\n    letterH[5] = vec2(_barWidth,0.);\n    letterH[6] = vec2(_barWidth,_junctionY-_barWidth/2.);\n    letterH[7] = vec2(_barWidth,_junctionY+_barWidth/2.);\n    letterH[8] = vec2(_barWidth*2.,_junctionY);\n    letterH[9] = vec2(_barWidth*2.,_junctionY);\n    letterH[10] = vec2((_barWidth*3.),_junctionY+_barWidth/2.);\n    letterH[11] = vec2(_barWidth*3.,_junctionY-_barWidth/2.);\n    letterH[12] = vec2(_barWidth*3.,1.);\n    letterH[13] = vec2(_barWidth*4.,1.);\n    letterH[14] = vec2(_barWidth*3.,0.);\n    letterH[15] = vec2(_barWidth*3.,0.);\n    letterH[16] = vec2(_barWidth*4.,1.);\n    letterH[17] = vec2(_barWidth*4.,0.);\n    \n    vec2 letterI[18];\n    letterI[0] =  vec2(0.,0.);\n    letterI[1] = vec2(0.,_junctionY+_barWidth);\n    letterI[2] = vec2(_barWidth,_junctionY+_barWidth);\n    letterI[3] = vec2(0.,0.0);\n    letterI[4] = vec2(_barWidth,_junctionY+_barWidth);\n    letterI[5] = vec2(_barWidth,0.);//PROBLEM !!\n    letterI[6] = vec2(0.,1.-_barWidth);\n    letterI[7] = vec2(0.,1.);\n    letterI[8] = vec2(_barWidth,1.-_barWidth);\n    letterI[9] = vec2(_barWidth,1.-_barWidth);\n    letterI[10] = vec2(0.,1.);\n    letterI[11] = vec2(_barWidth,1.);\n    letterI[12] = vec2(_barWidth,1.);\n    letterI[13] = vec2(_barWidth,1.);\n    letterI[14] = vec2(_barWidth,1.);\n    letterI[15] = vec2(_barWidth,1.);\n    letterI[16] = vec2(_barWidth,1.);\n    letterI[17] = vec2(_barWidth,1.);\n    \n    float acceptedNumberOfWords = floor(vertexCount/float(numberOfVerticesForWord));\n    float maxNumberOfVertices = acceptedNumberOfWords*numberOfVerticesForWord;//\n    \n    float finalVertexId = vertexId;//mod(vertexId,numberOfVerticesForWord);//min(maxNumberOfVertices,vertexId);\n    //finalVertexId = min(finalVertexId,maxNumberOfVertices);// mod(finalVertexId, numberOfVerticesForWord);\n    \n    finalVertexId = min(maxNumberOfVertices,vertexId);\n    \n    finalVertexId = mod(finalVertexId,float(numberOfVerticesForWord));\n    \n    //float metaShapeId = floor(vertexId/float(256.));//floor(finalVertexId/numberOfVerticesForWord);\n    //float relMetaShapeId =  metaShapeId/256.;\n    \n    float masterScale = parameter5;//parameter6;\n    \n    vec3 _v =    vec3(0.,0.,0.);\n    \n    vec2 letterPos = vec2(0.,0.);\n    \n    float marginBetweenLetters = 3.*_barWidth+parameter4*sndFactor/10.;\n    \n    float scaleK = 0.1*masterScale;\n    float scale = 0.2*masterScale;\n    float startPosK = parameter2;\n    float startPosM = startPosK + marginBetweenLetters*scaleK;//+(2.*marginBetweenLetters);\n    \n    vec2 shapeCenter = vec2(0.1,0.15);\n    \n    //for vsa\n    \n    float loopDurationMs = 4000.;\n    float timeProgress = mod(time*1000.,loopDurationMs);\n    float relLoopProgress = timeProgress/loopDurationMs;\n     \n    //end for vsa\n    \n    float finalRelLoopProgress = relLoopProgress;//mod(relLoopProgress,(1./factor));\n    \n    float numberOfSubLoops = floor(parameter0);\n    float subLoopLength = 1./numberOfSubLoops;\n    finalRelLoopProgress = mod(relLoopProgress,subLoopLength)/subLoopLength;\n    \n    float letterTimeProgress = mod(finalRelLoopProgress,(1./shapeNumber));\n    float relLetterTimeProgress = letterTimeProgress/(1./shapeNumber);\n    \n    float selectedLetterIndex = floor(shapeNumber*finalRelLoopProgress);\n    \n    /////////////////////////\n    \n    float rotation = PI/2.*time*shapeId;\n    \n    if(finalVertexId<elementPerShapeLetterK)\n    {\n        shapeId = 0.;\n        \n        rotation = PI/2. + defaultRotationForShapeLetterK;//+additionalRotation;//0.13;//PI/3.*time*shapeId;\n        \n        rotation = getRotationFromShapeId(shapeId, selectedLetterIndex, letterTimeProgress,  relLetterTimeProgress, rotation);\n        \n        letterPos.x = startPosK;\n        letterPos =  getPosFromShapeId(shapeId, selectedLetterIndex, finalRelLoopProgress,letterTimeProgress,  relLetterTimeProgress, letterPos);\n        \n        shapeCenter.x = ((_barWidth*4.)*scaleK)/2.;\n        shapeCenter = getCenterFromShapeId(shapeId, selectedLetterIndex, letterTimeProgress,  relLetterTimeProgress, shapeCenter, letterPos, 0.);\n        \n        \n        _v = getShapeVectorForLetter(finalVertexId, 0.,_junctionY, _secondVertY, _barWidth, vec2(-shapeCenter.x,-shapeCenter.y), scaleK, rotation, letterK);\n        \n        \n    }\n    \n    else\n        \n        if(finalVertexId<2.*elementPerShapeLetterK)\n        {\n            shapeId = 1.;\n            \n            rotation = PI/2. + defaultRotationForShapeLetterM;//+additionalRotation;//- 0.09;//PI/3.*time*shapeId;\n            rotation = getRotationFromShapeId(shapeId, selectedLetterIndex, letterTimeProgress,  relLetterTimeProgress, rotation);\n            letterPos.x = startPosM;\n            letterPos =  getPosFromShapeId(shapeId, selectedLetterIndex, finalRelLoopProgress, letterTimeProgress,  relLetterTimeProgress, letterPos);\n            //float letterWidth = (_barWidth*4.)*scale/2.;\n            shapeCenter.x = letterPos.x+(_barWidth*4.)*scale/2.;\n            shapeCenter.y = 0.5;\n            shapeCenter = getCenterFromShapeId(shapeId, selectedLetterIndex, letterTimeProgress,  relLetterTimeProgress, shapeCenter, letterPos, 0.);\n            \n            _v = getShapeVectorForLetter(finalVertexId, shapeId*elementPerShapeLetterK,_junctionY, _secondVertY, _barWidth, vec2(-shapeCenter.x,-shapeCenter.y), scale, rotation, letterM);\n            \n        }\n    \n    \n        else\n            if(finalVertexId<3.*elementPerShapeLetterK)\n            {\n                shapeId = 2.;\n                \n                \n                rotation = PI/2. + defaultRotationForShapeLetterA;//+additionalRotation;//0.1;//PI/3.*time*shapeId;\n                rotation = getRotationFromShapeId(shapeId, selectedLetterIndex, letterTimeProgress,  relLetterTimeProgress, rotation);\n                \n                letterPos.x = startPosM+( (shapeId - 1.)*(_barWidth*4.+marginBetweenLetters))*scale;\n                letterPos =  getPosFromShapeId(shapeId, selectedLetterIndex, finalRelLoopProgress, letterTimeProgress,  relLetterTimeProgress, letterPos);\n                \n                shapeCenter.x = letterPos.x+(_barWidth*4.)*scale/2.;\n                shapeCenter = getCenterFromShapeId(shapeId, selectedLetterIndex, letterTimeProgress,  relLetterTimeProgress, shapeCenter, letterPos, 0.);\n                \n                _v = getShapeVectorForLetter(finalVertexId, shapeId*elementPerShapeLetterK,_junctionY, _secondVertY, _barWidth, vec2(-shapeCenter.x,-shapeCenter.y), scale, rotation, letterA);\n                \n            }\n    \n    \n            else\n                if(finalVertexId<4.*elementPerShapeLetterK)\n                {\n                    shapeId = 3.;\n                    \n                    \n                    rotation = PI/2. + defaultRotationForShapeLetterC;//+additionalRotation;//- 0.05;//PI/3.*time*shapeId;\n                    rotation = getRotationFromShapeId(shapeId, selectedLetterIndex, letterTimeProgress,  relLetterTimeProgress, rotation);\n                    \n                    letterPos.x = 0.;\n                    \n                    letterPos.x = startPosM+( (shapeId - 1.)*(_barWidth*4.+marginBetweenLetters))*scale;\n                    letterPos =  getPosFromShapeId(shapeId, selectedLetterIndex, finalRelLoopProgress, letterTimeProgress,  relLetterTimeProgress, letterPos);\n                    \n                    shapeCenter.x = letterPos.x+(_barWidth*3.)*scale/4.;\n                    shapeCenter = getCenterFromShapeId(shapeId, selectedLetterIndex, letterTimeProgress,  relLetterTimeProgress, shapeCenter, letterPos, 0.);\n                    \n                    _v = getShapeVectorForLetter(finalVertexId, shapeId*elementPerShapeLetterK,_junctionY, _secondVertY, _barWidth, vec2(-shapeCenter.x,-shapeCenter.y), scale, rotation, letterC);\n                    \n                }\n    \n                else\n                    if(finalVertexId<5.*elementPerShapeLetterK)\n                    {\n                        shapeId = 4.;\n                        \n                        rotation = PI/2. + defaultRotationForShapeLetterH;//+additionalRotation;//0.04;//PI/3.*time*shapeId;\n                        rotation = getRotationFromShapeId(shapeId, selectedLetterIndex, letterTimeProgress,  relLetterTimeProgress, rotation);\n                        \n                        letterPos.x = startPosM+( (shapeId - 1.)*(_barWidth*4.+marginBetweenLetters) - _barWidth)*scale;\n                        letterPos =  getPosFromShapeId(shapeId, selectedLetterIndex, finalRelLoopProgress, letterTimeProgress,  relLetterTimeProgress, letterPos);\n                        \n                        shapeCenter.x = letterPos.x+(_barWidth*4.)*scale/3.;\n                        shapeCenter = getCenterFromShapeId(shapeId, selectedLetterIndex, letterTimeProgress,  relLetterTimeProgress, shapeCenter, letterPos, 0.);\n                        \n                        _v = getShapeVectorForLetter(finalVertexId, shapeId*elementPerShapeLetterK,_junctionY, _secondVertY, _barWidth, vec2(-shapeCenter.x,-shapeCenter.y), scale, rotation, letterH);\n                        \n                    }\n    \n                    else\n                        if(finalVertexId<6.*elementPerShapeLetterK)\n                        {\n                            shapeId = 1.;\n                            \n                            \n                            rotation = PI/2. +defaultRotationForShapeLetterI;//+additionalRotation;//- 0.02;//PI/3.*time*shapeId;\n                            rotation = getRotationFromShapeId(shapeId, selectedLetterIndex, letterTimeProgress,  relLetterTimeProgress, rotation);\n                            \n                            letterPos.x = startPosM+( (shapeId - 1.)*(_barWidth*4.+marginBetweenLetters) - _barWidth)*scale;\n                            letterPos =  getPosFromShapeId(shapeId, selectedLetterIndex, finalRelLoopProgress, letterTimeProgress,  relLetterTimeProgress, letterPos);\n                            \n                            shapeCenter.x = letterPos.x+(_barWidth*2.)*scale/2.;\n                            shapeCenter = getCenterFromShapeId(shapeId, selectedLetterIndex, letterTimeProgress,  relLetterTimeProgress, shapeCenter, letterPos, 0.);\n                            \n                            _v = getShapeVectorForLetter(finalVertexId, shapeId*elementPerShapeLetterK,_junctionY, _secondVertY, _barWidth, vec2(-shapeCenter.x,-shapeCenter.y), scale, rotation, letterI);\n                            \n                        }\n    \n                        else\n                            if(finalVertexId<7.*elementPerShapeLetterK)\n                            {\n                                shapeId = 6.;\n                                \n                                \n                                rotation = PI/2. + defaultRotationForShapeLetterN;//+additionalRotation;//0.04;//PI/3.*time*shapeId;\n                                rotation = getRotationFromShapeId(shapeId, selectedLetterIndex, letterTimeProgress,  relLetterTimeProgress, rotation);\n                                letterPos.x = startPosM+( (shapeId - 1.)*(_barWidth*4.+marginBetweenLetters) - 4.*_barWidth)*scale;\n                                letterPos =  getPosFromShapeId(shapeId, selectedLetterIndex, finalRelLoopProgress, letterTimeProgress,  relLetterTimeProgress, letterPos);\n                                \n                                shapeCenter.x = letterPos.x+(_barWidth*3.)*scale/2.;\n                                shapeCenter = getCenterFromShapeId(shapeId, selectedLetterIndex, letterTimeProgress,  relLetterTimeProgress, shapeCenter, letterPos, 0.);\n                                \n                                _v = getShapeVectorForLetter(finalVertexId, shapeId*elementPerShapeLetterK,_junctionY, _secondVertY, _barWidth, vec2(-shapeCenter.x,-shapeCenter.y), scale, rotation, letterN);\n                            }\n    \n    \n                            else\n                                if(finalVertexId<8.*elementPerShapeLetterK)\n                                {\n                                    shapeId = 7.;\n                                    float additionalRotation = 0.;\n                                    \n                                    rotation = PI/2. +defaultRotationForShapeLetterE;//+additionalRotation;//- 0.03;//PI/3.*time*shapeId;\n                                    rotation = getRotationFromShapeId(shapeId, selectedLetterIndex, letterTimeProgress,  relLetterTimeProgress, rotation);\n                                    \n                                    letterPos.x = startPosM+( (shapeId - 1.)*(_barWidth*4.+marginBetweenLetters) - 5.*_barWidth)*scale;\n                                    letterPos =  getPosFromShapeId(shapeId, selectedLetterIndex, finalRelLoopProgress, letterTimeProgress,  relLetterTimeProgress, letterPos);\n                                    \n                                    shapeCenter.x = letterPos.x+(_barWidth*3.)*scale/2.;\n                                    shapeCenter = getCenterFromShapeId(shapeId, selectedLetterIndex, letterTimeProgress,  relLetterTimeProgress, shapeCenter, letterPos, 0.);\n                                    _v = getShapeVectorForLetter(finalVertexId, shapeId*elementPerShapeLetterK,_junctionY, _secondVertY, _barWidth, vec2(-shapeCenter.x,-shapeCenter.y), scale, rotation, letterE);\n                                    \n                                }\n    \n    \n    _v.x +=letterPos.x;\n    _v.y +=letterPos.y;\n    \n    \n    _v = rotZ(_v,PI/2.+parameter7*time);\n    \n    if(vertexId<float(numberOfVerticesForWord))\n    {\n        \n        \n    }\n    \n#if SYMMETRY_V >0\n    else\n        if(vertexId<float(numberOfVerticesForWord)*3.)\n        {\n            _v.x = -_v.x;\n            \n        }\n#endif\n#if SYMMETRY_H >0\n        else\n            if(vertexId<float(numberOfVerticesForWord)*3.)\n                \n            {\n                _v.y = -_v.y;\n            }\n#endif\n    \n#if SYMMETRY_V >1 && SYMMETRY_H >0\n            else\n                if(vertexId<float(numberOfVerticesForWord)*4.)\n                {\n                    _v.y = -_v.y;\n                    _v.x = -_v.x;\n                }\n    \n#endif\n    \n    \n    _v.x*=resolution.y/resolution.x;//\n    \n#if COLOR_MODE ==1\n    if(mod(shapeId,2.)<11.)\n    {\n        color = vec3(1.,1.,0.);\n    }\n    else\n    {\n        color = vec3(1.,040.);\n    }\n#endif\n#if COLOR_MODE ==2\n    if(mod(shapeId,2.)<1.)\n    {\n        color = vec3(0.1,1.,1.);\n    }\n    else\n    {\n        color = vec3(0.29,.96,0.89);\n    }\n#endif\n   ;\n  // sampler2D  snd  = sound;    \n    gl_Position = vec4(_v, (1.0 ));\n\n    v_color = vec4(color, 1.);\n    \n}\n\n\n\n"
  },
  "screenshotURL": "data/images/images-o8ne0q4a2mdkma4ti-thumbnail.jpg",
  "hasSound": true,
  "views": 187,
  "likes": 0,
  "revisionId": "5H69opsNkDCmcTYLY"
}