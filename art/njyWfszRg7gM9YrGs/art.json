{
  "_id": "njyWfszRg7gM9YrGs",
  "owner": {
    "username": "anon"
  },
  "createdAt": {
    "$date": {
      "$numberLong": "1583771588064"
    }
  },
  "modifiedAt": {
    "$date": {
      "$numberLong": "1583771588064"
    }
  },
  "origId": "7qtbHrwZAwuFQLxhC",
  "name": "shadow_test",
  "notes": "",
  "rank": {
    "$numberDouble": "1.546289885972261"
  },
  "private": false,
  "unlisted": false,
  "username": "-anon-",
  "avatarUrl": "",
  "settings": "{\"num\":24579,\"mode\":\"TRIANGLES\",\"sound\":\"\",\"lineSize\":\"NATIVE\",\"backgroundColor\":[0.403921568627451,0.403921568627451,0.403921568627451,1],\"shader\":\"\\n#define COLOR_SUNSET\\n\\n#ifdef COLOR_PASTEL\\n\\nvec3 gSunColor = vec3(1.0, 0.9, 0.1) * 0.0;  \\n\\nvec3 gSkyTop =  vec3( 0.1, 0.2, 0.8 ) * 4.0;\\nvec3 gSkyBottom = vec3( 0.5, 0.8, 1.0 ) * 5.0;\\n\\nfloat gFogDensity = 0.01;\\n\\n\\tvec3 gFloorColor = vec3(0.5, 0.1, 0.2);\\nvec3 gCubeColor = vec3(1.0, 0.8, 0.8);\\nfloat gExposure = 1.0;\\n\\nfloat gCubeColorRandom = 0.4;\\n\\n#endif\\n\\n#ifdef COLOR_VIVID\\n\\nvec3 gSunColor = vec3(1.0, 0.9, 0.1) * 10.0;  \\n\\nvec3 gSkyTop =  vec3( 0.1, 0.2, 0.8 ) * 0.5;\\nvec3 gSkyBottom = vec3( 0.5, 0.8, 1.0 ) * 1.5;\\n\\nfloat gFogDensity = 0.05;\\n\\n\\tvec3 gFloorColor = vec3(0.5, 0.1, 0.2);\\nvec3 gCubeColor = vec3(1.0, 0.1, 1.0);\\nfloat gExposure = 1.0;\\n\\nfloat gCubeColorRandom = 0.9;\\n\\n#endif \\n\\n#pragma region Pre_Define\\n\\t#define PI radians(180.)\\n#pragma endregion \\n\\n#pragma region const\\n\\tconst float FARCLIPPED = 1000.  ;\\n\\tconst float NEARCLIPPED = 0.1\\t  ; \\n    float g_cameraFar = 1000.0;\\n\\n#pragma endregion \\n\\n\\n#pragma region MatrixConverte \\n\\t\\n  mat4 mAspect = mat4\\n  (\\n    1, 0, 0, 0,\\n    0, resolution.x / resolution.y, 0, 0,\\n    0, 0, 1, 0,\\n    0, 0, 0, 1\\n  ); \\n  vec3 hsv2rgb(vec3 c) {\\n    c = vec3(c.x, clamp(c.yz, 0.0, 1.0));\\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\\n  }\\n\\n\\n  mat4 rotY( float angle ) {\\n      float s = sin( angle );\\n      float c = cos( angle );\\n\\n      return mat4( \\n        c, 0,-s, 0,\\n        0, 1, 0, 0,\\n        s, 0, c, 0,\\n        0, 0, 0, 1);  \\n  }\\n\\n\\n  mat4 rotZ( float angle ) {\\n      float s = sin( angle );\\n      float c = cos( angle );\\n\\n      return mat4( \\n        c,-s, 0, 0, \\n        s, c, 0, 0,\\n        0, 0, 1, 0,\\n        0, 0, 0, 1); \\n  }\\n\\n  mat4 trans(vec3 trans) {\\n    return mat4(\\n      1, 0, 0, 0,\\n      0, 1, 0, 0,\\n      0, 0, 1, 0,\\n      trans, 1);\\n  }\\n\\n  mat4 ident() {\\n    return mat4(\\n      1, 0, 0, 0,\\n      0, 1, 0, 0,\\n      0, 0, 1, 0,\\n      0, 0, 0, 1);\\n  }\\n\\n  mat4 scale(vec3 s) {\\n    return mat4(\\n      s[0], 0, 0, 0,\\n      0, s[1], 0, 0,\\n      0, 0, s[2], 0,\\n      0, 0, 0, 1);\\n  }\\n\\n  mat4 uniformScale(float s) {\\n    return mat4(\\n      s, 0, 0, 0,\\n      0, s, 0, 0,\\n      0, 0, s, 0,\\n      0, 0, 0, 1);\\n  }\\n\\n  mat4 persp(float fov, float aspect, float zNear, float zFar) {\\n    float f = tan(PI * 0.5 - 0.5 * fov);\\n    float rangeInv = 1.0 / (zNear - zFar);\\n\\n    return mat4(\\n      f / aspect, 0, 0, 0,\\n      0, f, 0, 0,\\n      0, 0, (zNear + zFar) * rangeInv, -1,\\n      0, 0, zNear * zFar * rangeInv * 2., 0);\\n  }\\n\\n  mat4 trInv(mat4 m) {\\n    mat3 i = mat3(\\n      m[0][0], m[1][0], m[2][0], \\n      m[0][1], m[1][1], m[2][1], \\n      m[0][2], m[1][2], m[2][2]);\\n    vec3 t = -i * m[3].xyz;\\n\\n    return mat4(\\n      i[0], t[0], \\n      i[1], t[1],\\n      i[2], t[2],\\n      0, 0, 0, 1);\\n  }\\n\\n  mat4 transpose(mat4 m) {\\n    return mat4(\\n      m[0][0], m[1][0], m[2][0], m[3][0], \\n      m[0][1], m[1][1], m[2][1], m[3][1],\\n      m[0][2], m[1][2], m[2][2], m[3][2],\\n      m[0][3], m[1][3], m[2][3], m[3][3]);\\n  }\\n\\n  mat4 lookAt(vec3 eye, vec3 target, vec3 up) {\\n    vec3 zAxis = normalize(eye - target);\\n    vec3 xAxis = normalize(cross(up, zAxis));\\n    vec3 yAxis = cross(zAxis, xAxis);\\n\\n    return mat4(\\n      xAxis, 0,\\n      yAxis, 0,\\n      zAxis, 0,\\n      eye, 1);\\n  }\\n\\n  mat4 inverse(mat4 m) {\\n    float\\n        a00 = m[0][0], a01 = m[0][1], a02 = m[0][2], a03 = m[0][3],\\n        a10 = m[1][0], a11 = m[1][1], a12 = m[1][2], a13 = m[1][3],\\n        a20 = m[2][0], a21 = m[2][1], a22 = m[2][2], a23 = m[2][3],\\n        a30 = m[3][0], a31 = m[3][1], a32 = m[3][2], a33 = m[3][3],\\n\\n        b00 = a00 * a11 - a01 * a10,\\n        b01 = a00 * a12 - a02 * a10,\\n        b02 = a00 * a13 - a03 * a10,\\n        b03 = a01 * a12 - a02 * a11,\\n        b04 = a01 * a13 - a03 * a11,\\n        b05 = a02 * a13 - a03 * a12,\\n        b06 = a20 * a31 - a21 * a30,\\n        b07 = a20 * a32 - a22 * a30,\\n        b08 = a20 * a33 - a23 * a30,\\n        b09 = a21 * a32 - a22 * a31,\\n        b10 = a21 * a33 - a23 * a31,\\n        b11 = a22 * a33 - a23 * a32,\\n\\n        det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;\\n\\n    return mat4(\\n        a11 * b11 - a12 * b10 + a13 * b09,\\n        a02 * b10 - a01 * b11 - a03 * b09,\\n        a31 * b05 - a32 * b04 + a33 * b03,\\n        a22 * b04 - a21 * b05 - a23 * b03,\\n        a12 * b08 - a10 * b11 - a13 * b07,\\n        a00 * b11 - a02 * b08 + a03 * b07,\\n        a32 * b02 - a30 * b05 - a33 * b01,\\n        a20 * b05 - a22 * b02 + a23 * b01,\\n        a10 * b10 - a11 * b08 + a13 * b06,\\n        a01 * b08 - a00 * b10 - a03 * b06,\\n        a30 * b04 - a31 * b02 + a33 * b00,\\n        a21 * b02 - a20 * b04 - a23 * b00,\\n        a11 * b07 - a10 * b09 - a12 * b06,\\n        a00 * b09 - a01 * b07 + a02 * b06,\\n        a31 * b01 - a30 * b03 - a32 * b00,\\n        a20 * b03 - a21 * b01 + a22 * b00) / det;\\n  }\\n#pragma region \\n\\n#pragma region Func \\n   mat4 cameraLookAt(vec3 eye, vec3 target, vec3 up)\\n   {\\n    #if 1\\n    return inverse(lookAt(eye, target, up));\\n    #else\\n    vec3 zAxis = normalize(target - eye);\\n    vec3 xAxis = normalize(cross(up, zAxis));\\n    vec3 yAxis = cross(zAxis, xAxis);\\n\\n    return mat4(\\n      xAxis, 0,\\n      yAxis, 0,\\n      zAxis, 0,\\n      -dot(xAxis, eye), -dot(yAxis, eye), -dot(zAxis, eye), 1);  \\n    #endif\\n\\n  }\\n  // hash function from https://www.shadertoy.com/view/4djSRW\\n  float hash(float p) \\n  {\\n      vec2 p2 = fract(vec2(p * 5.3983, p * 5.4427));\\n      p2 += dot(p2.yx, p2.xy + vec2(21.5351, 14.3137));\\n      return fract(p2.x * p2.y * 95.4337);\\n  }\\n\\n  float m1p1(float v) //normalize to NDC \\n  {\\n    return v * 2. - 1.;\\n  }\\n\\n  float inv(float v) \\n  {\\n    return 1. - v;\\n  }  \\n\\n\\n\\t\\n#pragma endregion \\n\\n\\n#pragma region Scene_Vertex_Collection \\n  struct SceneVertex\\n  {\\n      vec3 vWorldPos;\\n      vec3 vColor;\\n      float fAlpha;\\n  };\\n\\n  struct SurfaceInfo \\n  {\\n      vec3 vPos;\\n      vec3 vNormal;\\n      float fGloss;\\n  };\\n  struct SphereInfo\\n  {\\t \\n      vec3 vOrigin;\\n      float fRadius ;   \\n      \\n      float fSlices ; \\n      float fSegments ; \\n  }; \\n    \\n  struct Material \\n  {\\n      vec4 diffuseAlebdo;\\n      vec3 FresenlR0 ;\\n      float Roughness ;\\n      mat4 MatTransform ; \\n  }; \\n  struct Light\\n  {\\n\\n      vec3 vStrength ; \\n      float FalloffStart ; \\n      vec3 vDirection  ; \\n      float FalloffEnd ; \\n      vec3 vPosition ; \\n      float SpotPower ; \\n  };\\n#pragma endregion  \\n    \\n\\n\\n#pragma region GetInfo \\n\\n\\nvec3 GetSunDir()\\n{\\n  \\treturn normalize( vec3( 1.0, 0.3, -0.5 ) );\\n}\\n\\n\\nvoid GetMatrixFromZY( const vec3 vZ, const vec3 vY, out mat3 m )\\n{\\n   vec3 vX = normalize( cross( vY, vZ ) );\\n   vec3 vOrthoY = normalize( cross( vZ, vX ) );\\n   m[0] = vX;\\n   m[1] = vOrthoY;\\n   m[2] = vZ;\\n}\\n\\n\\nvoid GetMatrixFromZ( vec3 vZAxis, out mat3 m )\\n{\\n  \\tvec3 vZ = normalize(vZAxis);\\n   \\tvec3 vY = vec3( 0.0, 1.0, 0.0 );\\n  \\tif ( abs(vZ.y) > 0.99 )\\n    {\\n       vY = vec3( 1.0, 0.0, 0.0 );\\n    }\\n  \\tGetMatrixFromZY( vZ, vY, m );\\n}\\n\\n\\nvoid GetQuadInfo(const float vertexIndex,\\n                 out vec2 quadVertId,\\n                 \\n                 out float quadId )\\n{\\n    float twoTriVertexIndex = mod( vertexIndex, 6.0 );\\n    float triVertexIndex = mod( vertexIndex, 3.0 );\\n  \\n    if \\t\\t( twoTriVertexIndex < 0.5 ) quadVertId = vec2( 0.0, 0.0 );\\n    else if\\t( twoTriVertexIndex < 1.5 )\\tquadVertId = vec2( 1.0, 0.0 );\\n    else if ( twoTriVertexIndex < 2.5 )\\tquadVertId = vec2( 0.0, 1.0 );\\n    else if ( twoTriVertexIndex < 3.5 )\\tquadVertId = vec2( 1.0, 0.0 );\\n    else if ( twoTriVertexIndex < 4.5 )\\tquadVertId = vec2( 1.0, 1.0 );\\n    else \\t\\t\\t\\t\\t\\t\\t\\tquadVertId = vec2( 0.0, 1.0 );\\n\\n    quadId = floor( vertexIndex / 6.0 );\\n}\\n\\t\\nvoid GetQuadTileInfo(const vec2 quadVertId,\\n                     const float quadId,\\n                     const vec2 vDim,\\n                     \\n                     out vec2 vQuadTileIndex,\\n                     out vec2 vQuadUV )\\n{\\n    vQuadTileIndex.x = floor( mod( quadId, vDim.x ) );\\n    vQuadTileIndex.y = floor( quadId / vDim.x );\\n\\n  \\tvQuadUV.x = floor(quadVertId.x + vQuadTileIndex.x);\\n    vQuadUV.y = floor(quadVertId.y + vQuadTileIndex.y);\\n\\n    vQuadUV = vQuadUV * (1.0 / vDim);\\n}\\n\\n\\nvoid GetQuadTileInfo(const float vertexIndex,\\n                     const vec2 vDim,\\n                     \\n                     out vec2 vQuadTileIndex,\\n                     out vec2 vQuadUV )\\n{\\n  \\tvec2 quadVertId;\\n  \\tfloat quadId;\\n\\tGetQuadInfo( vertexIndex, quadVertId, quadId );  \\n  \\tGetQuadTileInfo( quadVertId, quadId, vDim, vQuadTileIndex, vQuadUV );   \\n}\\n\\n\\nfloat GetCosSunRadius()\\n{\\n  return 0.01;\\n}\\n\\n\\nfloat GetSunIntensity()\\n{  \\t\\n  \\treturn 0.001;\\n}\\n\\nvec3 GetNormalToWorld(SphereInfo in_SI, vec3 in_Normal)\\n{\\n  return in_Normal ; \\n}\\nvec3 GetPosToWorld(SphereInfo in_SI, vec3 vPos)\\n{\\n  return in_SI.vOrigin + vPos ; \\n}\\nfloat GetSphereQuadCount(const SphereInfo in_SI)\\n{\\n    return in_SI.fSegments * in_SI.fSlices; \\n}\\nfloat GetSphereVertexCount(const SphereInfo in_SI)\\n{   \\n    return GetSphereQuadCount(in_SI) * 6.; \\n}\\n\\nvec3 GetSunPosition()\\n{\\n  \\tfloat fSunDistance = 14000.0;\\n  \\treturn vec3( 0.0, 0.1, 1.0 ) * fSunDistance;\\n}\\nvec3 GetSunDir( vec3 vCameraPos )\\n{\\n  \\treturn normalize( GetSunPosition() - vCameraPos );\\n}\\n\\n// From Shadertoy \\\"Hash without sine - Dave Hoskins\\\"\\n// https://www.shadertoy.com/view/4djSRW\\n#define MOD3 vec3(.1031,.11369,.13787)\\n#define MOD4 vec4(.1031,.11369,.13787, .09987)\\nfloat hash11(float p)\\n{\\n\\tvec3 p3  = fract(vec3(p) * MOD3);\\n    p3 += dot(p3, p3.yzx + 19.19);\\n    return fract((p3.x + p3.y) * p3.z);\\n}\\n\\nvec4 hash41(float p)\\n{\\n\\tvec4 p4 = fract(vec4(p) * MOD4);\\n    p4 += dot(p4, p4.wzxy+19.19);\\n    return fract(vec4((p4.x + p4.y)*p4.z, (p4.x + p4.z)*p4.y, (p4.y + p4.z)*p4.w, (p4.z + p4.w)*p4.x));\\n    \\n}\\nfloat SmoothNoise(in vec2 o) \\n{\\n\\tvec2 p = floor(o);\\n\\tvec2 f = fract(o);\\n\\t\\t\\n\\tfloat n = p.x + p.y*57.0;\\n\\n\\tfloat a = hash11(n+  0.0);\\n\\tfloat b = hash11(n+  1.0);\\n\\tfloat c = hash11(n+ 57.0);\\n\\tfloat d = hash11(n+ 58.0);\\n\\t\\n\\tvec2 f2 = f * f;\\n\\tvec2 f3 = f2 * f;\\n\\t\\n\\tvec2 t = 3.0 * f2 - 2.0 * f3;\\n\\t\\n\\tfloat u = t.x;\\n\\tfloat v = t.y;\\n\\n\\tfloat res = a + (b-a)*u +(c-a)*v + (a-b+d-c)*u*v;\\n    \\n    return res;\\n}\\n\\n//FBM step  \\n#define k_fmbSteps 10\\nfloat FBM( vec2 p, float repeat, float ps ) {\\n\\tfloat f = 0.0;\\n    float tot = 0.0;\\n    float a = 1.0;  \\t\\n    for( int i=0; i<k_fmbSteps; i++)\\n    {\\n        f += SmoothNoise( fract(p / repeat) * repeat ) * a;\\n        p *= 2.0;\\n        tot += a;\\n        a *= ps;\\n    }\\n    return f / tot;\\n}\\n#pragma endregion      \\n\\n#pragma region HelperMethod \\nfloat saturate(float v1)\\n{\\n  return clamp(v1 , 0.0 , 1.0);\\n}\\n\\nfloat CalAttenuation(float d, float falloffStart, float falloffEnd)\\n{ \\n  return saturate( (falloffEnd -d )  /  (falloffEnd - falloffStart) );  \\n}\\n\\nvec3 SchlickFresnel(vec3 R0 , vec3 normal , vec3 lightVec ) \\n{ \\n  float cosIncidentAngle = saturate(dot(normal , lightVec)) ;\\n  \\n  float f0 = 1.0 - cosIncidentAngle ; \\n  \\n  vec3 reflectPercent = R0 + (1.0 - R0) * (f0*f0*f0*f0*f0) ; \\n   \\n  return reflectPercent; \\n}\\n/*\\ndirectx code:MSDN\\n\\nfloat3 result = saturate(texCol0.rgb - Density*(texCol1.rgb));\\n\\nGLSL equivalent:\\n\\nvec3 result = clamp(texCol0.rgb - Density*(texCol1.rgb), 0.0, 1.0); \\n*/\\n\\nvec3 BlinnPhong(vec3 lightStrength, vec3 lightVec , \\n               vec3 normal, vec3 toEye, Material mat)\\n{\\n  float m = (1. - mat.Roughness) * 256.0 ; \\n  vec3 halfVec = normalize(toEye + lightVec);\\n  \\n  float roughnessFactor = (m + 8.0) * \\n                          pow(max(dot(halfVec , normal), 0.0 ), m) / 8.0;\\n  vec3 fresnelFactor = SchlickFresnel(mat.FresenlR0 , halfVec , lightVec);  \\n  \\n  return mat.diffuseAlebdo.rgb * lightStrength ; \\n}\\n\\nvoid Shadow(inout vec3 color) \\n{\\n  color -= vec3(0.2 , 0.2 , 0.2)  ;   \\n}\\n\\n\\n#pragma endregion\\n\\n\\n#pragma region PostEffect  \\n//https://blog.csdn.net/qq_29601003/article/details/103696527\\n  void PE_Vignette(inout SceneVertex out_SV) \\n  {\\n    float dist = distance(out_SV.vWorldPos.xy, vec2(0.5)) * 2.0 ; \\n    dist /= 1.5142; \\n    dist = pow(dist, 1.1) ; \\n    out_SV.vColor *= (1.0 - dist) ; \\n  }\\n#pragma endregion \\n\\n#pragma region Light/Shadow \\n  //Directional Light \\n  vec3 ComputeDirLight(Light L, Material mat, \\n                      vec3 pos ,vec3 normal, vec3 toEye)\\n  {\\n    vec3 lightVec = -L.vDirection ;\\n    \\n    float ndotl = max(dot(lightVec , normal) , 0. )  ;\\n    vec3 lightStrength = L.vStrength * ndotl ;  \\n    \\n    return BlinnPhong(lightStrength , lightVec, normal , toEye , mat) ; \\n  }\\n#pragma endregion \\n    \\n#pragma region InfoCollection \\n/*DirLight*/\\n\\t\\n  #define DirStrength vec3(0.4 , 0.4 , 0.4 )\\n  #define DirFalloffStart 1. \\n  #define DirDirection vec3(-0.4, -2. , 1. )\\n  #define DirPosition vec3(0.)\\n  #define DirSpotPower 12. \\n\\n  #define SphSegments 64.\\n  #define SphSclices 48.\\n  #define SphOrigin vec3(0.)\\n  #define SphRdius 5. \\n\\n\\n\\n#pragma endregion \\n\\n#pragma region DrawScreen   \\n    #define WidthX \\t\\t\\t\\t16.0\\n    #define HeightY \\t\\t\\t16.0\\n    #define floorTileCount \\t\\t(WidthX * HeightY) \\n    #define floorVertexCount \\t(floorTileCount * 6.) \\n    void GenFloor(const vec3 in_ViewPos, const float vertexIndex, \\n                  const Light in_light, \\n                  inout SceneVertex outSceneVertex )\\n    { \\n\\t\\tvec2 vDim = vec2( WidthX, HeightY );\\n        vec2 vQuadTileIndex;\\n\\t\\tvec2 vQuadUV; \\n      /*Get the Current TileInfo*/\\n\\t\\tGetQuadTileInfo( vertexIndex, vDim, vQuadTileIndex, vQuadUV );  \\n        outSceneVertex.vWorldPos.xz = (vQuadUV * 2.0 - 1.0) * 100.0;  \\n\\t\\toutSceneVertex.vWorldPos.y = 0.; \\n\\t\\toutSceneVertex.fAlpha = 1.0;\\n\\t\\toutSceneVertex.vColor = vec3(0.);\\n\\n\\t\\tvec3 vNormal = vec3( 0.0, 1.0, 0.0 );\\n      /*Get the Surface Info*/\\n      \\tSurfaceInfo s_FloorS ; \\n      \\ts_FloorS.vPos = outSceneVertex.vWorldPos ; \\n      \\ts_FloorS.vNormal = vNormal ; \\n      \\ts_FloorS.fGloss = 5. ; \\n      /*Set the Material Info*/\\n      \\tMaterial mat;  \\n      \\tmat.diffuseAlebdo = vec4(0.5 ,0.8 ,0.8, 1.0);\\n      \\tmat.FresenlR0 = vec3(0.1 , 0.1, 0.1 ) ; \\n        mat.Roughness = 0.125 ;  \\n       \\n      /*Apply the lgiht*/\\n      \\tvec3 result = vec3(0.) ; \\n        vec3 toEye = normalize((in_ViewPos - outSceneVertex.vWorldPos)) ; \\n        result = ComputeDirLight(in_light , mat ,\\n                                 outSceneVertex.vWorldPos , vNormal , toEye);\\n        result *= 2.72 / ( log(distance(in_ViewPos.x, outSceneVertex.vWorldPos.x))) ; \\n      /*Apply the Shadow*/\\n      \\tvec3 m = outSceneVertex.vWorldPos + DirDirection; \\n      \\tvec3 AP = SphOrigin - outSceneVertex.vWorldPos;\\n      \\tvec3 pp = abs(dot(m, AP)) / abs(m) ;  \\n       \\tvec3 c2l = sqrt(\\n          \\t\\t\\t\\t\\tpow(AP, vec3(2.)) - \\n                            pow(pp, vec3(2.))\\n                        ) ; \\t\\n      \\tfloat disLength = length(c2l);  \\n      \\t\\n      \\n      /*Apply the Color to hte scene color*/  \\n      \\toutSceneVertex.vColor = result; \\n      \\n      /*Apply the shadow color*/\\n       if(disLength < SphRdius)\\n        {\\n          /*Apply the shadow color*/\\n          Shadow(outSceneVertex.vColor);\\n        }\\n      \\n    }\\n//SunInfo\\n\\t#define Sun_fSegments    64.\\n\\t#define Sun_fSclices \\t 48.\\n\\t#define Sun_vOrigin \\t vec3(0.)\\n\\t#define Sun_fRadius \\t 5. \\n\\tvoid GenPointLight(const float in_vertexIndex, \\n                       \\tconst Light in_light, \\n                        const vec3 in_CamPos , \\n               \\t\\t\\tout SceneVertex outSceneVertex)\\n    {\\n      vec2 vDim = vec2(Sun_fSegments , Sun_fSclices);\\n      \\n      vec2 vQuadTileIndex ; \\n      vec2 vUV ;  \\n      GetQuadTileInfo(in_vertexIndex, vDim ,\\n                      vQuadTileIndex,\\n                      vUV);\\n       float fElevation = vUV.y * PI ;  \\n      \\n    }\\n\\t \\n\\tvoid GenSphere(const float in_vertexIndex,\\n                   const SphereInfo in_SI ,\\n                   const Light in_DL ,\\n                   const vec3 in_CamPos,\\n                   out SceneVertex outSceneVertex)\\n    {\\n      vec2 vDim = vec2(in_SI.fSegments , in_SI.fSlices);\\n      \\n      vec2 vQuadTileIndex ; \\n      vec2 vUV ; \\n      GetQuadTileInfo(in_vertexIndex, vDim ,\\n                      vQuadTileIndex,\\n                      vUV);\\n      \\n      vec3 vSpherePos ; \\n      float fElevation = vUV.y * PI ;  \\n      vSpherePos.y = cos(fElevation);\\n     /*setting up the Heading*/\\n      float fHeading = vUV.x * PI * 2.  ; \\n      float fSliceRadius = sqrt(1. - vSpherePos.y * vSpherePos.y);\\n      vSpherePos.x = sin(fHeading ) * fSliceRadius  ; \\n      vSpherePos.z = cos(fHeading ) * fSliceRadius  ; \\n      \\n      vec3 vSphereNormal = normalize(vSpherePos);\\n      \\n      vec3 vWorldNormal = GetNormalToWorld(in_SI , vSphereNormal);\\n      outSceneVertex.vWorldPos = GetPosToWorld(in_SI, vSpherePos * in_SI.fRadius); \\n      \\n      /*Setting up the color view */ \\n      SurfaceInfo t_SI ; \\n      t_SI.vPos = outSceneVertex.vWorldPos - vec3(0.) ; \\n      t_SI.vNormal  = vWorldNormal ; \\n      t_SI.fGloss = 5. ;\\n      \\n      /*Material*/\\n      Material mat;  \\n      mat.diffuseAlebdo = vec4(0.5 ,0.8 ,0.8, 1.0);\\n      mat.FresenlR0 = vec3(0.1 , 0.1, 0.1 ) ; \\n      mat.Roughness = 0.125 ; \\n      \\n      /*Apply the lgiht*/\\n      vec3 result = vec3(0.) ; \\n      vec3 toEye = normalize((in_CamPos - outSceneVertex.vWorldPos)) ; \\n      \\n      result = ComputeDirLight(in_DL , mat ,\\n                                 outSceneVertex.vWorldPos , vSphereNormal , toEye); \\n      /*apply the light*/\\n      outSceneVertex.vColor = result ; \\n      outSceneVertex.fAlpha = 1. ; \\n          \\n    } \\n\\n\\t\\n#pragma endregion \\n\\n/* -------------------------------- display ------------------------------- */\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n/* -------------------------------- display ------------------------------- */\\n/*\\n  struct Light\\n  { \\n      vec3 vStrength ; \\n      float FalloffStart ; \\n      vec3 vDirection  ; \\n      float FalloffEnd ; \\n      vec3 vPosition ; \\n      float SpotPower ; \\n  };\\n*/\\n//globalLight\\n\\tLight DirLight  ;  //Directional Light\\n    Light PointLight;  //Point Light\\n\\tLight SpotLihgt ;  //Spot Light\\n\\n\\nvoid main()\\n{  \\n   \\n  DirLight.vStrength = DirStrength ;  /*Directional Light*/\\n  DirLight.FalloffStart = DirFalloffStart ; \\n  DirLight.vDirection = DirDirection;  \\n  DirLight.vPosition = DirPosition; \\n  DirLight.SpotPower = DirSpotPower ;\\n  \\n  PointLight.vStrength = vec3(1. , 1. , 1. ) ; /*Point Light*/\\n  PointLight.FalloffStart = 1. ; \\n  PointLight.vDirection = vec3(-1., -2., 1.); \\n  PointLight.vPosition = vec3(4. , 5. , 2.) ; \\n  PointLight.SpotPower = 32. ; \\n  \\n  \\n  #pragma region screenSetting \\n\\tSceneVertex sv ; \\n\\tvec2 vMouse = mouse ; \\n  \\tfloat vertexIndex = vertexId ; \\n  #pragma endregion \\n  \\n  #pragma region Sphereinfo \\n  \\tSphereInfo sphereInfo ; \\n \\tsphereInfo.fSegments = SphSegments;\\n    sphereInfo.fSlices = SphSclices; \\n  \\tsphereInfo.vOrigin = SphOrigin ; \\n    sphereInfo.fRadius = SphRdius ;\\n  #pragma endregion \\n  \\n  \\n  \\n  #pragma region ProjectionSetUp \\n     mat4 m  = persp(radians(60.),\\n                     resolution.x/ resolution.y, \\n                     NEARCLIPPED , \\n                     FARCLIPPED); \\n  #pragma endregion \\n\\n  #pragma region CameraSetUp/ViewSetUp\\n      vec3 target = vec3(0. ) ;\\n      vec3 up = vec3(0. ,1. , 0. ) ;\\n\\t  //target = sv.vWorldPos; \\n      vec3 camTarget = target ; \\n      vec3 camPos = vec3(90. ,90. ,0.);  \\n      vec3 camForward = normalize(camTarget - camPos);\\n      m *= cameraLookAt(camPos , camTarget, normalize(up));\\n  #pragma endregion \\n\\n  #pragma region Global Setting \\n      m *= uniformScale(1.5);\\n    //  m *= trans(vec3(0.)) ;\\n     // m *= rotY(1. * time);\\n  \\t //m *= rotZ(sin(1. * time)); \\n  #pragma endregion \\n   \\n\\n#pragma region DrawSomething \\n  #pragma region Floor\\n    if(vertexIndex >= 0. && vertexIndex < floorVertexCount)\\n      GenFloor(camPos , vertexId, DirLight,\\n               sv) ; \\n    vertexIndex -= floorVertexCount ;   \\n  #pragma endregion  \\n  \\n  #pragma region Sphere\\n      float fSphereVertexCount = GetSphereVertexCount(sphereInfo);\\n      if(vertexIndex >= 0. && vertexIndex < fSphereVertexCount)\\n      {\\n        GenSphere(vertexIndex, sphereInfo,\\n                  DirLight, \\n                  camPos,\\n                  sv);\\n        m *= uniformScale(1.5);\\n        m *= trans(vec3(0. , 4. , 0. )) ;  \\n      }\\n      vertexIndex -= fSphereVertexCount ;  \\n  #pragma endregion    \\n#pragma endregion  \\n  \\n  \\n#pragma region PostEffect\\n // PE_Vignette(sv) ;\\n#pragma endregion \\n  \\n#pragma region ApplySetting\\n    gl_Position = m * vec4(sv.vWorldPos, 1.); \\n  \\tgl_PointSize = 10. ; \\n    v_color = vec4(sv.vColor * sv.fAlpha, sv.fAlpha);\\n#pragma endregion \\n}\"}",
  "screenshotURL": "data/images/images-we13h662eoncnka3l-thumbnail.jpg",
  "hasSound": "",
  "views": {
    "$numberInt": "99"
  },
  "likes": {
    "$numberInt": "0"
  },
  "revisionId": "rxcrBMaF8XGNnf6TM"
}