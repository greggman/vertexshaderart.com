{
  "_id": "QvQL9vkAcj4EawBDk",
  "owner": {
    "_id": "Pexi77zfde4iNKmrT",
    "createdAt": {
      "$date": {
        "$numberLong": "1493741221077"
      }
    },
    "profile": {
      "name": "Kolargon Generative",
      "avatarUrl": "https://lh3.googleusercontent.com/-tiKYx1U71-Q/AAAAAAAAAAI/AAAAAAAAAGg/b-eEUsFpspc/photo.jpg"
    },
    "username": "kolargon"
  },
  "createdAt": {
    "$date": {
      "$numberLong": "1538519586076"
    }
  },
  "modifiedAt": {
    "$date": {
      "$numberLong": "1541123738656"
    }
  },
  "origId": "STMhyZ8zrQSiJqi7S",
  "name": "cosmic 2",
  "notes": "http://glslsandbox.com/e#45880.0",
  "rank": {
    "$numberDouble": "1.3967696769586129"
  },
  "private": true,
  "unlisted": false,
  "username": "kolargon",
  "avatarUrl": "https://lh3.googleusercontent.com/-tiKYx1U71-Q/AAAAAAAAAAI/AAAAAAAAAGg/b-eEUsFpspc/photo.jpg",
  "settings": {
    "num": 100000,
    "mode": "POINTS",
    "sound": "https://soundcloud.com/dark_trance/azzault-technicolors-of-lsd",
    "lineSize": "NATIVE",
    "backgroundColor": [
      0,
      0,
      0,
      1
    ],
    "shader": "#define parameter0 0.6//KParameter -5.0>>5.\n#define parameter1 0.4//KParameter 0.0>>10.\n#define parameter2 100.//KParameter 10.0>>100.\n#define parameter3 3.2//KParameter 0.0>>1.\n#define rotationX 0.//KParameter 0.0>>2.\n#define rotationY 0.//KParameter 0.0>>1.\n#define soundFact 0.//KParameter 0.0>>1.\n#define soundAmp 0.//KParameter 0.0>>5.\n\n#define PI 3.14159265359\n#define HPI PI/2.\n\n//Functions used for camera\n\nmat4 inverse(mat4 m) {\n  float\n      a00 = m[0][0], a01 = m[0][1], a02 = m[0][2], a03 = m[0][3],\n      a10 = m[1][0], a11 = m[1][1], a12 = m[1][2], a13 = m[1][3],\n      a20 = m[2][0], a21 = m[2][1], a22 = m[2][2], a23 = m[2][3],\n      a30 = m[3][0], a31 = m[3][1], a32 = m[3][2], a33 = m[3][3],\n\n      b00 = a00 * a11 - a01 * a10,\n      b01 = a00 * a12 - a02 * a10,\n      b02 = a00 * a13 - a03 * a10,\n      b03 = a01 * a12 - a02 * a11,\n      b04 = a01 * a13 - a03 * a11,\n      b05 = a02 * a13 - a03 * a12,\n      b06 = a20 * a31 - a21 * a30,\n      b07 = a20 * a32 - a22 * a30,\n      b08 = a20 * a33 - a23 * a30,\n      b09 = a21 * a32 - a22 * a31,\n      b10 = a21 * a33 - a23 * a31,\n      b11 = a22 * a33 - a23 * a32,\n\n      det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;\n\n  return mat4(\n      a11 * b11 - a12 * b10 + a13 * b09,\n      a02 * b10 - a01 * b11 - a03 * b09,\n      a31 * b05 - a32 * b04 + a33 * b03,\n      a22 * b04 - a21 * b05 - a23 * b03,\n      a12 * b08 - a10 * b11 - a13 * b07,\n      a00 * b11 - a02 * b08 + a03 * b07,\n      a32 * b02 - a30 * b05 - a33 * b01,\n      a20 * b05 - a22 * b02 + a23 * b01,\n      a10 * b10 - a11 * b08 + a13 * b06,\n      a01 * b08 - a00 * b10 - a03 * b06,\n      a30 * b04 - a31 * b02 + a33 * b00,\n      a21 * b02 - a20 * b04 - a23 * b00,\n      a11 * b07 - a10 * b09 - a12 * b06,\n      a00 * b09 - a01 * b07 + a02 * b06,\n      a31 * b01 - a30 * b03 - a32 * b00,\n      a20 * b03 - a21 * b01 + a22 * b00) / det;\n}\n\nmat4 lookAt(vec3 eye, vec3 target, vec3 up) {\n  vec3 zAxis = normalize(eye - target);\n  vec3 xAxis = normalize(cross(up, zAxis));\n  vec3 yAxis = cross(zAxis, xAxis);\n\n  return mat4(\n    xAxis, 0,\n    yAxis, 0,\n    zAxis, 0,\n    eye, 1);\n}\n\nmat4 cameraLookAt(vec3 eye, vec3 target, vec3 up) {\n  #if 1\n  return inverse(lookAt(eye, target, up));\n  #else\n  vec3 zAxis = normalize(target - eye);\n  vec3 xAxis = normalize(cross(up, zAxis));\n  vec3 yAxis = cross(zAxis, xAxis);\n\n  return mat4(\n    xAxis, 0,\n    yAxis, 0,\n    zAxis, 0,\n    -dot(xAxis, eye), -dot(yAxis, eye), -dot(zAxis, eye), 1);  \n  #endif\n  \n}\n\nmat4 persp(float fov, float aspect, float zNear, float zFar) {\n  float f = tan(PI * 0.5 - 0.5 * fov);\n  float rangeInv = 1.0 / (zNear - zFar);\n\n  return mat4(\n    f / aspect, 0, 0, 0,\n    0, f, 0, 0,\n    0, 0, (zNear + zFar) * rangeInv, -1,\n    0, 0, zNear * zFar * rangeInv * 2., 0);\n}\n\n\nvec2 rotate(vec2 f, float deg) \n{\n\treturn vec2(f.x * cos(deg) - f.y * sin(deg), f.x * sin(deg) + f.y * cos(deg));\n}\n\n\nfloat random(float n) {\n\treturn fract(abs(sin(n * 55.753) * 367.34));\n}\n\nmat2 rotate2d(float angle){\n\treturn mat2(cos(angle), -sin(angle),  sin(angle), cos(angle));\n}\n\nvec3 rotX(vec3 _v, float _rad) {\n    vec2 f = sin(vec2(_rad, _rad + HPI));\n    vec3 r = _v;\n    r.y = _v.y * f.y + _v.z * -f.x;\n    r.z = _v.y * f.x + _v.z *  f.y;\n    return r;\n}\n\nvec3 rotY(vec3 _v, float _rad) {\n    vec2 f = sin(vec2(_rad, _rad + HPI));\n    vec3 r = _v;\n    r.x =  _v.x *  f.y + _v.z *  f.x;\n    r.z =  _v.x * -f.x + _v.z *  f.y;\n    return r;\n}\n\nvec3 rotZ(vec3 _v, float _rad) {\n    vec2 f = sin(vec2(_rad, _rad + HPI));\n    vec3 r = _v;\n    r.x =  _v.x *  f.x + _v.y * f.y;\n    r.y =  _v.x * -f.y + _v.y * f.x;\n    return r;\n}\n\nvoid main( void ) {float finalDesiredPointSize = 3.;\nfloat maxFinalSquareSideSize = floor(sqrt(vertexCount));\nfloat finalMaxVertexCount = maxFinalSquareSideSize*maxFinalSquareSideSize;\nfloat maxVerticesPerLine = floor(maxFinalSquareSideSize  *resolution.x/resolution.y);\nvec2 vertexResolution = vec2(maxVerticesPerLine, floor(finalMaxVertexCount/maxVerticesPerLine));\nfloat finalVertexCount = vertexResolution.x*vertexResolution.y;\nfloat finalVertexId = mod(vertexId,finalVertexCount);\nfloat x = mod(finalVertexId, vertexResolution.x);\nfloat y = floor(finalVertexId / vertexResolution.x);\nvec2 simFragCoord = vec2(x,y);//simfragCoord will replace the gl_FragCoord of fragment shader\nfloat u_i = (x /vertexResolution.x);\nfloat v_i = (y /vertexResolution.y);\nfloat sizeFactor = finalDesiredPointSize*vertexResolution.x/resolution.x;\nfloat ux = sizeFactor*(u_i - 0.5);\nfloat vy = sizeFactor*(v_i - 0.5);\ngl_PointSize = finalDesiredPointSize;\n\nfloat sndComp = u_i;\nif(u_i>0.5)\n                   {\n                    sndComp = 1.-sndComp;\n                   }\n                   \nfloat snd = soundFact * texture2D(sound, vec2(0.,  sndComp)).a;\n \n\n                   \n //camera stuffs\n\n  mat4 mat = persp(radians(60.0), resolution.x / resolution.y, 0.4, 0.0);\n  vec3 eye = vec3(0., 0.,  1.5);\n\n  vec3 target = vec3(0.,0.,0.);\n  vec3 up = vec3(0., 1., 0.);\n  \n  \n  mat *= cameraLookAt(eye, target, up);\n  \n  \n\nvec2 surfacePosition = vec2(ux,vy);\n\n\tvec2 uv = (simFragCoord.xy * 2.0 -  vertexResolution.xy) / vertexResolution.x;\n\n                   float rot = parameter3;\n                   if(u_i>0.5)\n                   {\n                     rot = -rot;\n                   };\n                     \n\tuv *= rotate2d(time * rot); //time * 0.2\n\n\tfloat direction = 1.0;\n\tfloat speed = time * direction * parameter0;\n\tfloat distanceFromCenter = length(uv);\n\n     float angleCompX = uv.x;              \n    if(u_i>0.5)\n    {\n      angleCompX = -angleCompX;\n    }\n\tfloat meteorAngle = atan(uv.y, angleCompX) * (180.0 / PI);\n\n\tfloat flooredAngle = floor(meteorAngle);\n\tfloat randomAngle = pow(random(flooredAngle), 0.5);\n\tfloat t = speed;\n\n\tfloat lightsCountOffset = parameter1;\n\tfloat adist = randomAngle / distanceFromCenter * lightsCountOffset + snd;\n\tfloat dist = t + adist;\n\tfloat meteorDirection = (direction < 0.0) ? -1.0 : 0.0;\n\tdist = abs(fract(dist) + meteorDirection);\n\n\tfloat lightLength = parameter2;\n\tfloat meteor = (5.0 / dist) * cos(sin(speed)) / lightLength;\n\tmeteor *= distanceFromCenter * 5.0;\n\n\n\tvec3 color = vec3(0.);\n                \n\n    float depth = snd*(color.x+color.y+color.z)/3.;\n                   \n\tcolor += meteor;\n\n\tv_color = vec4(color, 1.0);\n        \n   \n    vec4 finalPos = vec4(ux, vy, snd, 1.);\n  \n    finalPos = vec4(rotX(rotY(finalPos.xyz, rotationY*2.*PI),rotationX*2.*PI),1.);\n                 \n    gl_Position = mat*finalPos;\n                   \n}"
  },
  "screenshotURL": "data/images/images-ivqh5c6876dsw1ys3-thumbnail.jpg",
  "hasSound": true,
  "views": {
    "$numberInt": "16"
  },
  "likes": {
    "$numberInt": "0"
  },
  "revisionId": "KAQKAR654ke9L8u8p"
}