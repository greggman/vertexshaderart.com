{
  "_id": "YFECqw3LmKnaojReb",
  "owner": {
    "_id": "Pexi77zfde4iNKmrT",
    "createdAt": {
      "$date": {
        "$numberLong": "1493741221077"
      }
    },
    "profile": {
      "name": "Kolargon Generative",
      "avatarUrl": "https://lh3.googleusercontent.com/-tiKYx1U71-Q/AAAAAAAAAAI/AAAAAAAAAGg/b-eEUsFpspc/photo.jpg"
    },
    "username": "kolargon"
  },
  "createdAt": {
    "$date": {
      "$numberLong": "1538565028111"
    }
  },
  "modifiedAt": {
    "$date": {
      "$numberLong": "1538798057723"
    }
  },
  "origId": "9WvFeBhi2eCqodeBQ",
  "name": "simple frag to vertex formula with sizeFactor",
  "notes": "http://glslsandbox.com/e#42523.0",
  "rank": {
    "$numberDouble": "1.423046236747249"
  },
  "private": true,
  "unlisted": false,
  "username": "kolargon",
  "avatarUrl": "https://lh3.googleusercontent.com/-tiKYx1U71-Q/AAAAAAAAAAI/AAAAAAAAAGg/b-eEUsFpspc/photo.jpg",
  "settings": "{\"num\":100000,\"mode\":\"POINTS\",\"sound\":\"https://soundcloud.com/merzbow/pulse-vegan-part-1\",\"lineSize\":\"NATIVE\",\"backgroundColor\":[0,0,0,1],\"shader\":\"\\n\\n\\n//Step 1 >> comment all precision, extension, uniforms and varying\\n/*\\n#ifdef GL_ES\\nprecision mediump float;\\n#endif\\n \\n#extension GL_OES_standard_derivatives : enable\\n\\nuniform float time;\\nuniform vec2 mouse;\\nuniform vec2 resolution;\\nvarying vec2 surfacePosition;\\n*/\\n\\n#define patternFactor0 0.0012//KParameter 0.0012>>0.12\\n#define timeFactor0 0.1//KParameter 0.1>>1.\\n#define timeFactorAmp 10.//KParameter 1.>>40.\\n#define timeFactorAmp2 10.//KParameter 1.>>40.\\n#define patternFactor1Rot 10.//KParameter 1.>>100.\\n#define sizeFactor 1.//KParameter 1.>>4.\\n#define shapeFactor1 0.4//KParameter 0.4>>1.0\\n#define shapeFactor0 9.0//KParameter 9.0>>30.\\n\\nvec2 pattern(vec2 p) {\\n\\t\\n\\tfloat a = atan(p.x,p.y);\\n\\tfloat r = shapeFactor0 * pow(1.0/length(p), shapeFactor1);\\n\\tfloat t =  time + length(p) * patternFactor0;\\n\\treturn vec2(sin(a*3.0+cos(t*0.25)*patternFactor1Rot), sin(r*2.+sin(time*timeFactor0)*timeFactorAmp));\\n}\\n\\nvoid main( void ) {\\n\\n  //Step 2 >> replace  gl_FragCoord\\n\\n  float maxFinalSquareSideSize = floor(sqrt(vertexCount));\\n  float finalMaxVertexCount = pow(maxFinalSquareSideSize,2.);\\n  \\n  float maxVerticesPerLine = floor(maxFinalSquareSideSize  *resolution.x/resolution.y);\\n  \\n  //x = number of elements in a line as x value for local resolution\\n  //y = number of possible lines with the given vertexCount\\n  vec2 vertexResolution = vec2(maxVerticesPerLine, floor(finalMaxVertexCount/maxVerticesPerLine));\\n  \\n  //we can now calculate the final number of elements\\n  float finalVertexCount = vertexResolution.x*vertexResolution.y;\\n  \\n  //and adjust finalVertexId\\n  float finalVertexId = mod(vertexId,finalVertexCount);\\n  \\n  //Calculate the position of the elements based on their finalVertexId\\n  //simfragCoord <=> gl_FragCoord in the vertex shader\\n  \\n  vec2 simfragCoord = vec2(mod(finalVertexId, vertexResolution.x),floor(finalVertexId / vertexResolution.x));\\n  \\n  //Step 3 >> calculate vertice positions\\n  //relative coordinate of the vertex (cordinates in 0..1 referential)\\n  float u = (simfragCoord.x /vertexResolution.x);\\n  float v = (simfragCoord.y /vertexResolution.y);\\n  \\n  //calculate coordinates in -1.>>1.0 space\\n  float fact = 2.*sizeFactor;\\n  float ux = fact*(u - 0.5);\\n  float vy = fact*(v - 0.5);\\n  \\n  gl_Position = vec4(ux, vy, 0., 1.);\\n  \\n  //Calculate the best possible pointSize to fill the screen\\n  //based on the current vertexCount (finalVertexCount)\\n  gl_PointSize = 2.*resolution.y/vertexResolution.y;\\n  \\n  //create the surfacePosition\\n  vec2 surfacePosition = vec2(ux,vy);\\n\\n   /****************************************************************/\\n  //Step 4 >> paste the old fragment code with following changes:\\n  //replace gl_FragCoord by vfragCoord \\n  //replace gl_FragColor by v_color\\n  \\n\\n\\tvec2 p = surfacePosition * 99.0;\\n\\tvec3 col = vec3(0.0);\\n\\t\\n\\tfor (int i=0; i<3; i++)\\n\\t\\tp.xy = pattern(p);\\n\\t\\n\\tcol.xy = sin(p.xy);\\n\\tcol.z = max(step(abs(p.x*p.x),0.5), -1.0 / abs(p.y));\\n\\t\\n\\tv_color = vec4( col, 1.0 );\\n\\n  \\n  /****************************************************************/\\n  \\n}\"}",
  "screenshotURL": "data/images/images-xnzqfyvyk3nlvdgke-thumbnail.jpg",
  "hasSound": true,
  "views": {
    "$numberInt": "19"
  },
  "likes": {
    "$numberInt": "0"
  },
  "revisionId": "Nw8cqdaShxz8jgzYX"
}