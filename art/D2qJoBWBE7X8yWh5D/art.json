{
  "_id": "D2qJoBWBE7X8yWh5D",
  "owner": {
    "_id": "B7Kfai5f9h3MxwJcP",
    "createdAt": {
      "$date": {
        "$numberLong": "1445777397953"
      }
    },
    "username": "gman",
    "profile": {
      "info": "&nbsp;&nbsp;contact: [@greggman](http://twitter.com/greggman), [github](http://github.com/greggman), [blog](http://greggman.com)\nnew stuff: [webgl](http://webglfundamentals.com), [twgl](http://twgljs.org), [threejsfundamentals](https://threejsfundamentals.org)\nold stuff: [chrome](http://chromium.org), [locoroco](https://www.youtube.com/watch?v=pFKpyScxv0k), [CTR](https://www.youtube.com/watch?v=3O8FK5d67cM), [Zombie Revenge](https://www.youtube.com/watch?v=Xw8yNik8Q-A), [and others...](http://games.greggman.com/game/games_o_the_greggman/)\n\nSome stuff you might want to look at\n\n*   [A uniform grid based on `vertexCount` and the window dimensions](https://www.vertexshaderart.com/art/NPohkmBgKdTBhML8P)\n*   [Tons of matrix functions](https://www.vertexshaderart.com/art/nr3EiyXWLMpwoouHt)\n\nNote: All the shaders I've posted are licensed [CC0](https://creativecommons.org/publicdomain/zero/1.0/)",
      "avatarUrl": "https://secure.gravatar.com/avatar/dcc0309895c3d6db087631813efaa9d1?default=retro&size=200"
    }
  },
  "createdAt": {
    "$date": {
      "$numberLong": "1449084382766"
    }
  },
  "modifiedAt": {
    "$date": {
      "$numberLong": "1450070664201"
    }
  },
  "origId": null,
  "name": "particles",
  "rank": {
    "$numberDouble": "1.213907166784185"
  },
  "private": true,
  "unlisted": false,
  "username": "gman",
  "settings": "{\"num\":100000,\"mode\":\"POINTS\",\"sound\":\"\",\"lineSize\":\"CSS\",\"backgroundColor\":[0,0,0,1],\"shader\":\"//\\n\\n#define PI radians(180.)\\n\\n// hash function from https://www.shadertoy.com/view/4djSRW\\nfloat hash(float p) {\\n\\tvec2 p2 = fract(vec2(p * 5.3983, p * 5.4427));\\n    p2 += dot(p2.yx, p2.xy + vec2(21.5351, 14.3137));\\n\\treturn fract(p2.x * p2.y * 95.4337);\\n}\\n\\nfloat m1p1(float v) {\\n  return v * 2. - 1.;\\n}\\n\\nfloat p1m1(float v) {\\n  return v * .5 + .5;\\n}\\n\\nvec3 shape00(float vertexId, float time) {\\n  vec3 clocks = vec3(\\n    time * hash(vertexId), \\n    time * hash(vertexId * 0.37), \\n    time * hash(vertexId * 0.73));\\n  vec3 radius  = vec3(\\n    hash(vertexId * 0.23),\\n    hash(vertexId * 1.17),\\n    hash(vertexId * 2.99)\\n    );\\n  return vec3(\\n      sin(clocks.x) * radius.x,\\n      sin(clocks.y) * radius.y,\\n      cos(clocks.z) * radius.z);\\n}\\n\\nvec3 shape01(float vertexId, float time) {\\n  return vec3(\\n    m1p1(hash(vertexId * 0.33)),\\n    m1p1(hash(vertexId * 1.57)),\\n    m1p1(hash(vertexId * 2.39)));\\n    \\n}\\n\\nvec3 shape02(float vertexId, float time) {\\n  return vec3( \\n    sin(vertexId * 0.005),\\n    cos(vertexId * 0.005),\\n    cos(vertexId + time * 0.01));\\n  \\n}\\n\\nvec3 shape03(float vertexId, float time) {\\n  float r = cos(vertexId * mod(floor(time * 20.), 15.) * 0.25);\\n  return vec3( \\n    sin(vertexId * 0.005) * r,\\n    cos(vertexId * 0.005) * r,\\n    sin(vertexId + time * 0.01));\\n  \\n}\\n\\nvoid main() {\\n  vec3 pos00 = shape03(vertexId, time); \\n  vec3 pos = pos00;\\n  gl_Position = vec4(pos, 1);\\n  gl_Position = vec4(gl_Position.xyz, .6 / gl_Position.z);\\n  \\n  float zish = p1m1(gl_Position.z / gl_Position.w);\\n  gl_PointSize = zish;\\n  v_color = vec4(1, 1, 1, zish);\\n  v_color = vec4(v_color.rgb * v_color.a, v_color.a);\\n}\"}",
  "screenshotURL": "data/images/images-08w7c6r49jcvlca6s-thumbnail.jpg",
  "hasSound": "",
  "views": {
    "$numberInt": "4"
  },
  "likes": {
    "$numberInt": "0"
  },
  "revisionId": "67Xh5EywTdZmXaGp8",
  "avatarUrl": "https://secure.gravatar.com/avatar/dcc0309895c3d6db087631813efaa9d1?default=retro&size=200",
  "notes": ""
}