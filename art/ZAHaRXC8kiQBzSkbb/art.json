{
  "_id": "ZAHaRXC8kiQBzSkbb",
  "owner": {
    "username": "anon"
  },
  "createdAt": {
    "$date": {
      "$numberLong": "1482252697193"
    }
  },
  "modifiedAt": {
    "$date": {
      "$numberLong": "1482252697193"
    }
  },
  "origId": null,
  "name": "SurfaceNet Metaball",
  "notes": "",
  "rank": {
    "$numberDouble": "10.738209142322725"
  },
  "private": false,
  "unlisted": false,
  "username": "-anon-",
  "avatarUrl": "",
  "settings": {
    "num": 70000,
    "mode": "TRIANGLES",
    "sound": "",
    "lineSize": "NATIVE",
    "backgroundColor": [
      0,
      0,
      0,
      1
    ],
    "shader": "#define PI05 1.570796326795\n#define PI   3.1415926535898\n\n#define kNumVertX   15.0\n#define kNumVertY   15.0\n//#define kNumVertZ\n#define kScale      0.2\n#define kTranslate  vec3(-1.5)\n\nvec3 hash3(vec3 v) {\n  return fract(sin(v) * vec3(43758.5453123, 12345.6789012,76543.2109876));\n}\n\nvec3 rotX(vec3 p, float rad) {\n  vec2 sc = sin(vec2(rad, rad + PI05));\n  vec3 rp = p;\n  rp.y = p.y * sc.y + p.z * -sc.x;\n  rp.z = p.y * sc.x + p.z *  sc.y;\n  return rp;\n}\n\nvec3 rotY(vec3 p, float rad) {\n  vec2 sc = sin(vec2(rad, rad + PI05));\n  vec3 rp = p;\n  rp.x =  p.x *  sc.y + p.z *  sc.x;\n  rp.z =  p.x * -sc.x + p.z *  sc.y;\n  return rp;\n}\n\nvec3 rotZ(vec3 p, float rad) {\n  vec2 sc = sin(vec2(rad, rad + PI05));\n  vec3 rp = p;\n  rp.x =  p.x *  sc.x + p.y * sc.y;\n  rp.y =  p.x * -sc.y + p.y * sc.x;\n  return rp;\n}\n\nvec4 perspective(vec3 p, float fov, float near, float far) {\n  vec4 pp = vec4(p, -p.z);\n  pp.xy *= vec2(resolution.y / resolution.x, 1.0) / tan(radians(fov * 0.5));\n  pp.z = (-p.z * (far + near) - 2.0 * far * near) / (far - near);\n  return pp;\n}\n\nmat4 lookat(vec3 eye, vec3 look, vec3 up) {\n  vec3 z = normalize(eye - look);\n  vec3 x = normalize(cross(up, z));\n  vec3 y = cross(z, x);\n  return mat4(x.x, y.x, z.x, 0.0, x.y, y.y, z.y, 0.0, x.z, y.z, z.z, 0.0, 0.0, 0.0, 0.0, 1.0) * \n    mat4(1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, -eye.x, -eye.y, -eye.z, 1.0);\n}\n\nvec3 voxelPosToWorld(vec3 vxlp) {\n    return vxlp * kScale + kTranslate;\n}\n\nfloat blobSphere(vec3 p, float r) {\n    return 1.0 / (1.0 + pow(length(p / r), 2.0));\n}\n\nfloat scene(vec3 p) {\n    const float kThreshould = 0.5;\n    float d = 0.0;\n    d += blobSphere(p + sin(time * vec3(1.5, 2.1, 0.5)) * vec3(0.5, 0.6, 0.3), 0.4);\n    d += blobSphere(p + sin(time * vec3(2.3, 1.2, 1.7)) * vec3(0.6, 0.5, 0.8), 0.2);\n    d += blobSphere(p + sin(time * vec3(0.3, 1.2, 2.7)) * vec3(0.5, 0.4, 0.5), 0.3);\n    //d += 1.0 / (1.0 + pow(length(p * 2.0), 2.0));\n    return kThreshould - d;\n}\n\nvec3 sceneNormal(vec3 p) {\n    vec3 EPS = vec3(0.01, 0.0, 0.0);\n    vec3 n;\n    n.x = scene(p + EPS.xyz) - scene(p - EPS.xyz);\n    n.y = scene(p + EPS.zxy) - scene(p - EPS.zxy);\n    n.z = scene(p + EPS.yzx) - scene(p - EPS.yzx);\n    return normalize(n);\n}\n\nvec3 smoothVertex(vec3 ip) {\n    vec3 p = ip;\n    vec3 n = sceneNormal(p);\n    for(int i = 0; i < 8; i++) {\n        float d = scene(p);\n        p -= n * d;\n        if(abs(d) < 0.01) { break; }\n    }\n    return p;\n}\n\nvec4 shading(vec3 p, vec3 n) {\n    vec3 kDc = vec3(0.6, 0.05, 0.15);\n    vec3 kSp = vec3(1.0, 1.0, 1.0) * 0.2;\n    vec3 kFc = vec3(0.3,0.1,0.15);\n    vec3 L = normalize(vec3(1.0, 1.0, 1.0));\n    float d = dot(L, n);\n    float s = 0.0;\n    if(d > 0.0) {\n        vec3 h = (normalize(-p) + L) * 0.5;\n        s = pow(max(0.0, dot(h, n)), 4.0);\n    }\n    float kR0 = 0.02;\n    float F =  kR0 + (1.0 - kR0) * pow(1.0 - max(0.0, dot(normalize(-p), n)), 5.0);\n    \n    return vec4((max(0.0, d) * 0.6 + 0.2) * kDc + s * kSp + F * kFc, 1.0);\n}\n\nvoid main() {\n    // vertex index in quad face (2 triangles: 0-5)\n    float faceVertId = mod(vertexId, 6.0);\n    // face index\n    float faceId = floor(vertexId / 6.0);\n    // fece index in corner\n    float cornerFaceId = mod(faceId, 3.0);\n    // edge index in corner\n    float cornerEdgeId = mod(faceId, 3.0);\n    // corner index (1 corner = 3 faces = 3 * 6 verts)\n    float cornerId = floor(vertexId / 18.0);\n    // corner position\n    vec3 cornerPos;\n    cornerPos.x = mod(cornerId, kNumVertX);\n    cornerPos.y = mod(floor(cornerId / kNumVertX), kNumVertY);\n    cornerPos.z = mod(floor(cornerId / (kNumVertX * kNumVertY)), kNumVertY);\n    \n    vec3 faceNormal;\n    vec3 faceTangent;\n    vec3 faceCotangent;\n    vec3 faceColor;\n    if(cornerEdgeId == 0.0) {\n        faceNormal = vec3(1.0, 0.0, 0.0);\n        faceTangent = vec3(0.0, 0.0, -1.0);\n        faceCotangent = vec3(0.0, 1.0, 0.0);\n    } else if(cornerEdgeId == 1.0) {\n        faceNormal = vec3(0.0, 1.0, 0.0);\n        faceTangent = vec3(1.0, 0.0, 0.0);\n        faceCotangent = vec3(0.0, 0.0, -1.0);\n    } else {\n        faceNormal = vec3(0.0, 0.0, 1.0);\n        faceTangent = vec3(1.0, 0.0, 0.0);\n        faceCotangent = vec3(0.0, 1.0, 0.0);\n    }\n    vec3 anotherPos = cornerPos + faceNormal;\n    \n    // sampling points\n    vec3 p0 = voxelPosToWorld(cornerPos);\n    vec3 p1 = voxelPosToWorld(anotherPos);\n    \n    // field value\n    float d0 = scene(p0);\n    float d1 = scene(p1);\n    \n    vec3 p;\n    vec3 vertNorm;\n    \n    if(d0 * d1 > 0.0) {\n        // no face\n        p = p0;\n        vertNorm = vec3(1.0, 1.0, 1.0);\n    } else {\n        // have a face\n        if(d1 < d0) {\n            // 0->1 is standard normal.\n            // otherwise flip triangle\n            if(faceVertId == 0.0) {\n                faceVertId = 2.0;\n            } else if(faceVertId == 2.0) {\n                faceVertId = 0.0;\n            } else if(faceVertId == 3.0) {\n                faceVertId = 5.0;\n            } else if(faceVertId == 5.0) {\n                faceVertId = 3.0;\n            }\n            faceNormal *= -1.0;\n        }\n        \n        /*\n        face\n        2 4-5\n        |\\ \\|\n        0-1 3\n        */\n        float kFaceSize = mix(0.45, 0.5, clamp(cos(time * 1.5) * 4.0 + 0.5, 0.0, 1.0));\n        vec3 edgeMidPos = (cornerPos + anotherPos) * 0.5;\n        vec3 faceVertPos;\n        if(faceVertId == 0.0) {\n            faceVertPos = edgeMidPos + faceTangent * -kFaceSize + faceCotangent * -kFaceSize;\n        } else if(faceVertId == 1.0) {\n            faceVertPos = edgeMidPos + faceTangent *  kFaceSize + faceCotangent * -kFaceSize;\n        } else if(faceVertId == 2.0) {\n            faceVertPos = edgeMidPos + faceTangent * -kFaceSize + faceCotangent *  kFaceSize;\n        } else if(faceVertId == 3.0) {\n            faceVertPos = edgeMidPos + faceTangent *  kFaceSize + faceCotangent * -kFaceSize;\n        } else if(faceVertId == 4.0) {\n            faceVertPos = edgeMidPos + faceTangent * -kFaceSize + faceCotangent *  kFaceSize;\n        } else if(faceVertId == 5.0) {\n            faceVertPos = edgeMidPos + faceTangent *  0.5 + faceCotangent *  0.5;\n        }\n        p = voxelPosToWorld(faceVertPos);\n        \n        // smoothing\n        vec3 sp = smoothVertex(p);\n        vertNorm = sceneNormal(p);\n        \n        float vmix = clamp(sin(time * 0.35) * 2.0 + 0.5, 0.0, 1.0);\n        p = mix(p, sp, vmix);\n        vertNorm = mix(faceNormal, vertNorm, vmix);\n    }\n    \n    vec3 eye = rotX(rotY(vec3(0.0, 0.0, 3.5), -mouse.x * 2.0), mouse.y);\n    //vec3 eye = vec3(0.0, 0.0, 3.0);\n    mat4 viewMat = lookat(eye, vec3(0.0), vec3(0.0, 1.0, 0.0));\n    vec3 viewPos = (viewMat * vec4(p, 1.0)).xyz;\n    vec3 viewNorm = normalize((viewMat * vec4(vertNorm, 0.0)).xyz);\n    \n    gl_Position = perspective(viewPos, 60.0, 0.1, 10.0);\n    gl_PointSize = 2.0;\n    //v_color = vec4(abs(faceNormal), 1.0);\n    //v_color = vec4(vertNorm * 0.5 + 0.5, 1.0);\n    //v_color = vec4(viewNorm * 0.5 + 0.5, 1.0);\n    v_color = shading(viewPos, viewNorm);\n}\n"
  },
  "screenshotURL": "data/images/images-290zfqwqwzy8ecig6-thumbnail.jpg",
  "hasSound": "",
  "views": {
    "$numberInt": "768"
  },
  "likes": {
    "$numberInt": "3"
  },
  "revisionId": "3vraw9ESWCopjk4f2"
}