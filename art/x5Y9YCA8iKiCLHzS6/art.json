{
  "_id": "x5Y9YCA8iKiCLHzS6",
  "owner": {
    "_id": "Pexi77zfde4iNKmrT",
    "createdAt": {
      "$date": {
        "$numberLong": "1493741221077"
      }
    },
    "profile": {
      "name": "Kolargon Generative",
      "avatarUrl": "https://lh3.googleusercontent.com/-tiKYx1U71-Q/AAAAAAAAAAI/AAAAAAAAAGg/b-eEUsFpspc/photo.jpg"
    },
    "username": "kolargon"
  },
  "createdAt": {
    "$date": {
      "$numberLong": "1523539817358"
    }
  },
  "modifiedAt": {
    "$date": {
      "$numberLong": "1523539817358"
    }
  },
  "origId": "xdgnE3FvNBNtDFynG",
  "name": "PROBLEM",
  "notes": "http://glslsandbox.com/e#38484.0",
  "rank": {
    "$numberDouble": "1.5002847992248667"
  },
  "private": true,
  "unlisted": false,
  "username": "kolargon",
  "avatarUrl": "https://lh3.googleusercontent.com/-tiKYx1U71-Q/AAAAAAAAAAI/AAAAAAAAAGg/b-eEUsFpspc/photo.jpg",
  "settings": "{\"num\":500,\"mode\":\"POINTS\",\"sound\":\"https://soundcloud.com/user-158087960/studiomix-douzirec-06-2007-flac\",\"lineSize\":\"NATIVE\",\"backgroundColor\":[0,0,0,1],\"shader\":\"//Created by K Machine from http://glslsandbox.com/e#46257.0\\nvec2 surfacePosition;\\nvec4 simFragCoord;\\nvec2 vertexResolution = resolution;\\n/*\\n * Original shader from: https://www.shadertoy.com/view/4tc3zf\\n */\\n\\n#ifdef GL_ES\\n//precision  mediump float;\\n#endif\\n\\n// glslsandbox //uniform s\\n//uniform  float time;\\n//uniform  vec2 vertexResolution;\\n\\n// shadertoy globals\\nfloat iTime = time;//;\\nvec3 iResolution  = vec3(vertexResolution, 0.0);//;\\n\\n// --------[ Original ShaderToy begins here ]---------- //\\n//***************************************************************************************************\\n//\\n// Galvanize / Alcatraz\\n// Jochen \\\"Virgill\\\" Feldkoetter\\n//\\n// Intro for Nordlicht demoparty 2014      Shadertoy version\\n//\\n//***************************************************************************************************\\n\\n\\n\\nint efx = 0;\\nint refleco = 0;\\nint snowo = 0;\\nvec4 orbitTrap = vec4(0.0);\\nfloat blend =0.0;\\nfloat d = 0.0;\\nfloat m = 0.0;\\nfloat kalitime =0.;\\nfloat depth = 0.;     \\nfloat prec =0.;\\nconst float scene = 35.;\\n\\n\\n// Rotate\\nvec3 rotXaxis(vec3 p, float rad)\\n{\\n\\tfloat z2 = cos(rad) * p.z - sin(rad) * p.y;\\n\\tfloat y2 = sin(rad) * p.z + cos(rad) * p.y;\\n\\tp.z = z2;\\n\\tp.y = y2;\\n\\treturn p;\\n}\\n\\nvec3 rotYaxis(vec3 p, float rad) \\n{\\n\\tfloat x2 = cos(rad) * p.x - sin(rad) * p.z;\\n\\tfloat z2 = sin(rad) * p.x + cos(rad) * p.z;\\n\\tp.x = x2;\\n\\tp.z = z2;\\n\\treturn p;\\n}\\n\\nvec3 rotZaxis(vec3 p, float rad) \\n{\\n\\tfloat x2 = cos(rad) * p.x - sin(rad) * p.y;\\n\\tfloat y2 = sin(rad) * p.x + cos(rad) * p.y;\\n\\tp.x = x2;\\n\\tp.y = y2;\\n\\treturn p;\\n}\\n\\n\\n// noise functions\\nfloat rand1(vec2 co)\\n{\\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\\n}\\n\\nfloat rand2(vec2 co)\\n{\\n    return fract(cos(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\\n}\\n\\n\\n\\n\\n// polyomial smooth min (IQ)\\nfloat sminPoly( float a, float b, float k )\\n{\\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\\n    return mix( b, a, h ) - k*h*(1.0-h);\\n}\\n\\n\\n// exponential smooth min (IQ)\\nfloat smin( float a, float b, float k )\\n{\\n    float res = exp( -k*a ) + exp( -k*b );\\n    return -log( res )/k;\\n}\\n\\n\\n// length\\nfloat length2(vec2 p) \\n{ \\n  \\treturn dot(p, p); \\n}\\n\\n// worley effect\\nfloat worley(vec2 p) \\n{\\n\\tfloat d = 1.;\\n\\tfor (int xo = -1; xo <= 1; ++xo)\\n\\tfor (int yo = -1; yo <= 1; ++yo) \\n    {\\n\\t\\tvec2 tp = floor(p) + vec2(xo, yo);\\n\\t\\td = min(d, length2(p - tp - vec2(rand1(tp))));\\n\\t}\\n\\treturn 3.*exp(-4.*abs(2.*d - 1.));\\n}\\n\\nfloat fworley(vec2 p) \\n{\\n\\treturn sqrt(sqrt(sqrt(worley(p*32. + 4.3 + iTime*.250) * sqrt(worley(p * 64. + 5.3 + iTime * -.125)) * sqrt(sqrt(worley(p * -128. +7.3))))));\\n}\\n\\n\\n// menger\\nfloat NewMenger(vec3 z)\\n{\\n\\tfloat Scale = 3.0;\\t\\t\\t\\t\\n\\tvec3 Offset = vec3(1.0,1.0,1.0);\\t\\t\\n\\tint Iterations = 6;\\t\\t\\t\\t\\t\\n\\tint ColorIterations = 3;\\t\\n\\n    for(int n = 0; n < 6; n++) \\n\\t{\\n\\tz.z*=1.+0.2*sin(iTime/4.0)+0.1;\\n\\t\\tz = abs(z);\\n\\t\\tif (z.x<z.y){ z.xy = z.yx;}\\n\\t\\tif (z.x< z.z){ z.xz = z.zx;}\\n\\t\\tif (z.y<z.z){ z.yz = z.zy;}\\n\\t\\tz = Scale*z-Offset*(Scale-1.0);\\n\\t\\tif( z.z<-0.5*Offset.z*(Scale-1.0))  z.z+=Offset.z*(Scale-1.0);\\n\\n\\t\\tif (n<ColorIterations) orbitTrap = min(orbitTrap, (vec4(abs(z),dot(z,z))));\\n\\n\\t}\\t\\t\\t\\t\\n\\treturn abs(length(z) ) * pow(Scale, float(-Iterations-1));\\n}\\n\\n\\n\\n// mandelbulb (Fractalforums.com)\\nfloat Mandelbulb(vec3 p)\\n{\\n\\tfloat Scale = 3.0;\\t\\t\\t\\t\\t\\n\\tint Iterations = 6;\\t\\t\\t\\n\\tint ColorIterations = 1;\\t\\n\\tfloat parachute=(1.-min(1.8*abs(sin((iTime-5.0)*3.1415/scene)),1.0)); // Fallschirm\\n\\tparachute = smoothstep(0.0,1.0,parachute)*35.0;\\n\\tvec3 w = p;\\n\\tfloat dr = 1.0+parachute;\\n\\tfloat r = 0.;\\n    for (int i=0; i<6; ++i)\\n\\t{\\n    \\tr = length(w);\\n\\t\\tif (r>4.0) break;\\n\\t\\tdr*=pow(r, 7.)*8.+1.;\\n\\t\\tfloat x = w.x; float x2 = x*x; float x4 = x2*x2;\\n\\t\\tfloat y = w.y; float y2 = y*y; float y4 = y2*y2;\\n\\t\\tfloat z = w.z; float z2 = z*z; float z4 = z2*z2;\\n\\t\\tfloat k3 = x2 + z2;\\n\\t\\tfloat k2 = inversesqrt( pow(k3, 7.0) );\\n\\t\\tfloat k1 = x4 + y4 + z4 - 6.0*y2*z2 - 6.0*x2*y2 + 2.0*z2*x2;\\n\\t\\tfloat k4 = x2 - y2 + z2;\\n\\t\\tw =  vec3(64.0*x*y*z*(x2-z2)*k4*(x4-6.0*x2*z2+z4)*k1*k2,-16.0*y2*k3*k4*k4 + k1*k1,-8.0*y*k4*(x4*x4 - 28.0*x4*x2*z2 + 70.0*x4*z4 - 28.0*x2*z2*z4 + z4*z4)*k1*k2);\\n\\t\\tw-=p;\\n\\t\\tw = rotYaxis(w,sin(iTime*0.14));\\t\\n\\t\\tw = rotZaxis(w,cos(iTime*0.2));\\t\\n\\t\\torbitTrap = min(orbitTrap, abs(vec4(p.x*w.z, p.y*w.x, 0., 0.)));\\n\\n\\t\\tif (i>=ColorIterations+2) orbitTrap = vec4(0.0);\\n\\t} \\n\\treturn  .5*log(r)*r/dr;\\n}\\n\\n// kalibox (Kali / Fractalforums.com)\\nfloat Kalibox(vec3 pos) \\n{\\n\\tfloat Scale = 1.84;\\t\\t\\t\\t\\t\\t\\n\\tint Iterations = 14;\\t\\t\\t\\n\\tint ColorIterations = 3;\\t\\t\\n\\tfloat MinRad2 = 0.34;\\t\\n\\tvec3 Trans = vec3(0.076,-1.86,0.036);\\t\\t\\t\\n\\tvec3 Julia = vec3(-0.66,-1.2+(kalitime/80.),-0.66);\\t\\n\\tvec4 scale = vec4(Scale, Scale, Scale, abs(Scale)) / MinRad2;\\n\\tfloat absScalem1 = abs(Scale - 1.0);\\n\\tfloat AbsScaleRaisedTo1mIters = pow(abs(Scale), float(1-Iterations));\\n    vec4 p = vec4(pos,1), p0 = vec4(Julia,1); \\n\\tfor (int i=0; i<14; i++)\\n\\t\\t{\\n\\t\\t\\tp.xyz=abs(p.xyz)+Trans;\\n\\t\\t\\tfloat r2 = dot(p.xyz, p.xyz);\\n\\t\\t\\tp *= clamp(max(MinRad2/r2, MinRad2), 0.0, 1.0); \\n\\t\\t\\tp = p*scale + p0;\\n\\t\\t\\tif (i<ColorIterations) orbitTrap = min(orbitTrap, abs(vec4(p.xyz,r2)));\\n\\t\\t}\\n\\t\\treturn (    (length(p.xyz) - absScalem1) / p.w - AbsScaleRaisedTo1mIters    );\\n}\\n\\n// balls and cube\\nfloat Balls(vec3 pos) \\n{\\n\\tm = length(max(abs(rotYaxis(rotXaxis(pos+vec3(0.0,-0.3,0.0),iTime),iTime*0.3))-vec3(0.35,0.35,0.35),0.0))-0.02; \\n\\tm = smin (m, length(pos+vec3(0.0,-0.40,1.2+0.5*sin(0.8*iTime+0.0)))-0.4,7.4);\\n\\tm = smin (m, length(pos+vec3(0.0,-0.40,-1.2-0.5*sin(0.8*iTime+0.4)))-0.4,7.4);\\n\\tm = smin (m, length(pos+vec3(-1.2-0.5*sin(0.8*iTime+0.8),-0.40,0.0))-0.4,7.4);\\n\\tm = smin (m, length(pos+vec3(1.2+0.5*sin(0.8*iTime+1.2),-0.40,0.0))-0.4,7.4);\\n\\tm = smin (m, length(pos+vec3(0.0,-1.6+0.5*-sin(0.8*iTime+1.6),0.0))-0.4,7.4);\\n\\t//m+= klang1*(0.003*cos(50.*pos.x)+0.003*cos(50.*pos.y)); //distortion\\n\\torbitTrap = vec4(length(pos)-0.8*pos.z,length(pos)-0.8*pos.y,length(pos)-0.8*pos.x,0.0)*1.0;\\n\\treturn m;\\n}\\n\\n// plane\\nfloat sdPlane(in vec3 p) \\n{\\n\\treturn p.y+(0.025*sin(p.x*10.  +1.4*iTime  ))+(0.025*sin(p.z*12.3*cos(0.4-p.x)+  1.6*iTime  ))-0.05;\\n}\\n\\n// cylinder \\nfloat sdCylinder( vec3 p, vec3 c )\\n{\\n\\treturn length(p.xz-c.xy)-c.z;\\n}\\n\\n\\n// scene\\nfloat map(in vec3 p)\\n{\\n\\torbitTrap = vec4(10.0);\\n\\td = sdPlane(p);\\n\\n\\tif (efx == 0) {\\t\\t\\t// balls and cube\\n\\tm = Balls(p); \\n\\t}\\n\\tif (efx == 1) {\\t\\t\\t// milky menger\\n\\tm = NewMenger(rotYaxis(rotXaxis(p-vec3(0.0,sin(iTime/0.63)+0.2,0.0),0.15*iTime),0.24*iTime));\\n\\t}\\n\\tif (efx == 2) {\\t\\t\\t// mandelbulb\\n\\tm = Mandelbulb(rotYaxis(rotXaxis(p,iTime*0.1),0.21*iTime));\\n\\t}\\n\\tif (efx == 3) {\\t\\t\\t// kalibox\\n\\tm = Kalibox(rotYaxis(rotXaxis(p,1.50),0.1*iTime));\\n\\t}\\n\\tif (efx == 4 || efx == 5) { // tunnel or swirl\\n\\tvec3 c = vec3(2.0, 8.0, 2.0);\\n\\tvec3 q = mod(p-vec3(1.0,0.1*iTime,1.0),c)-0.5*c;\\n\\tfloat kali = Kalibox(rotYaxis(q,0.04*iTime));\\n\\tm = max(kali,-sdCylinder(p,vec3(0.0,0.0,0.30+0.1*sin(iTime*0.2))) );\\n\\t}\\n\\td = sminPoly (m, d, 0.04); \\n   \\treturn d;\\n}\\n\\n\\n// normal calculation\\nvec3 calcNormal(in vec3 p) \\n{\\n    vec3 e = vec3(0.001, 0.0, 0.0);\\n    vec3 nor = vec3(map(p + e.xyy) - map(p - e.xyy),  map(p + e.yxy) - map(p - e.yxy),  map(p + e.yyx) - map(p - e.yyx));\\n    return normalize(nor);\\n}\\n\\n// cast\\nfloat castRay(in vec3 ro, in vec3 rd, in float maxt) \\n{\\n    float precis = prec;\\n    float h = precis * 2.0;\\n    float t = depth;\\n\\n    for(int i = 0; i < 122; i++) \\n\\t{\\n        if(abs(h) < precis || t > maxt) break;\\n        orbitTrap = vec4(10.0);\\n\\t\\th = map(ro + rd * t);\\n        t += h;\\n\\t}\\n    return t;\\n}\\n\\n// softshadow (IQ)\\nfloat softshadow(in vec3 ro, in vec3 rd, in float mint, in float maxt, in float k) \\n{\\n    float sh = 1.0;\\n    float t = mint;\\n    float h = 0.0;\\n    for(int i = 0; i < 19; i++)  //23 gut!\\n\\t{\\n        if(t > maxt) continue;\\n\\t\\torbitTrap = vec4(10.0);\\n        h = map(ro + rd * t);\\n        sh = min(sh, k * h / t);\\n        t += h;\\n    }\\n    return sh;\\n}\\n\\n\\n// orbit color\\nvec3 BaseColor = vec3(0.2,0.2,0.2);\\nvec3 OrbitStrength = vec3(0.8, 0.8, 0.8);\\nvec4 X = vec4(0.5, 0.6, 0.6, 0.2);\\nvec4 Y = vec4(1.0, 0.5, 0.1, 0.7);\\nvec4 Z = vec4(0.8, 0.7, 1.0, 0.3);\\nvec4 R = vec4(0.7, 0.7, 0.5, 0.1);\\nvec3 getColor()\\n{\\n\\torbitTrap.w = sqrt(orbitTrap.w);\\n\\tvec3 orbitColor = X.xyz*X.w*orbitTrap.x + Y.xyz*Y.w*orbitTrap.y + Z.xyz*Z.w*orbitTrap.z + R.xyz*R.w*orbitTrap.w;\\n\\tvec3 color = mix(BaseColor,3.0*orbitColor,OrbitStrength);\\n\\treturn color;\\n}\\n\\n// particles (Andrew Baldwin)\\nfloat snow(vec3 direction)\\n{\\n\\tfloat help = 0.0;\\n\\tconst mat3 p = mat3(13.323122,23.5112,21.71123,21.1212,28.7312,11.9312,21.8112,14.7212,61.3934);\\n\\tvec2 uvx = vec2(direction.x,direction.z)+vec2(1.,iResolution.y/iResolution.x)*simFragCoord.xy / iResolution.xy;\\n\\tfloat acc = 0.0;\\n\\tfloat DEPTH = direction.y*direction.y-0.3;\\n\\tfloat WIDTH =0.1;\\n\\tfloat SPEED = 0.1;\\n\\tfor (int i=0;i<10;i++) \\n\\t{\\n\\t\\tfloat fi = float(i);\\n\\t\\tvec2 q = uvx*(1.+fi*DEPTH);\\n\\t\\tq += vec2(q.y*(WIDTH*mod(fi*7.238917,1.)-WIDTH*.5),SPEED*iTime/(1.+fi*DEPTH*.03));\\n\\t\\tvec3 n = vec3(floor(q),31.189+fi);\\n\\t\\tvec3 m = floor(n)*.00001 + fract(n);\\n\\t\\tvec3 mp = (31415.9+m)/fract(p*m);\\n\\t\\tvec3 r = fract(mp);\\n\\t\\tvec2 s = abs(mod(q,1.)-.5+.9*r.xy-.45);\\n\\t\\tfloat d = .7*max(s.x-s.y,s.x+s.y)+max(s.x,s.y)-.01;\\n\\t\\tfloat edge = .04;\\n\\t\\tacc += smoothstep(edge,-edge,d)*(r.x/1.0);\\n\\t\\thelp = acc;\\n\\t}\\n\\treturn help;\\n\\t}\\n\\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) \\n{\\n    \\n    if (iTime >=0. && iTime <=35. ) {efx=4; refleco=0; snowo=0;} \\n    if (iTime >35. && iTime <=70. ) {efx=0; refleco=1; snowo=1;}\\n    if (iTime >70. && iTime <=105.) {efx=1; refleco=0; snowo=1;} \\n    if (iTime >105.&& iTime <=140.) {efx=3; refleco=0; snowo=1;} \\n    if (iTime >140.&& iTime <=175.) {efx=2; refleco=0; snowo=1;}  \\n    if (iTime >175.&& iTime <=210.) {efx=4; refleco=0; snowo=0;}   \\n    if (iTime >210.&& iTime <=245.) {efx=5; refleco=0; snowo=0;}  \\n\\n\\tblend=min(2.0*abs(sin((iTime+0.0)*3.1415/scene)),1.0); \\n    if (iTime >245.) blend = 0.;\\n    vec2 uv = fragCoord.xy / iResolution.xy;\\n    vec2 p = uv * 2.0 - 1.0;\\n\\tp.x *= iResolution.x / iResolution.y;\\n\\tfloat theta = sin(iTime*0.03) * 3.14 * 2.0;\\n    float x = 3.0 * cos(theta)+0.007*rand1(fragCoord.xy); \\n    float z = 3.0 * sin(theta)+0.007*rand2(fragCoord.xy); \\n\\tvec3 ro; // camera\\n\\t\\n\\tif (efx==0) {\\n\\tprec = 0.001;\\n\\tro = vec3(x*0.2+1.0, 5.0, z*2.0-3.); \\t// camera balls and cube  \\n\\t}\\n\\tif (efx==1) {\\n\\tprec = 0.002;\\n\\tro = vec3(x*1.2, 7.0, z*2.0);  \\t\\t\\t// camera menger\\n\\t}\\n\\tif (efx==2) {\\n\\tprec = 0.002;\\n\\tro = vec3(x*1.0, 6.2, z*2.8);  \\t\\t\\t// camera mandelbulb\\n\\tdepth =4.;\\n\\t}\\n\\tif (efx==3) {\\n\\tkalitime = 40.;\\n\\tprec = 0.002;\\n\\tro = vec3(x*1.7, 2.6, 2.0);\\t \\t\\t\\t// camera kalibox\\n\\t}\\n\\tif (efx==4) {\\n\\t//time = iTime -2.5;\\n\\tprec = 0.002;\\n\\tkalitime = iTime-15.0;\\n\\tro = vec3(0.0, 8.0, 0.0001);   \\t\\t\\t// camera tunnel\\n\\t}\\n\\tif (efx==5) {\\n\\tprec = 0.004;\\n\\tkalitime = 210.+175.; \\n\\tro = vec3(0, 3.8, 0.0001);   \\t\\t\\t// camera swirl\\n\\t}\\n\\n\\n\\tvec3 ta = vec3(0.0, 0.25, 0.0);\\n    vec3 cw = normalize(ta - ro);\\n    vec3 cp = vec3(0.0, 1.0, 0.0);\\n    vec3 cu = normalize(cross(cw, cp));\\n    vec3 cv = normalize(cross(cu, cw));\\n\\tvec3 rd = normalize(p.x * cu + p.y * cv + 7.5 * cw);\\n\\n// render:\\n    vec3 col = vec3(0.0);\\n    float t = castRay(ro, rd, 12.0);\\n\\tvec3 pos = ro + rd *t;\\n\\tvec3 nor = calcNormal(pos);\\n\\tvec3 lig;\\t\\n\\tif (efx==4 || efx ==5 )  \\tlig = normalize(vec3(-0.4*sin(iTime*0.15), 1.0, 0.5));\\n\\telse if (efx==3)\\t\\t  \\tlig = normalize(vec3(-0.1*sin(iTime*0.2), 0.2, 0.4*sin(iTime*0.1)));\\t\\n\\telse \\t\\t\\t\\t\\t\\tlig = normalize(vec3(-0.4, 0.7, 0.5));\\n\\tfloat dif = clamp(dot(lig, nor), 0.0, 1.0);\\n\\tfloat spec = pow(clamp(dot(reflect(rd, nor), lig), 0.0, 1.0), 16.0);\\n\\tfloat sh;\\n\\tif (efx == 1 || efx == 5) sh = softshadow(pos, lig, 0.02, 20.0, 7.0);\\n\\tvec3 color = getColor();\\n\\tcol = ((0.8*dif+ spec) + 0.35*color);\\n\\tif (efx !=1 && efx != 5) sh = softshadow(pos, lig, 0.02, 20.0, 7.0); \\n\\tcol = col*clamp(sh, 0.0, 1.0);\\n\\n\\n// reflections:\\nif (refleco == 1) {\\n    vec3 col2 = vec3(0.0);\\n\\tvec3 ro2 = pos-rd/t;\\n\\tvec3 rd2 = reflect(rd,nor);\\n    float t2 = castRay(ro2, rd2, 7.0);\\n\\tvec3 pos2 = vec3(0.0);\\n\\tif (t2<7.0) {\\n\\tpos2 = ro2 + rd2* t2;\\n\\t}\\n    vec3 nor2 = calcNormal(pos2);\\n\\tfloat dif2 = clamp(dot(lig, nor2), 0.0, 1.0);\\n\\tfloat spec2 = pow(clamp(dot(reflect(rd2, nor2), lig), 0.0, 1.0), 16.0);\\n\\tcol+= 0.22*vec3(dif2*color+spec2);\\n}\\n\\n// postprocessing\\nfloat klang1=0.75;\\nvec2 uv2=-0.3+2.*fragCoord.xy/iResolution.xy;\\ncol-=0.20*(1.-klang1)*rand1(uv2.xy*iTime);\\t\\t\\t\\t\\t\\t\\t\\ncol*=.9+0.20*(1.-klang1)*sin(10.*iTime+uv2.x*iResolution.x);\\t\\ncol*=.9+0.20*(1.-klang1)*sin(10.*iTime+uv2.y*iResolution.y);\\t\\nfloat Scr=1.-dot(uv2,uv2)*0.15;\\nvec2 uv3=fragCoord.xy/iResolution.xy;\\nfloat worl = fworley(uv3 * iResolution.xy / 2100.);\\nworl *= exp(-length2(abs(2.*uv3 - 1.))); \\nworl *= abs(1.-0.6*dot(2.*uv3-1.,2.*uv3-1.));\\nif (efx==4) col += vec3(0.4*worl,0.35*worl,0.25*worl);\\nif (efx==5)  col += vec3(0.2*worl); \\nfloat g2 = (blend/2.)+0.39;\\nfloat g1 = ((1.-blend)/2.);\\nif (uv3.y >=g2+0.11) col*=0.0;\\nif (uv3.y >=g2+0.09) col*=0.4;\\nif (uv3.y >=g2+0.07) {if (mod(uv3.x-0.06*iTime,0.18)<=0.16) col*=0.5;}\\nif (uv3.y >=g2+0.05) {if (mod(uv3.x-0.04*iTime,0.12)<=0.10) col*=0.6;}\\nif (uv3.y >=g2+0.03) {if (mod(uv3.x-0.02*iTime,0.08)<=0.06) col*=0.7;}\\nif (uv3.y >=g2+0.01) {if (mod(uv3.x-0.01*iTime,0.04)<=0.02) col*=0.8;}\\nif (uv3.y <=g1+0.10) {if (mod(uv3.x+0.01*iTime,0.04)<=0.02) col*=0.8;}\\nif (uv3.y <=g1+0.08) {if (mod(uv3.x+0.02*iTime,0.08)<=0.06) col*=0.7;}\\nif (uv3.y <=g1+0.06) {if (mod(uv3.x+0.04*iTime,0.12)<=0.10) col*=0.6;}\\nif (uv3.y <=g1+0.04) {if (mod(uv3.x+0.06*iTime,0.18)<=0.16) col*=0.5;}\\nif (uv3.y <=g1+0.02) col*=0.4;\\nif (uv3.y <=g1+0.00) col*=0.0;\\n\\nif (snowo == 1) fragColor = (vec4(col*1.0*Scr-1.6*snow(cv), 1.0)*blend)*vec4(1.0, 0.93, 1.0, 1.0);\\nelse fragColor = vec4(col*1.0*Scr, 1.0)*blend;\\n}\\n\\n\\n\\n\\n// --------[ Original ShaderToy ends here ]---------- //\\n\\nvoid main(void)\\n{float finalDesiredPointSize = 3.;\\nfloat maxFinalSquareSideSize = floor(sqrt(vertexCount));\\nfloat finalMaxVertexCount = maxFinalSquareSideSize*maxFinalSquareSideSize;\\nfloat maxVerticesPerLine = floor(maxFinalSquareSideSize  *resolution.x/resolution.y);\\nvertexResolution = vec2(maxVerticesPerLine, floor(finalMaxVertexCount/maxVerticesPerLine));\\nfloat finalVertexCount = vertexResolution.x*vertexResolution.y;\\nfloat finalVertexId = mod(vertexId,finalVertexCount);\\nfloat x = mod(finalVertexId, vertexResolution.x);\\nfloat y = floor(finalVertexId / vertexResolution.x);\\nsimFragCoord = vec4(x,y,1.,1.);//simfragCoord will replace the gl_FragCoord of fragment shader\\nfloat u_i = (x /vertexResolution.x);\\nfloat v_i = (y /vertexResolution.y);\\nfloat sizeFactor = finalDesiredPointSize*vertexResolution.x/resolution.x;\\nfloat ux = sizeFactor*(u_i - 0.5);\\nfloat vy = sizeFactor*(v_i - 0.5);\\ngl_PointSize = finalDesiredPointSize;\\ngl_Position = vec4(ux, vy, 0., 1.);\\nsurfacePosition = vec2(ux,vy);\\n\\n    iTime = time;\\n    iResolution = vec3(vertexResolution, 0.0);\\n\\n    mainImage(v_color, simFragCoord.xy);\\n    v_color.a = 1.0;\\n}\"}",
  "screenshotURL": "data/images/images-taxxzmmw7lbt33f4j-thumbnail.jpg",
  "hasSound": true,
  "views": {
    "$numberInt": "4"
  },
  "likes": {
    "$numberInt": "0"
  },
  "revisionId": "ZSMgM6TextnkcNvvw"
}