{
  "_id": "xCGKaZubja8uuYkJH",
  "owner": {
    "_id": "NHZzD8e27B7poHpfx",
    "createdAt": {
      "$date": {
        "$numberLong": "1445941822749"
      }
    },
    "profile": {
      "name": "Paul Malin",
      "avatarUrl": "https://pbs.twimg.com/profile_images/2157402471/Profile_200x200.png"
    },
    "username": "P_Malin"
  },
  "createdAt": {
    "$date": {
      "$numberLong": "1446568826916"
    }
  },
  "modifiedAt": {
    "$date": {
      "$numberLong": "1446568826916"
    }
  },
  "origId": null,
  "name": "Sky",
  "private": true,
  "username": "P_Malin",
  "settings": "{\"num\":16384,\"mode\":\"TRIANGLES\",\"sound\":\"\",\"lineSize\":\"NATIVE\",\"backgroundColor\":[1,1,1,1],\"shader\":\"// Sky - @P_Malin\\n\\nfloat g_cameraFar = 8000.0;\\n\\nvec3 g_sunColor = vec3( 1.0, 0.8, 0.5 ) * 100.0;\\nvec3 g_skyTop =  vec3( 0.01, 0.6, 1.0 ) * 0.1;\\nvec3 g_skyBottom =  vec3( 0.01, 0.8, 0.8 ) * 1.0;\\n\\n\\n#define PI radians( 180.0 )\\n\\nvec3 g_sunDir = vec3( 0.0, 0.1, 1.0 );\\n\\nvec3 GetSunDir()\\n{\\n  \\treturn normalize( g_sunDir );\\n}\\n\\nfloat GetCosSunRadius()\\n{\\n  return 0.01;\\n}\\n\\nfloat GetSunIntensity()\\n{  \\t\\n  \\treturn 0.0001;\\n}\\n\\nvoid GetQuadInfo( const float vertexIndex, out vec2 quadVertId, out float quadId )\\n{\\n    float twoTriVertexIndex = mod( vertexIndex, 6.0 );\\n    float triVertexIndex = mod( vertexIndex, 3.0 );\\n  \\n    if \\t\\t( twoTriVertexIndex < 0.5 ) quadVertId = vec2( 0.0, 0.0 );\\n    else if\\t( twoTriVertexIndex < 1.5 )\\tquadVertId = vec2( 1.0, 0.0 );\\n    else if ( twoTriVertexIndex < 2.5 )\\tquadVertId = vec2( 0.0, 1.0 );\\n    else if ( twoTriVertexIndex < 3.5 )\\tquadVertId = vec2( 1.0, 0.0 );\\n    else if ( twoTriVertexIndex < 4.5 )\\tquadVertId = vec2( 1.0, 1.0 );\\n    else \\t\\t\\t\\t\\t\\t\\t\\tquadVertId = vec2( 0.0, 1.0 );\\n\\n    quadId = floor( vertexIndex / 6.0 );\\n}\\n\\n\\nvoid GetQuadTileInfo( const vec2 quadVertId, const float quadId, const vec2 vDim, out vec2 vQuadTileIndex, out vec2 vQuadUV )\\n{\\n    vQuadTileIndex.x = floor( mod( quadId, vDim.x ) );\\n    vQuadTileIndex.y = floor( quadId / vDim.x );\\n\\n  \\tvQuadUV.x = floor(quadVertId.x + vQuadTileIndex.x);\\n    vQuadUV.y = floor(quadVertId.y + vQuadTileIndex.y);\\n\\n    vQuadUV = vQuadUV * (1.0 / vDim);\\n}\\n\\n\\nvoid GetQuadTileInfo( const float vertexIndex, const vec2 vDim, out vec2 vQuadTileIndex, out vec2 vQuadUV )\\n{\\n  \\tvec2 quadVertId;\\n  \\tfloat quadId;\\n\\tGetQuadInfo( vertexIndex, quadVertId, quadId );  \\n  \\tGetQuadTileInfo( quadVertId, quadId, vDim, vQuadTileIndex, vQuadUV );   \\n}\\n\\n\\nstruct SurfaceInfo\\n{\\n\\tvec3 vPos;\\n  \\tvec3 vNormal;\\n\\tfloat fGloss;\\n};\\n\\nvoid AddDirectionalLight( vec3 vLightDir, vec3 vLightColor, const SurfaceInfo surfaceInfo, const vec3 vCameraPos, inout vec3 vDiffuse, inout vec3 vSpecular )\\n{\\n  vec3 vViewDir = normalize(vCameraPos-surfaceInfo.vPos);\\n  \\n  float NdotL = max( 0.0, dot( vLightDir, surfaceInfo.vNormal ) );\\n  \\n  vec3 vHalfAngle = normalize( vViewDir + vLightDir );\\n\\n  float NdotH = max( 0.0, dot( vHalfAngle, surfaceInfo.vNormal ) );\\n  \\n  vDiffuse += NdotL * vLightColor;\\n\\n  float fPower = surfaceInfo.fGloss;\\n  vSpecular += pow( NdotH, fPower ) * 2.0 * NdotL * vLightColor;\\n}\\n\\n\\n\\n\\nvec3 LightSurface( const SurfaceInfo surfaceInfo, const vec3 vCameraPos, const vec3 vAlbedo, float fShadow )\\n{   \\n  vec3 vDiffuseLight = vec3(0.0);\\n  vec3 vSpecLight = vec3(0.0);\\n\\n  AddDirectionalLight( GetSunDir(), g_sunColor * 0.01 * fShadow, surfaceInfo, vCameraPos, vDiffuseLight, vSpecLight );\\n  \\n  vec3 vViewDir = normalize(vCameraPos-surfaceInfo.vPos);\\n  \\n  float fNdotD = clamp(dot(surfaceInfo.vNormal, vViewDir), 0.0, 1.0);\\n  vec3 vR0 = vec3(0.04);\\n  vec3 vFresnel = vR0 + (1.0 - vR0) * pow(1.0 - fNdotD, 5.0);  \\n  \\n  vec3 vColor = mix( vDiffuseLight * vAlbedo, vSpecLight, vFresnel );\\n  \\n  return vColor;\\n}\\n\\nvec3 PostProcess( vec3 vColor, float fExposure )\\n{\\n  vColor = vec3(1.0) - exp2( vColor * -fExposure );\\n\\n  vColor = pow( vColor, vec3(1.0 / 2.2) );\\n\\n  return vColor;\\n}\\n\\nvec3 ApplyVignetting( const in vec2 vUV, const in vec3 vInput )\\n{\\n\\tvec2 vOffset = (vUV - 0.5) * sqrt(2.0);\\n\\t\\n\\tfloat fDist = dot(vOffset, vOffset);\\n\\t\\n\\tconst float kStrength = 0.95;\\n\\tconst float kPower = 1.5;\\n\\n\\treturn vInput * ((1.0 - kStrength) +  kStrength * pow(max(0.0, 1.0 - fDist), kPower));\\n}\\n\\n\\nstruct SceneVertex\\n{\\n  \\tvec3 vWorldPos;\\n  \\tvec3 vColor;\\n\\tfloat fAlpha;\\n};\\n\\n\\n\\nvoid GetMatrixFromZY( const vec3 vZ, const vec3 vY, out mat3 m )\\n{\\n   vec3 vX = normalize( cross( vY, vZ ) );\\n   vec3 vOrthoY = normalize( cross( vZ, vX ) );\\n   m[0] = vX;\\n   m[1] = vOrthoY;\\n   m[2] = vZ;\\n}\\n\\nvoid GetMatrixFromZ( vec3 vZAxis, out mat3 m )\\n{\\n  \\tvec3 vZ = normalize(vZAxis);\\n   \\tvec3 vY = vec3( 0.0, 1.0, 0.0 );\\n  \\tif ( abs(vZ.y) > 0.99 )\\n    {\\n       vY = vec3( 1.0, 0.0, 0.0 );\\n    }\\n  \\tGetMatrixFromZY( vZ, vY, m );\\n}\\n\\nvec3 GetBackdropColor( vec3 vViewDir, vec3 vCameraPos )\\n{\\n  \\tfloat VdotL = dot( normalize(vViewDir), GetSunDir() );\\n  \\n  \\tVdotL = clamp( VdotL, 0.0, 1.0 );\\n  \\n  \\tfloat fShade = 0.0;\\n\\n  \\tfShade = acos( VdotL ) * (1.0 / PI);\\n  \\n  \\tfloat fCosSunRadius = GetCosSunRadius();\\n  \\n  \\tfShade = max( 0.0, (fShade - fCosSunRadius) / (1.0 - fCosSunRadius) );    \\n  \\n  \\tfShade = GetSunIntensity() / pow(fShade, 1.5);\\n  \\n  \\tvec3 vColor = mix( g_skyBottom, g_skyTop, vViewDir.y * 0.5 + 0.5 );\\n      \\n    vColor += vec3( fShade * g_sunColor );\\n    return vColor;\\n}\\n\\n#define g_backdropSegments \\t\\t\\t32.0\\n#define g_backdropSlices \\t\\t\\t32.0\\n#define g_backdropQuads \\t\\t\\t( g_backdropSegments * g_backdropSlices )\\n#define g_backdropVertexCount \\t\\t( g_backdropQuads * 6.0 )\\n\\nvoid GenerateBackdropVertex( const float vertexIndex, const vec3 vCameraPos, out SceneVertex outSceneVertex )\\n{\\n    vec2 vBackdropDim = vec2( g_backdropSegments, g_backdropSlices );\\n    \\n  \\tvec2 vQuadTileIndex;\\n    vec2 vUV;  \\n  \\tGetQuadTileInfo( vertexIndex, vBackdropDim, vQuadTileIndex, vUV );\\n\\n    float fSlicePos = 0.0;\\n  \\n  \\tfloat fSunMeshPinch = 5.0;\\n  \\n  \\tif (vQuadTileIndex.y > 0.0)\\n    {\\n      \\tfloat t = pow( vUV.y, fSunMeshPinch );\\n  \\t\\tfloat fCosSunRadius = GetCosSunRadius();\\n      \\tfSlicePos = fCosSunRadius + t * (1.0- fCosSunRadius);\\n    }\\n    \\n  \\tvec3 vSpherePos;\\n  \\tfloat fElevation = fSlicePos * PI;\\n  \\tvSpherePos.z = cos( fElevation );\\n\\n  \\tfloat fHeading = vUV.x * PI * 2.0;\\n  \\tfloat fSliceRadius = sqrt( 1.0 - vSpherePos.z * vSpherePos.z );\\n  \\tvSpherePos.x = sin( fHeading ) * fSliceRadius;\\n  \\tvSpherePos.y = cos( fHeading ) * fSliceRadius;\\n  \\n\\tmat3 m;\\n  \\n  \\tGetMatrixFromZ( GetSunDir(), m );\\n    \\n  \\tvec3 vLocalSpherePos = m * vSpherePos;\\n\\n  \\tfloat fBackdropDistance = g_cameraFar; \\n  \\tvec3 vWorldSpherePos = vLocalSpherePos * fBackdropDistance;\\n\\n  \\tvWorldSpherePos += vCameraPos;\\n  \\n    outSceneVertex.vWorldPos = vWorldSpherePos;\\n      \\n  \\toutSceneVertex.vColor = GetBackdropColor( vLocalSpherePos, vCameraPos );\\n\\n  \\toutSceneVertex.fAlpha = 1.0;\\n}  \\n\\nvoid main()\\n{ \\n  \\tSceneVertex sceneVertex;\\n  \\n  \\tvec2 vMouse = mouse;\\n  \\n  \\tfloat fov = 1.5;\\n  \\n  \\tfloat fMouseX = (vMouse.x * 0.5 + 0.5);\\n  \\tfMouseX = fMouseX * fMouseX;\\n \\n  \\tfloat fOrbitDistance = 10.0;\\n\\n  \\tfloat orbitAngle = mouse.x * PI  * 2.0;\\n  \\n  \\tvec3 vCameraPos = vec3( sin(orbitAngle), 0.0, cos(orbitAngle) ) * fOrbitDistance;\\n  \\tvec3 vCameraTarget = vec3( 0.0, vMouse.y * 10.5, 0.0 );\\n  \\tvec3 vCameraUp = vec3( 0.0, 1.0, 0.0 );\\n  \\n  \\tif( false )\\n    {\\n      vCameraPos = vec3( 10.0, 8.0, 30.0 );\\n      vCameraTarget = vec3( 0.0, 0.0, 0.0 );\\n      vCameraUp = vec3( 0.0, 1.0, 0.0);\\n    }\\n  \\n  \\tvec3 vCameraForwards = normalize(vCameraTarget - vCameraPos);\\n  \\n  \\tmat3 mCamera;\\n    GetMatrixFromZY( vCameraForwards, normalize(vCameraUp), mCamera );\\n  \\n  \\tfloat vertexIndex = vertexId;\\n  \\n  \\t// Backdrop\\n  \\tif ( vertexIndex >= 0.0 && vertexIndex < g_backdropVertexCount )\\n    {\\n    \\tGenerateBackdropVertex( vertexIndex, vCameraPos, sceneVertex );\\n    }\\n  \\tvertexIndex -= g_backdropVertexCount;\\n\\n  \\tif ( vertexIndex >= 0.0 )\\n    {\\n      sceneVertex.vWorldPos = vec3(0.0);\\n      sceneVertex.vColor = vec3(0.0);\\n      sceneVertex.fAlpha = 0.0;\\n    }\\n\\n    // Fianl output position\\n\\tvec3 vViewPos = sceneVertex.vWorldPos;\\n    vViewPos -= vCameraPos;\\n  \\tvViewPos =  vViewPos * mCamera;\\n  \\t\\n  \\tvec2 vFov = vec2( 1.0, resolution.x / resolution.y ) * fov;\\n  \\tvec2 vScreenPos = vViewPos.xy * vFov;\\n\\n\\tgl_Position = vec4( vScreenPos.xy, -1.0, vViewPos.z );\\n  \\n  \\t// Final output color\\n  \\tvec3 vFinalColor = sceneVertex.vColor;\\n  \\n  \\t//vFinalColor = ApplyVignetting( (gl_Position.xy / gl_Position.w) * 0.5 + 0.5, vFinalColor );  \\n  \\n  \\tfloat VdotL = dot( vCameraForwards, -GetSunDir() );\\n  \\n  \\t// Adjust exposure if we are looking towards the sun\\n  \\tfloat fExposure = (0.5 + VdotL * 0.5) * 5.0;\\n  \\n  \\tfExposure = 1.0;\\n  \\n  \\tfExposure += 0.5;\\n  \\n  \\tfExposure *= min( 1.0, time / 5.0 );\\n  \\n  \\tvFinalColor = PostProcess( vFinalColor, fExposure );\\n  \\n  \\tv_color = vec4(vFinalColor * sceneVertex.fAlpha, sceneVertex.fAlpha);  \\n}\\n\"}",
  "screenshotURL": "data/images/images-7lcv6r9ndjifq0bz4-thumbnail.jpg",
  "views": {
    "$numberInt": "4"
  },
  "likes": {
    "$numberInt": "0"
  },
  "revisionId": "hmPL9Rtck6jaHnxpd",
  "rank": {
    "$numberDouble": "1.666819557582499"
  },
  "avatarUrl": "https://pbs.twimg.com/profile_images/2157402471/Profile_200x200.png"
}