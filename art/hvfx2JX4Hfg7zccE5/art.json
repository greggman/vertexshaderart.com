{
  "_id": "hvfx2JX4Hfg7zccE5",
  "owner": {
    "_id": "Pexi77zfde4iNKmrT",
    "createdAt": {
      "$date": {
        "$numberLong": "1493741221077"
      }
    },
    "profile": {
      "name": "Kolargon Generative",
      "avatarUrl": "https://lh3.googleusercontent.com/-tiKYx1U71-Q/AAAAAAAAAAI/AAAAAAAAAGg/b-eEUsFpspc/photo.jpg"
    },
    "username": "kolargon"
  },
  "createdAt": {
    "$date": {
      "$numberLong": "1522807318601"
    }
  },
  "modifiedAt": {
    "$date": {
      "$numberLong": "1522807318601"
    }
  },
  "origId": "tZJWzLbyDQHTztNqY",
  "name": "String theory for K Machine",
  "notes": "http://glslsandbox.com/e#25748.0",
  "rank": {
    "$numberDouble": "1.8000983912025503"
  },
  "private": true,
  "unlisted": false,
  "username": "kolargon",
  "avatarUrl": "https://lh3.googleusercontent.com/-tiKYx1U71-Q/AAAAAAAAAAI/AAAAAAAAAGg/b-eEUsFpspc/photo.jpg",
  "settings": {
    "num": 100000,
    "mode": "POINTS",
    "sound": "https://soundcloud.com/user-158087960/studiomix-douzirec-06-2007-flac",
    "lineSize": "NATIVE",
    "backgroundColor": [
      0,
      0,
      0,
      1
    ],
    "shader": "\n\n\n//Step 1 >> comment all precision, extension, uniforms and varying\n/*\n#ifdef GL_ES\nprecision mediump float;\n#endif\n \n#extension GL_OES_standard_derivatives : enable\n\nuniform float time;\nuniform vec2 mouse;\nuniform vec2 resolution;\nvarying vec2 surfacePosition;\n*/\n//#define BASE_ANGLE 0.\n//#define ANGLE_DELTA 0.02\n//#define XOFF .7\n\n#define SPIN 0.5//KParameter 0.>>10.\n#define SPIN2 .02//KParameter 0.02>>10.\n\n\n//#ifdef GL_ES\n//precision highp float;\n//precision mediump float;\n//#endif\n\n//uniform float time;\n//varying vec2 surfacePosition;\n  \n#define ptpi 1385.4557313670110891409199368797 //powten(pi)\n#define pipi  36.462159607207911770990826022692 //pi pied, pi^pi\n#define picu  31.006276680299820175476315067101 //pi cubed, pi^3\n#define pepi  23.140692632779269005729086367949 //powe(pi);\n#define chpi  11.59195327552152062775175205256  //cosh(pi)\n#define shpi  11.548739357257748377977334315388 //sinh(pi)\n#define pisq  9.8696044010893586188344909998762 //pi squared, pi^2\n#define twpi  6.283185307179586476925286766559  //two pi, 2*pi\n#define pi    3.1415926535897932384626433832795 //pi\n#define e     2.7182818284590452353602874713526 //eulers number\n#define sqpi  1.7724538509055160272981674833411 //square root of pi\n#define phi   1.6180339887498948482045868343656 //golden ratio\n#define hfpi  1.5707963267948966192313216916398 //half pi, 1/pi\n#define cupi  1.4645918875615232630201425272638 //cube root of pi\n#define prpi  1.4396194958475906883364908049738 //pi root of pi\n#define lnpi  1.1447298858494001741434273513531 //logn(pi);\n#define trpi  1.0471975511965977461542144610932 //one third of pi, pi/3\n#define thpi  0.99627207622074994426469058001254//tanh(pi)\n#define lgpi  0.4971498726941338543512682882909 //log(pi)      \n#define rcpi  0.31830988618379067153776752674503// reciprocal of pi  , 1/pi \n#define rcpipi  0.0274256931232981061195562708591 // reciprocal of pipi  , 1/pipi\n\nfloat tt = ((time*e));\nfloat t = (rcpi*(pi+tt/pisq))+pepi;\nfloat k = (lgpi*(pi+tt/chpi))+chpi;\n\nvec3 qAxis = normalize(vec3(sin(t*(prpi)), cos(k*(cupi)), cos(k*(hfpi)) ));\nvec3 wAxis = normalize(vec3(cos(k*(-trpi)/pi), sin(t*(rcpi)/pi), sin(k*(lgpi)/pi) ));\nvec3 sAxis = normalize(vec3(cos(t*(trpi)), sin(t*(-rcpi)), sin(k*(lgpi)) ));\nfloat axe = pow(qAxis.x+qAxis.y+qAxis.z+wAxis.x+wAxis.y+wAxis.z+sAxis.x+sAxis.y+sAxis.z,2.0);\n\nvec3 camPos = (vec3(0.0, 0.0, -1.0));\nvec3 camUp  = (vec3(0.0,1.0,0.0));\nfloat focus = pi;\nvec3 camTarget = vec3(0.1)*sAxis;\n\nvec3 rotate(vec3 vec, vec3 axis, float ang)\n{\n    return vec * cos(ang) + cross(axis, vec) * sin(ang) + axis * dot(axis, vec) * (1.0 - cos(ang));\n}\n\n\n\nvec3 pin(vec3 v)\n{\n    vec3 q = vec3(0.0);\n   \n    q.x = sin(v.x)*0.5+0.5;\n    q.y = sin(v.y+0.66666667*pi)*0.5+0.5;\n    q.z = sin(v.z+1.33333333*pi)*0.5+0.5;\n   \n    return normalize(q);\n}\n\nvec3 spin(vec3 v)\n{\n    for(int i = 1; i <4; i++)\n    {\n        v=pin((v.yzx*twpi)*(float(i)));\n    }\n    return v.zxy;\n}\n\n\nfloat len( vec3 v )\n{\n\tv=mod(v,vec3(0.5))-0.25;\n\treturn (max(0.0,length(v)-0.1)); \n}\n\nvec3 nrm(vec3 p) {\n\tvec2 q = vec2(0.0, 0.1);\n\treturn normalize(vec3( len(p + q.yxx) - len(p - q.yxx),\n\t\t     len(p + q.xyx) - len(p - q.xyx),\n\t\t     len(p + q.xxy) - len(p - q.xxy) ));\n}\n\n\nvoid main( void ) {\n\n\n  //Step 2 >> replace  gl_FragCoord\n  float finalDesiredPointSize = 3.;\n  float maxFinalSquareSideSize = floor(sqrt(vertexCount));\n  float finalMaxVertexCount = maxFinalSquareSideSize*maxFinalSquareSideSize;\n  \n  float maxVerticesPerLine = floor(maxFinalSquareSideSize  *resolution.x/resolution.y);\n  \n  //x = number of elements in a line as x value for local resolution\n  //y = number of possible lines with the given vertexCount\n  vec2 vertexResolution = vec2(maxVerticesPerLine, floor(finalMaxVertexCount/maxVerticesPerLine));\n  \n  //we can now calculate the final number of elements\n  float finalVertexCount = vertexResolution.x*vertexResolution.y;\n  \n  //and adjust finalVertexId\n  float finalVertexId = mod(vertexId,finalVertexCount);\n  \n  //Calculate the position of the elements based on their finalVertexId\n  float x = mod(finalVertexId, vertexResolution.x);\n  float y = floor(finalVertexId / vertexResolution.x);\n  \n  vec2 simFragCoord = vec2(x,y);//simfragCoord will replace the gl_FragCoord of fragment shader\n  \n  \n  //Step 3 >> calculate vertice positions\n  //relative coordinate of the vertex (cordinates in 0..1 referential)\n  float u = (x /vertexResolution.x);\n  float v = (y /vertexResolution.y);\n  \n  //set vertices disposition\n  float sizeFactor = finalDesiredPointSize*vertexResolution.x/resolution.x;\n  \n  float ux = sizeFactor*(u - 0.5);\n  float vy = sizeFactor*(v - 0.5);\n  \n  gl_PointSize = finalDesiredPointSize;\n  gl_Position = vec4(ux, vy, 0., 1.);\n  \n  //create the surfacePosition\n  vec2 surfacePosition = vec2(ux,vy);\n\n   /****************************************************************/\n  //Step 4 >> paste the old fragment code with following changes:\n  //replace gl_FragCoord by simFragCoord \n  //replace gl_FragColor by v_color\n  //replace iResolution by resolution\n  //replace resolution by vertexResolution\n  \nvec2 pos = (surfacePosition)*twpi;//(sin(t*pi)+2.0);\n    float ang = (sin(t*lnpi)*pi)+(distance(sAxis,wAxis)+distance(qAxis,sAxis)+distance(wAxis,qAxis));\n    camPos = e*(camPos * cos(ang) + cross(qAxis, camPos) * sin(ang) + qAxis * dot(qAxis, camPos) * (1.0 - cos(ang)));\n   \n    vec3 camDir = normalize(camTarget-camPos);\n    camUp = rotate(camUp, camDir, sin(t*prpi)*pi);\n    vec3 camSide = cross(camDir, camUp);\n    vec3 sideNorm=normalize(cross(camUp, camDir));\n    vec3 upNorm=cross(camDir, sideNorm);\n    vec3 worldFacing=(camPos + camDir);\n    vec3 rayDir = -normalize((worldFacing+sideNorm*pos.x + upNorm*pos.y - camDir*((focus))));\n   \n    float show=0.0;\n   \n    float t = .1;\n    float temp = 0.;\n    for(int i = 0 ; i < 40; i++) {\n\ttemp = len((camPos + rayDir * (t)));\n\t    if(temp < 0.001) {show = 1.0;break;}\n\t    if(t>pisq){break;} \n        t += temp;\n    }\n    vec3 clr = rotate(mod((camPos + rayDir * (t)),vec3(SPIN))-0.25,rotate(sAxis,wAxis,ang*pisq),ang*pi+t);\n    clr = (show*(spin(clr))/(t))*(dot(rayDir,nrm(mod((camPos + rayDir * (t)),vec3(10.5))-0.25)));\n    v_color = vec4(clr, 1.0);\n\n  \n  /****************************************************************/\n  \n}"
  },
  "screenshotURL": "data/images/images-pop2mecp2pp2uz5e4-thumbnail.jpg",
  "hasSound": true,
  "views": {
    "$numberInt": "6"
  },
  "likes": {
    "$numberInt": "0"
  },
  "revisionId": "t52zAedpabu7ff6T6"
}