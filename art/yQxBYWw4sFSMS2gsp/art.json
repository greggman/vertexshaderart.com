{
  "_id": "yQxBYWw4sFSMS2gsp",
  "owner": {
    "_id": "Bs4vwFBoeN6Lx3is5",
    "createdAt": {
      "$date": {
        "$numberLong": "1528672219472"
      }
    },
    "profile": {
      "name": "Justin Shrake",
      "avatarUrl": "https://avatars.githubusercontent.com/jshrake?s=200",
      "info": "Contact me @ https://twitter.com/j2rgb"
    },
    "username": "jshrake"
  },
  "createdAt": {
    "$date": {
      "$numberLong": "1636899862273"
    }
  },
  "modifiedAt": {
    "$date": {
      "$numberLong": "1636907884304"
    }
  },
  "origId": null,
  "name": "hexagon tile strings 3D",
  "notes": "",
  "rank": {
    "$numberDouble": "10.149794664864398"
  },
  "private": false,
  "unlisted": false,
  "username": "jshrake",
  "avatarUrl": "https://avatars.githubusercontent.com/jshrake?s=200",
  "settings": {
    "num": 100000,
    "mode": "POINTS",
    "sound": "",
    "lineSize": "NATIVE",
    "backgroundColor": [
      0,
      0,
      0,
      1
    ],
    "shader": "// Hexagon Tile Strings by Justin Shrake (https://twitter.com/j2rgb)\n// Inspired by https://twitter.com/etiennejcb/status/974037218330382336?s=20\n// CC BY-NC 4.0 https://creativecommons.org/licenses/by-nc/4.0/\n\n// Submission for https://twitter.com/sableRaph #WCCChallenge\n// Topic: non-rectangular tiles\n// https://www.twitch.tv/sableraph\n\n\n#ifndef TAU\n#define TAU 6.28318530718\n#endif\n#ifndef PI\n#define PI 3.14159265359\n#endif\n\n\n// Raskolnikov (https://math.stackexchange.com/users/3567/raskolnikov), Is there\n// an equation to describe regular polygons?, URL (version: 2016-06-18):\n// https://math.stackexchange.com/q/41954 https://math.stackexchange.com/a/41954\n// Licensed under CC BY-SA 3.0\nfloat mmod(float x, float m) { return mod(mod(x, m) + m, m); }\nvec2 parametric_ngon(float n, float theta) {\n  theta = mod(TAU * theta, TAU);\n  float r = cos(PI / n) / cos(mmod(theta, 2.0 * PI / n) - PI / n);\n  float x = r * cos(theta);\n  float y = r * sin(theta);\n  return vec2(x, y);\n}\n\nvec4 grid2(float id, float w, float h) {\n  float ux = w == 1.0 ? 0.0 : mod(id, w);\n  float uy = h == 1.0 ? 0.0 : mod(floor(id / w), h);\n  float x = w == 1.0 ? 0.0 : 2.0 * ux / (w - 1.0) - 1.0;\n  float y = h == 1.0 ? 0.0 : 2.0 * uy / (h - 1.0) - 1.0;\n  return vec4(x, y, ux, uy);\n}\n\nmat2 rot2(float t) {\n  float ct = cos(t);\n  float st = sin(t);\n  return mat2(ct, -st, st, ct);\n}\n\nmat4 frustum(float left, float right, float bottom, float top, float near,\n             float far) {\n  float x = 2.0 * near / (right - left);\n  float y = 2.0 * near / (top - bottom);\n  float A = (right + left) / (right - left);\n  float B = (top + bottom) / (top - bottom);\n  float C = -(far + near) / (far - near);\n  float D = -2.0 * far * near / (far - near);\n  // clang-format off\n    return mat4(\n    x, 0, 0, 0,\n    0, y, 0, 0,\n    A, B, C, -1,\n    0, 0, D, 0\n    );\n  // clang-format on\n}\n\nmat4 perspective(float hfov_deg, float aspect, float near, float far) {\n  float hfov_rad = radians(hfov_deg);\n  float vfov_rad = 2.0 * atan(tan(hfov_rad * 0.5) / aspect);\n  // Tangent of half-FOV\n  float tangent = tan(0.5 * vfov_rad);\n  // Half the height of the near plane\n  float height = near * tangent;\n  // Half the width of the near plane\n  float width = height * aspect;\n  return frustum(-width, width, -height, height, near, far);\n}\n\n\nfloat quadraticInOut(float t) {\n  float p = 2.0 * t * t;\n  return t < 0.5 ? p : -p + (4.0 * t) - 1.0;\n}\n\n//\n// GLSL textureless classic 2D noise \"cnoise\",\n// with an RSL-style periodic variant \"pnoise\".\n// Author:  Stefan Gustavson (stefan.gustavson@liu.se)\n// Version: 2011-08-22\n//\n// Many thanks to Ian McEwan of Ashima Arts for the\n// ideas for permutation and gradient selection.\n//\n// Copyright (c) 2011 Stefan Gustavson. All rights reserved.\n// Distributed under the MIT license. See LICENSE file.\n// https://github.com/stegu/webgl-noise\n//\n\nvec4 mod289(vec4 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\n\nvec4 permute(vec4 x) { return mod289(((x * 34.0) + 10.0) * x); }\n\nvec4 taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }\n\nvec2 fade(vec2 t) { return t * t * t * (t * (t * 6.0 - 15.0) + 10.0); }\n\n// Classic Perlin noise\nfloat perlin(vec2 P) {\n  vec4 Pi = floor(P.xyxy) + vec4(0.0, 0.0, 1.0, 1.0);\n  vec4 Pf = fract(P.xyxy) - vec4(0.0, 0.0, 1.0, 1.0);\n  Pi = mod289(Pi); // To avoid truncation effects in permutation\n  vec4 ix = Pi.xzxz;\n  vec4 iy = Pi.yyww;\n  vec4 fx = Pf.xzxz;\n  vec4 fy = Pf.yyww;\n\n  vec4 i = permute(permute(ix) + iy);\n\n  vec4 gx = fract(i * (1.0 / 41.0)) * 2.0 - 1.0;\n  vec4 gy = abs(gx) - 0.5;\n  vec4 tx = floor(gx + 0.5);\n  gx = gx - tx;\n\n  vec2 g00 = vec2(gx.x, gy.x);\n  vec2 g10 = vec2(gx.y, gy.y);\n  vec2 g01 = vec2(gx.z, gy.z);\n  vec2 g11 = vec2(gx.w, gy.w);\n\n  vec4 norm = taylorInvSqrt(\n      vec4(dot(g00, g00), dot(g01, g01), dot(g10, g10), dot(g11, g11)));\n  g00 *= norm.x;\n  g01 *= norm.y;\n  g10 *= norm.z;\n  g11 *= norm.w;\n\n  float n00 = dot(g00, vec2(fx.x, fy.x));\n  float n10 = dot(g10, vec2(fx.y, fy.y));\n  float n01 = dot(g01, vec2(fx.z, fy.z));\n  float n11 = dot(g11, vec2(fx.w, fy.w));\n\n  vec2 fade_xy = fade(Pf.xy);\n  vec2 n_x = mix(vec2(n00, n01), vec2(n10, n11), fade_xy.x);\n  float n_xy = mix(n_x.x, n_x.y, fade_xy.y);\n  return 2.3 * n_xy;\n}\n\n// Classic Perlin noise, periodic variant\nfloat pnoise(vec2 P, vec2 rep) {\n  vec4 Pi = floor(P.xyxy) + vec4(0.0, 0.0, 1.0, 1.0);\n  vec4 Pf = fract(P.xyxy) - vec4(0.0, 0.0, 1.0, 1.0);\n  Pi = mod(Pi, rep.xyxy); // To create noise with explicit period\n  Pi = mod289(Pi);        // To avoid truncation effects in permutation\n  vec4 ix = Pi.xzxz;\n  vec4 iy = Pi.yyww;\n  vec4 fx = Pf.xzxz;\n  vec4 fy = Pf.yyww;\n\n  vec4 i = permute(permute(ix) + iy);\n\n  vec4 gx = fract(i * (1.0 / 41.0)) * 2.0 - 1.0;\n  vec4 gy = abs(gx) - 0.5;\n  vec4 tx = floor(gx + 0.5);\n  gx = gx - tx;\n\n  vec2 g00 = vec2(gx.x, gy.x);\n  vec2 g10 = vec2(gx.y, gy.y);\n  vec2 g01 = vec2(gx.z, gy.z);\n  vec2 g11 = vec2(gx.w, gy.w);\n\n  vec4 norm = taylorInvSqrt(\n      vec4(dot(g00, g00), dot(g01, g01), dot(g10, g10), dot(g11, g11)));\n  g00 *= norm.x;\n  g01 *= norm.y;\n  g10 *= norm.z;\n  g11 *= norm.w;\n\n  float n00 = dot(g00, vec2(fx.x, fy.x));\n  float n10 = dot(g10, vec2(fx.y, fy.y));\n  float n01 = dot(g01, vec2(fx.z, fy.z));\n  float n11 = dot(g11, vec2(fx.w, fy.w));\n\n  vec2 fade_xy = fade(Pf.xy);\n  vec2 n_x = mix(vec2(n00, n01), vec2(n10, n11), fade_xy.x);\n  float n_xy = mix(n_x.x, n_x.y, fade_xy.y);\n  return 2.3 * n_xy;\n}\n\n\nmat4 rot3(vec3 axis, float angle) {\n  axis = normalize(axis);\n  float s = sin(angle);\n  float c = cos(angle);\n  float oc = 1.0 - c;\n\n  return mat4(\n      oc * axis.x * axis.x + c, oc * axis.x * axis.y - axis.z * s,\n      oc * axis.z * axis.x + axis.y * s, 0.0, oc * axis.x * axis.y + axis.z * s,\n      oc * axis.y * axis.y + c, oc * axis.y * axis.z - axis.x * s, 0.0,\n      oc * axis.z * axis.x - axis.y * s, oc * axis.y * axis.z + axis.x * s,\n      oc * axis.z * axis.z + c, 0.0, 0.0, 0.0, 0.0, 1.0);\n}\n\n\nvoid main() {\n  // Loop timings\n  float loop_len = 4.0;\n  float time_off = 0.0;\n  float loop_pct = mod(time + time_off, loop_len) / (loop_len);\n  // The size of the hexagon tile grid\n  float gridw = 20.;\n  float gridh = 20.;\n  // The number of particles per hexagon\n  float particles_per_tile = 250.0;\n  // The particle index\n  float i = vertexId;\n  // The particle perctange\n  float pct = i / (vertexCount - 1.0);\n\n  // The hexagon index\n  float tile_i = floor(i / particles_per_tile);\n  // The total number of hexagons\n  float tile_count = gridw * gridh;\n\n  // The particle index wrt the hexagon\n  float tile_pi = mod(i, particles_per_tile);\n  // The particle percentage wrt the hexagon\n  float tile_ppct = tile_pi / particles_per_tile;\n\n  \n  float row = floor(tile_i/gridw);\n  float col = mod(tile_i, gridw);\n  float eo = mod(row, 2.0);\n  \n  float ar = resolution.y < resolution.x ? resolution.x/resolution.y : resolution.y/resolution.x;\n\n\n  // Hexagon tile size\n  float size = 1.0/(gridw - 1.0);\n  // padding between hexagons, 1.0 for no padding\n  float padding = 1.2;\n  // hexagon math courtesy of https://www.redblobgames.com/grids/hexagons/\n  vec2 grid_scale = padding*vec2(1.0*sqrt(3.0)*size, 1.5*ar*size);\n  vec2 tile_scale = vec2(size, size*ar);\n  // The center of the hexagon\n  vec2 tile_center = grid_scale*(grid2(tile_i, gridw, gridh).zw - 0.5*vec2(gridw, gridh));\n  tile_center.y += 2.5;\n  // Calculate the position of each particle in the tile\n  float ngon = 6.0;\n  float swirl = 0.5;\n  // The animation interpolates a point in the hexagon to another point in the hexagon\n  vec2 tile_a = parametric_ngon(ngon, tile_ppct);\n  float pn = 0.5*perlin(vec2(3.3)*tile_center) + 0.5;\n  float anim_delay = mix(0.0, 0.7, pn) + mix(0.0, 0.1, tile_ppct);\n  float anim_len = 0.2;\n  float m = smoothstep(0.0 + anim_delay, 0.0 + anim_delay + anim_len, loop_pct);\n  vec3 tile = vec3(tile_a, 0.0);\n  tile.xy = rot2(0.25*TAU)*tile.xy;\n  tile.xy *= tile_scale;\n  tile.x += 1.0 * eo * tile_scale.x;\n  tile.y += 1.0*size;\n  float amt = 1.0;\n  float start_z = -0.6;\n  tile.z = mix(start_z, start_z - amt, quadraticInOut(m));\n  tile.z += mix(0.0, amt, (loop_pct));\n  \n  // Outputs\n  vec4 pos;\n  pos.xyz = vec3(tile_center, 0.0) + tile;\n  pos.w = 1.0;\n  pos = rot3(vec3(1.0, 0.0, 0.0), 0.75*0.25*TAU)*rot3(vec3(0.0, 0.0, 1.0), 0.0*TAU)*pos;\n  mat4 p = perspective(60.0, 1.0, 0.01, 10.0);\n  gl_Position = p * pos;\n  gl_PointSize = 3.0;\n  v_color = vec4(1.0);\n}"
  },
  "screenshotURL": "data/images/images-go2w1b1vibry40xk3-thumbnail.jpg",
  "hasSound": "",
  "views": {
    "$numberInt": "1737"
  },
  "likes": {
    "$numberInt": "7"
  },
  "revisionId": "dgDTb6rAxCGyJrihz"
}