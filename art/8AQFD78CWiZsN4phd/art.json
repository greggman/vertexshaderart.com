{
  "_id": "8AQFD78CWiZsN4phd",
  "owner": {
    "_id": "cZNAKnfHAY6mZAn2h",
    "createdAt": {
      "$date": "1598366337757"
    },
    "username": "morimea",
    "profile": {
      "avatarUrl": "https://secure.gravatar.com/avatar/8ff4b4cacdf52d8d31a020cd244c5269?default=retro&size=200",
      "info": "https://www.shadertoy.com/user/morimea"
    }
  },
  "createdAt": {
    "$date": "1599349722701"
  },
  "modifiedAt": {
    "$date": "1599381002169"
  },
  "origId": null,
  "name": "Functions rotation animation",
  "notes": "logic based on my own old demo https://youtu.be/405yudjksDA",
  "rank": "1.4223532267597618",
  "private": false,
  "unlisted": false,
  "username": "morimea",
  "avatarUrl": "https://secure.gravatar.com/avatar/8ff4b4cacdf52d8d31a020cd244c5269?default=retro&size=200",
  "settings": {
    "num": 99360,
    "mode": "LINE_LOOP",
    "sound": "",
    "lineSize": "NATIVE",
    "backgroundColor": [
      0.050980392156862744,
      0.050980392156862744,
      0.050980392156862744,
      1
    ],
    "shader": "/*\n\n Created by Danil (2020+) https://github.com/danilw\n\n Mouse rotation - Left mouse key and move mouse to rotate.\n\n\n This is port to vertex shader my old code, old code can be found here https://youtu.be/405yudjksDA\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n*/\n\n// num lines\n// NUM_SEGMENTS 100. 100*2*360 = 72000\n// NUM_SEGMENTS 138. 138*2*360 = 99360\n#define NUM_SEGMENTS 138.\n\n// anim speed\n#define speed 0.95\n\n\n// debug\n\n//#define debug\nconst int debug_fid = 0;\n\n\nvec3 findaxis();\nvec3 get_color(vec3 rotate);\nvec4 get_func(int fid, float x);\nvec3 my_normalize(vec3 v);\nmat4 rotationAxisAngle(vec3 v, float angle);\nvec3 encodeSRGB(vec3 linearRGB);\n\n#ifdef debug\n#define time (((mouse.x + 1.) * 27.05 * 0.5) / speed)\n#endif\n\nvoid main() {\n    const float pi = 3.1415926;\n    vec4 iMouse = texture2DLod(touch, vec2(0., 0.), 0.);\n    int fid = int(mod(speed * time / (27.05 + .05), 14.));\n    #ifdef debug\n    fid = debug_fid;\n    #endif\n    float vert_z = mod(vertexId, NUM_SEGMENTS) / (NUM_SEGMENTS);\n    float idx = floor((vertexId / 2.) / NUM_SEGMENTS);\n    float slength = 1. / (NUM_SEGMENTS);\n    vec2 aspect = vec2(1, resolution.x / resolution.y);\n    float vert_s = floor(vertexId / 2.) * slength;\n    float ecolf = (((int(mod(vertexId, NUM_SEGMENTS)) == 0) || (int(mod(vertexId, NUM_SEGMENTS)) == int(NUM_SEGMENTS - 1.))) ? 0. : 1.);\n\n    vec4 val = get_func(fid, (vert_z));\n    vec3 rotate = findaxis();\n    vec4 col = vec4(get_color(rotate), 1.);\n    col.rgb = sqrt(encodeSRGB(col.rgb));\n    col.rgb += 0.05 * (dot(col.rgb, vec3(1.)));\n    col.rgb *= val.z * val.w * ecolf;\n    rotate = my_normalize(rotate);\n\n    vec2 xy = val.yx * vec2(0.06);\n\n    gl_Position = vec4(xy + 0.000001, 0.000001, 1.);\n    gl_Position = gl_Position * rotationAxisAngle(rotate.xyz, ((2. * pi) / 360.) * idx);\n    if (iMouse.z > 0.15) gl_Position = gl_Position * rotationAxisAngle(vec3(0., 1., 0.), iMouse.x * pi / 1.) * rotationAxisAngle(vec3(1., 0., 0.), iMouse.y * pi / 1.);\n    gl_Position.xy *= aspect;\n    gl_Position.z = (gl_Position.z) * 0.1 + abs(gl_Position.x) * 1. / aspect.y + vert_z * 0.1 + 10.*(1. - val.z) + (1. - ecolf);\n    gl_Position.w = 1.;\n    gl_PointSize = 3.;\n\n    v_color = col;\n    v_color.a = 0.;\n}\n\nbool isNan(float val) {\n    return (val <= 0.0 || 0.0 <= val) ? false : true;\n}\nbool isInf(float val) {\n    return (val + 1. != val) ? false : true;\n}\n\nfloat get_xt(float xpi, float px) {\n    return xpi * px;\n}\n\nfloat get_x(float xpi, float px) {\n    const float pi = 3.1415926;\n    return -pi * xpi + xpi * 2. * pi * px;\n}\n\n//return [x,y]-positions [z,w] color fix\nvec4 get_func(int fid, float x) {\n    const float pi = 3.1415926;\n    float ret = 0.;\n    float rety = ((x - 0.5) * 4.) * (1. / 0.2);\n    float cpw = 0.15;\n    float t = 0.;\n    const float maxh = 15.;\n    if (fid == 0) {t = get_x(1., x);ret = tan(t);} else\n    if (fid == 1) {t = get_x(1., x);ret = t * t * t;} else\n    if (fid == 2) {t = get_x(2., x);ret = (6. * sin(t)) / 2.;} else\n    if (fid == 3) {t = get_x(1., x);ret = 1. / tan(t);} else\n    if (fid == 4) {t = get_x(2., x);ret = abs(t) * sin(t);} else\n    if (fid == 5) {t = get_x(2., x);ret = t / (t * t);} else\n    if (fid == 6) {t = get_x(2., x);ret = -t * sin(t);} else\n    if (fid == 7) {cpw = 0.05;t = get_xt(1., rety);rety = 2.5 * (2. * cos(t) + cos(2. * t));ret = 2.5 * (2. * sin(t) - sin(2. * t));} else\n    if (fid == 8) {cpw = 0.05;t = get_xt(1., rety);rety = 1.5 * (4. * (cos(t) + cos(5. * t) / 5.));ret = 1.5 * (4. * (sin(t) - sin(5. * t) / 5.));} else\n    if (fid == 9) {cpw = 0.075;t = get_xt(1., rety);rety = 1.5 * (3. * (1. + cos(t)) * cos(t));ret = 1.5 * (3. * (1. + cos(t)) * sin(t));} else\n    if (fid == 10) {cpw = 0.05;t = get_xt(1., rety);rety = 2.5 * (3. * sin(t + pi / 2.));ret = 2.5 * (3. * sin(2. * t));} else\n    if (fid == 11) {cpw = 0.075;t = get_xt(1., rety);rety = 2.5 * ((16. * pow(sin(t), 3.)) / 4.);ret = 2.5 * ((13. * cos(t) - 5. * cos(2. * t) - 2. * cos(3. * t) - cos(4. * t)) / 4.);} else\n    if (fid == 12) {t = get_x(1., x);rety = 1.5 * (5. * sin(t));ret = 1.5 * (5. * cos(t));} else\n    if (fid == 13) {cpw = 0.1;t = get_x(1., x);rety = 2.5 * (3. * cos(t) * (1. - 2. * pow(sin(t), 2.)));ret = 2.5 * (3. * sin(t) * (1. - 2. * pow(cos(t), 2.)));} else \n    {t = get_x(1., x);ret = sin(t * 3.);}\n    float cfix = 1.;\n    if (isInf(ret)) {ret = maxh;cfix = 0.;} else {\n        if (isNan(ret)) {ret = 0.;cfix = 0.;} else {\n            if (abs(ret) > maxh) {ret = maxh * sign(ret);cfix = 0.;}\n        }\n    }\n    if (isInf(rety)) {rety = maxh;cfix = 0.;} else {\n        if (isNan(rety)) {rety = 0.001;cfix = 0.;} else {\n            if (abs(rety) > maxh) {rety = maxh * sign(rety);cfix = 0.;} else {\n                if (rety == 0.) rety = 0.001;\n            }\n        }\n    }\n\n    return vec4(ret, rety, cfix, cpw);\n}\n\n//return axis\nvec3 findaxis() {\n    vec3 rotate = vec3(0.);\n    const vec4 static_timers1 = vec4(2.33333, 4.7, 7.05, 9.41666);\n    const vec4 static_timers2 = vec4(11.76666, 14.11666, 16.4666, 18.8166);\n    const vec4 static_timers3 = vec4(21.16666, 23.51666, 25.866, 27.05);\n\n    float time_l = mod(time * speed, static_timers3[3] + .05);\n\n    rotate.x = smoothstep(static_timers1[0], static_timers1[1], time_l) *\n        (1. - smoothstep(static_timers1[1], static_timers1[2], time_l));\n    rotate.x += -smoothstep(static_timers1[2], static_timers1[3], time_l) *\n        (1. - smoothstep(static_timers2[1], static_timers2[2], time_l));\n    rotate.x += smoothstep(static_timers2[2], static_timers2[3], time_l) *\n        (1. - smoothstep(static_timers3[1], static_timers3[2], time_l));\n\n    rotate.y = smoothstep(0., static_timers1[0], time_l) *\n        (1. - smoothstep(static_timers1[0], static_timers1[1], time_l));\n    rotate.y += -smoothstep(static_timers1[2], static_timers1[3], time_l) *\n        (1. - smoothstep(static_timers1[3], static_timers2[0], time_l));\n    rotate.y += smoothstep(static_timers2[0], static_timers2[1], time_l) *\n        (1. - smoothstep(static_timers2[1], static_timers2[2], time_l));\n    rotate.y += -smoothstep(static_timers2[2], static_timers2[3], time_l) *\n        (1. - smoothstep(static_timers2[3], static_timers3[0], time_l));\n    rotate.y += smoothstep(static_timers3[0], static_timers3[1], time_l) *\n        (1. - smoothstep(static_timers3[1], static_timers3[2], time_l));\n\n    rotate.z = smoothstep(static_timers1[1], static_timers1[2], time_l) *\n        (1. - smoothstep(static_timers1[2], static_timers1[3], time_l));\n    rotate.z += -smoothstep(static_timers1[3], static_timers2[0], time_l) *\n        (1. - smoothstep(static_timers2[0], static_timers2[1], time_l));\n    rotate.z += smoothstep(static_timers2[1], static_timers2[2], time_l) *\n        (1. - smoothstep(static_timers2[2], static_timers2[3], time_l));\n    rotate.z += -smoothstep(static_timers2[3], static_timers3[0], time_l) *\n        (1. - smoothstep(static_timers3[0], static_timers3[1], time_l));\n    rotate.z += smoothstep(static_timers3[1], static_timers3[2], time_l) *\n        (1. - smoothstep(static_timers3[2], static_timers3[3], time_l));\n\n    return rotate;\n}\n\nvec3 get_color(vec3 rotate) {\n    return abs(rotate * 7.) / 14.0;\n}\n\nvec3 my_normalize(vec3 v) {\n    float len = length(v);\n    if (len == 0.0) return vec3(0., 1., 0.);\n    return v / len;\n}\n\nmat4 rotationAxisAngle(vec3 v, float angle) {\n    float s = sin(angle);\n    float c = cos(angle);\n    float ic = 1.0 - c;\n\n    return mat4(vec4(v.x * v.x * ic + c, v.y * v.x * ic - s * v.z, v.z * v.x * ic + s * v.y, 0.0),\n        vec4(v.x * v.y * ic + s * v.z, v.y * v.y * ic + c, v.z * v.y * ic - s * v.x, 0.0),\n        vec4(v.x * v.z * ic - s * v.y, v.y * v.z * ic + s * v.x, v.z * v.z * ic + c, 0.0),\n        vec4(0.0, 0.0, 0.0, 1.0));\n}\n\nvec3 encodeSRGB(vec3 linearRGB) {\n    vec3 a = 12.92 * linearRGB;\n    vec3 b = 1.055 * pow(linearRGB, vec3(1.0 / 2.4)) - 0.055;\n    vec3 c = step(vec3(0.0031308), linearRGB);\n    return mix(a, b, c);\n}\n"
  },
  "screenshotURL": "data/images/images-icfdnj1z1gcwact4x-thumbnail.jpg",
  "hasSound": "",
  "views": "610",
  "likes": "1",
  "revisionId": "9B62K5e3B6dAswERa"
}