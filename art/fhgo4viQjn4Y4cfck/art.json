{
  "_id": "fhgo4viQjn4Y4cfck",
  "owner": {
    "_id": "yXJ6WCMQCSanfJTWk",
    "createdAt": {
      "$date": {
        "$numberLong": "1447692554526"
      }
    },
    "username": "dzozef",
    "profile": {
      "info": "tinkerer",
      "avatarUrl": "https://secure.gravatar.com/avatar/d6b044e92a377cd617762af9a488719d?default=retro&size=200"
    }
  },
  "createdAt": {
    "$date": {
      "$numberLong": "1448628689320"
    }
  },
  "modifiedAt": {
    "$date": {
      "$numberLong": "1448638441284"
    }
  },
  "origId": null,
  "name": "cubes",
  "rank": {
    "$numberDouble": "1.128383156951127"
  },
  "private": true,
  "username": "dzozef",
  "settings": "{\"num\":100000,\"mode\":\"POINTS\",\"sound\":\"\",\"lineSize\":\"NATIVE\",\"backgroundColor\":[0,0,0,1],\"shader\":\"float SIDE = 16.; // how many cubes on one side\\nfloat CUBESIZE = 0.1; // one cube size\\nfloat NSCALE = 0.4;\\nfloat TSCALE = 1.2;\\n\\nvoid rotateX(inout vec3 p, float a) {\\n\\tfloat c,s;vec3 q=p;\\n\\tc = cos(a); s = sin(a);\\n\\tp.y = c * q.y - s * q.z;\\n\\tp.z = s * q.y + c * q.z;\\n}\\n\\nvec3 rotateY( vec3 p, float a )\\n{\\n    float sa = sin(a);\\n    float ca = cos(a);\\n    vec3 r;\\n    r.x = ca*p.x + sa*p.z;\\n    r.y = p.y;\\n    r.z = -sa*p.x + ca*p.z;\\n    return r;\\n}\\n\\n// noise from iq (https://www.shadertoy.com/view/4sfGzS)\\nfloat hash( float n ) { return fract(sin(n)*753.5453123); }\\nfloat noise( in vec3 x )\\n{\\n    vec3 p = floor(x);\\n    vec3 f = fract(x);\\n    f = f*f*(3.0-2.0*f);\\n\\t\\n    float n = p.x + p.y*157.0 + 113.0*p.z;\\n    return mix(mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\\n                   mix( hash(n+157.0), hash(n+158.0),f.x),f.y),\\n               mix(mix( hash(n+113.0), hash(n+114.0),f.x),\\n                   mix( hash(n+270.0), hash(n+271.0),f.x),f.y),f.z);\\n}\\n\\nvec3 GetPoint( float vertexid )\\n{\\n\\tfloat cube = floor( vertexid / 24. ); // 24 vertexes per cube\\n\\tif (cube > SIDE*SIDE*SIDE-1.) return vec3(0.0);\\n\\t// get the grid location\\n\\tfloat y = floor( cube / (SIDE*SIDE) );\\n\\tfloat z = floor( mod( cube, SIDE*SIDE ) / SIDE );\\n\\tfloat x = mod( mod( cube, SIDE*SIDE ), SIDE );\\n\\t// first check if empty\\n\\tfloat n = noise( vec3( x, y, z ) * NSCALE + vec3( time, time/2., time /3. ) * TSCALE );\\n\\tif (n < 0.7) return vec3(0.);\\n  \\n\\tfloat vid = mod( vertexid, 24. );\\n\\tfloat sideid = floor( vid / 4. );\\n\\n  \\n\\treturn (vec3( x, y, z ) + vec3( -SIDE/2. ))* CUBESIZE;\\n}\\n\\nvoid main()\\n{\\n\\tvec3 p = GetPoint( vertexId );\\n\\tfloat fov = 1.1;\\n\\tp = rotateY( p, -mouse.x*1.2-0.2 );\\n\\trotateX( p, mouse.y*1.2-0.2 );\\n\\tfloat origz = p.z;\\n\\tp += vec3( 0.0, 0, SIDE/7. );\\n\\tgl_Position = vec4( p.xy*fov, 1.0/(p.z-0.0), p.z );   \\n\\tgl_PointSize = 3.0;\\n\\tv_color = vec4(1.0);\\n}\"}",
  "screenshotURL": "data/images/images-bgz3bzrkem6dna8qp-thumbnail.jpg",
  "hasSound": "",
  "views": {
    "$numberInt": "7"
  },
  "likes": {
    "$numberInt": "0"
  },
  "revisionId": "Jzzr56FRDnBWjmxRP",
  "avatarUrl": "https://secure.gravatar.com/avatar/d6b044e92a377cd617762af9a488719d?default=retro&size=200"
}