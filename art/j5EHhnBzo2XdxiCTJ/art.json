{
  "_id": "j5EHhnBzo2XdxiCTJ",
  "owner": {
    "_id": "Pexi77zfde4iNKmrT",
    "createdAt": {
      "$date": {
        "$numberLong": "1493741221077"
      }
    },
    "profile": {
      "name": "Kolargon Generative",
      "avatarUrl": "https://lh3.googleusercontent.com/-tiKYx1U71-Q/AAAAAAAAAAI/AAAAAAAAAGg/b-eEUsFpspc/photo.jpg"
    },
    "username": "kolargon"
  },
  "createdAt": {
    "$date": {
      "$numberLong": "1523010053602"
    }
  },
  "modifiedAt": {
    "$date": {
      "$numberLong": "1523010053602"
    }
  },
  "origId": "dPsnyuwF6HxdEJMAd",
  "name": "frag from shadertoy",
  "notes": "http://glslsandbox.com/e#46262.1",
  "rank": {
    "$numberDouble": "1.175158194821777"
  },
  "private": true,
  "unlisted": false,
  "username": "kolargon",
  "avatarUrl": "https://lh3.googleusercontent.com/-tiKYx1U71-Q/AAAAAAAAAAI/AAAAAAAAAGg/b-eEUsFpspc/photo.jpg",
  "settings": "{\"num\":10000,\"mode\":\"POINTS\",\"sound\":\"https://soundcloud.com/user-158087960/studiomix-douzirec-06-2007-flac\",\"lineSize\":\"NATIVE\",\"backgroundColor\":[0,0,0,1],\"shader\":\"\\n\\n\\n//Step 1 >> comment all precision, extension, uniforms and varying\\n\\n#define factor0 0.01//KParameter 0.01>>0.9\\n#define factor1 0.05//KParameter 0.0001>>0.1\\n#define timeFactor 1.//KParameter 1.>>40.\\n\\nvec2 rotate(in vec2 v, in float a) {\\n\\treturn vec2(cos(a)*v.x + sin(a)*v.y, -sin(a)*v.x + cos(a)*v.y);\\n}\\n\\nfloat torus(in vec3 p, in vec2 t)\\n{\\n\\tvec2 q = abs(vec2(max(abs(p.x), abs(p.z))-t.x, p.y));\\n\\treturn max(q.x, q.y)-t.y;\\n}\\n\\nfloat trap(in vec3 p)\\n{\\n\\t//return abs(max(abs(p.z)-0.1, abs(p.x)-0.1))-0.01;\\n\\t//return length(max(abs(p.xy) - 0.05, 0.0));\\n\\t//return length(max(abs(p) - 0.35, 0.0));\\n\\t//return abs(length(p.xz)-0.2)-0.01;\\n\\t//return min(length(p.xz), min(length(p.yz), length(p.xy))) - 0.05;\\n\\treturn abs(min(torus(vec3(p.x, mod(p.y,factor0)-0.2, p.z), vec2(0.1, factor1)), max(abs(p.z)-0.05, abs(p.x)-0.05)))-0.005;\\n\\treturn abs(min(torus(p, vec2(0.3, 0.05)), max(abs(p.z)-0.05, abs(p.x)-0.05)))-0.005;\\n}\\n\\nfloat map(in vec3 p)\\n{\\n    float time2 = time+60.0;\\n\\tfloat cutout = dot(abs(p.yz),vec2(0.5))-0.035;\\n\\t//float road = max(abs(p.y-0.025), abs(p.z)-0.035);\\n\\t\\n\\tvec3 z = abs(1.0-mod(p,2.0));\\n\\tz.yz = rotate(z.yz, time2*0.05);\\n\\n\\tfloat d = 999.0;\\n\\tfloat s = 1.0;\\n\\tfor (float i = 0.0; i < 3.0; i++) {\\n\\t\\tz.xz = rotate(z.xz, radians(i*10.0+time2));\\n\\t\\tz.zy = rotate(z.yz, radians((i+1.0)*20.0+time2*1.1234));\\n\\t\\tz = abs(1.0-mod(z+i/3.0,2.0));\\n\\t\\t\\n\\t\\tz = z*2.0 - 0.3;\\n\\t\\ts *= 0.5;\\n\\t\\td = min(d, trap(z) * s);\\n\\t}\\n\\treturn max(d, -cutout);\\n}\\n\\nvec3 hsv(in float h, in float s, in float v) {\\n\\treturn mix(vec3(1.0), clamp((abs(fract(h + vec3(3, 2, 1) / 3.0) * 6.0 - 3.0) - 1.0), 0.0 , 1.0), s) * v;\\n}\\n\\nvec3 intersect(in vec3 rayOrigin, in vec3 rayDir)\\n{\\n    float time2 = time+60.0;\\n\\tfloat total_dist = 0.0;\\n\\tvec3 p = rayOrigin;\\n\\tfloat d = 1.0;\\n\\tfloat iter = 0.0;\\n\\tfloat mind = 3.14159+sin(time2*0.0)*0.0; // Move road from side to side slowly\\n\\t\\n\\tfor (int i = 0; i < 20; i++)\\n\\t{\\t\\t\\n\\t\\tif (d < 0.001) continue;\\n\\t\\t\\n\\t\\td = map(p);\\n\\t\\t// This rotation causes the occasional distortion - like you would see from heat waves\\n\\t\\tp += d*vec3(rayDir.x, rotate(rayDir.yz, sin(mind)));\\n\\t\\tmind = min(mind, d);\\n\\t\\ttotal_dist += d;\\n\\t\\titer++;\\n\\t}\\n\\n\\tvec3 color = vec3(0.0);\\n\\tif (d < 0.001) {\\n\\t\\tfloat x = (iter/59.0);\\n\\t\\tfloat y = (d-0.01)/0.01/(59.0);\\n\\t\\tfloat z = (0.01-d)/0.01/59.0;\\n\\t\\t\\n\\n\\t\\t\\tfloat q = 1.0-x-y*2.+z;\\n\\t\\t\\tcolor = hsv(q*0.2+0.85, 1.0-q*0.2, q);\\n\\t} \\n\\t\\t//color = hsv(d, 1.0, 1.0)*mind*45.0; // Background\\n\\treturn color;\\n}\\n\\nvoid main( void ) {\\n\\n\\n  //Step 2 >> replace  gl_FragCoord\\n  float finalDesiredPointSize = 3.;\\n  float maxFinalSquareSideSize = floor(sqrt(vertexCount));\\n  float finalMaxVertexCount = maxFinalSquareSideSize*maxFinalSquareSideSize;\\n  \\n  float maxVerticesPerLine = floor(maxFinalSquareSideSize  *resolution.x/resolution.y);\\n  \\n  //x = number of elements in a line as x value for local resolution\\n  //y = number of possible lines with the given vertexCount\\n  vec2 vertexResolution = vec2(maxVerticesPerLine, floor(finalMaxVertexCount/maxVerticesPerLine));\\n  \\n  //we can now calculate the final number of elements\\n  float finalVertexCount = vertexResolution.x*vertexResolution.y;\\n  \\n  //and adjust finalVertexId\\n  float finalVertexId = mod(vertexId,finalVertexCount);\\n  \\n  //Calculate the position of the elements based on their finalVertexId\\n  float x = mod(finalVertexId, vertexResolution.x);\\n  float y = floor(finalVertexId / vertexResolution.x);\\n  \\n  vec2 simFragCoord = vec2(x,y);//simfragCoord will replace the gl_FragCoord of fragment shader\\n  \\n  \\n  //Step 3 >> calculate vertice positions\\n  //relative coordinate of the vertex (cordinates in 0..1 referential)\\n  float u_i = (x /vertexResolution.x);\\n  float v_i = (y /vertexResolution.y);\\n  \\n  //set vertices disposition\\n  float sizeFactor = finalDesiredPointSize*vertexResolution.x/resolution.x;\\n  \\n  float ux = sizeFactor*(u_i - 0.5);\\n  float vy = sizeFactor*(v_i - 0.5);\\n  \\n  gl_PointSize = finalDesiredPointSize;\\n  gl_Position = vec4(ux, vy, 0., 1.);\\n  \\n  //create the surfacePosition\\n  vec2 surfacePosition = vec2(ux,vy);\\n\\n   /****************************************************************/\\n  //Step 4 >> paste the old fragment code with following changes:\\n  //replace gl_FragCoord by simFragCoord \\n  //replace gl_FragColor by v_color\\n  //replace iResolution by resolution\\n  //replace resolution by vertexResolution\\n  \\n     float time2 = timeFactor*time+60.0;\\n\\tvec3 upDirection = vec3(0, -1, 0);\\n\\tvec3 cameraDir = vec3(1,0,0);\\n\\tvec3 cameraOrigin = vec3(time2*0.1, 0, 0);\\n\\t\\n\\tvec3 u = normalize(cross(upDirection, cameraOrigin));\\n\\tvec3 v = normalize(cross(cameraDir, u));\\n\\tvec2 screenPos = -1.0 + 2.0 * simFragCoord.xy / vertexResolution.xy;\\n\\tscreenPos.x *= vertexResolution.x / vertexResolution.y;\\n\\tvec3 rayDir = normalize(u * screenPos.x + v * screenPos.y + cameraDir*(1.0-length(screenPos)*0.5));\\n\\tvec3 col = vec3( intersect(cameraOrigin, rayDir) );\\n\\tv_color = vec4(col,1.0);\\n \\n  /****************************************************************/\\n  \\n}\\n\\n\\n\"}",
  "screenshotURL": "data/images/images-e0lszzik9jcyjeyeh-thumbnail.jpg",
  "hasSound": true,
  "views": {
    "$numberInt": "4"
  },
  "likes": {
    "$numberInt": "0"
  },
  "revisionId": "Afaq58ATD5M7keoL5"
}