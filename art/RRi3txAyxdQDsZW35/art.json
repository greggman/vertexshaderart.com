{
  "_id": "RRi3txAyxdQDsZW35",
  "owner": {
    "_id": "Bs4vwFBoeN6Lx3is5",
    "createdAt": {
      "$date": "1528672219472"
    },
    "profile": {
      "name": "Justin Shrake",
      "avatarUrl": "https://avatars.githubusercontent.com/jshrake?s=200",
      "info": "Contact me @ https://twitter.com/j2rgb"
    },
    "username": "jshrake"
  },
  "createdAt": {
    "$date": "1528672237466"
  },
  "modifiedAt": {
    "$date": "1535900731524"
  },
  "origId": null,
  "name": "tornado-quad-triangle-tower-thing",
  "notes": "quick experiment",
  "rank": "10.540444296277315",
  "private": false,
  "unlisted": false,
  "username": "jshrake",
  "avatarUrl": "https://avatars.githubusercontent.com/jshrake?s=200",
  "settings": {
    "num": 41536,
    "mode": "TRIANGLES",
    "sound": "",
    "lineSize": "NATIVE",
    "backgroundColor": [
      1,
      1,
      1,
      1
    ],
    "shader": "#define ACROSS 1000\n// from http://lolengine.net/blog/2013/07/27/rgb-to-hsv-in-glsl\nvec3 hsv2rgb(vec3 c) {\n    c = vec3(c.x, clamp(c.yz, 0.0, 1.0));\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\n#define HASHSCALE1 .1031\n#define HASHSCALE3 vec3(.1031, .1030, .0973)\n#define HASHSCALE4 vec4(.1031, .1030, .0973, .1099)\nfloat hash11(float p)\n{\n\tvec3 p3  = fract(vec3(p) * HASHSCALE1);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n//----------------------------------------------------------------------------------------\n//  1 out, 2 in...\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * HASHSCALE1);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n//----------------------------------------------------------------------------------------\n//  1 out, 3 in...\nfloat hash13(vec3 p3)\n{\n\tp3  = fract(p3 * HASHSCALE1);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n//----------------------------------------------------------------------------------------\n//  2 out, 1 in...\nvec2 hash21(float p)\n{\n\tvec3 p3 = fract(vec3(p) * HASHSCALE3);\n\tp3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\n\n//----------------------------------------------------------------------------------------\n///  2 out, 2 in...\nvec2 hash22(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * HASHSCALE3);\n    p3 += dot(p3, p3.yzx+19.19);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\n\n//----------------------------------------------------------------------------------------\n///  2 out, 3 in...\nvec2 hash23(vec3 p3)\n{\n\tp3 = fract(p3 * HASHSCALE3);\n    p3 += dot(p3, p3.yzx+19.19);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\n//----------------------------------------------------------------------------------------\n//  3 out, 1 in...\nvec3 hash31(float p)\n{\n   vec3 p3 = fract(vec3(p) * HASHSCALE3);\n   p3 += dot(p3, p3.yzx+19.19);\n   return fract((p3.xxy+p3.yzz)*p3.zyx); \n}\n\n\n//----------------------------------------------------------------------------------------\n///  3 out, 2 in...\nvec3 hash32(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * HASHSCALE3);\n    p3 += dot(p3, p3.yxz+19.19);\n    return fract((p3.xxy+p3.yzz)*p3.zyx);\n}\n\n//----------------------------------------------------------------------------------------\n///  3 out, 3 in...\nvec3 hash33(vec3 p3)\n{\n\tp3 = fract(p3 * HASHSCALE3);\n    p3 += dot(p3, p3.yxz+19.19);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n\n}\n\n//----------------------------------------------------------------------------------------\n// 4 out, 1 in...\nvec4 hash41(float p)\n{\n\tvec4 p4 = fract(vec4(p) * HASHSCALE4);\n    p4 += dot(p4, p4.wzxy+19.19);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n    \n}\n\n//----------------------------------------------------------------------------------------\n// 4 out, 2 in...\nvec4 hash42(vec2 p)\n{\n\tvec4 p4 = fract(vec4(p.xyxy) * HASHSCALE4);\n    p4 += dot(p4, p4.wzxy+19.19);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n\n}\n\n//----------------------------------------------------------------------------------------\n// 4 out, 3 in...\nvec4 hash43(vec3 p)\n{\n\tvec4 p4 = fract(vec4(p.xyzx)  * HASHSCALE4);\n    p4 += dot(p4, p4.wzxy+19.19);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n}\n\n//----------------------------------------------------------------------------------------\n// 4 out, 4 in...\nvec4 hash44(vec4 p4)\n{\n\tp4 = fract(p4  * HASHSCALE4);\n    p4 += dot(p4, p4.wzxy+19.19);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n}\n\nfloat thash12(vec2 p) {\n\treturn fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\nvec3 thash33(vec3 p) {\n\tp = vec3( dot(p,vec3(127.1,311.7, 74.7)),\n\t\t\t  dot(p,vec3(269.5,183.3,246.1)),\n\t\t\t  dot(p,vec3(113.5,271.9,124.6)));\n\treturn fract(sin(p)*43758.5453123);\n}\n\nmat3 rotX( float fAngle ) {\n    float s = sin( fAngle );\n    float c = cos( fAngle );\n    return mat3( 1.0, 0.0, 0.0, \n                 0.0, c, s,\n                 0.0, -s, c );  \n}\n\n\nmat3 rotY( float fAngle ) {\n    float s = sin( fAngle );\n    float c = cos( fAngle );\n    return mat3( c, 0.0, s, \n                         0.0, 1.0, 0.0,\n                         -s, 0.0, c );\n  \n}\n\n\nmat3 rotZ( float fAngle ) {\n    float s = sin( fAngle );\n    float c = cos( fAngle );\n    return mat3( c, s, 0.0, \n                 -s, c, 0.0,\n                 0.0, 0.0, 1.0 );\n  \n}\n\n\nmat4 projection(vec3 pa, vec3 pb, vec3 pc, vec3 pe, float n, float f) {\n    vec3 vr = normalize(pb - pa);\n    vec3 vu = normalize(pc - pa);\n    vec3 vn = cross(vr, vu);\n    vec3 va = pa - pe;\n    vec3 vb = pb - pe;\n    vec3 vc = pc - pe;\n    float d = -dot(va, vn);\n    float nod = n / d;\n    float l = dot(vr, va)  * nod;\n    float r = dot(vr, vb)  * nod;\n    float b = dot(vu, va)  * nod;\n    float t = dot(vu, vc)  * nod;\n\n    // glFrustum\n    float x = 2. * n / (r - l);\n    float y = 2. * n / (t - b);\n    float A = (r + l) / (r - l);\n    float B = (t + b) / (t - b);\n    float C = -(f + n) / (f - n);\n    float D = -2. * f * n / (f - n);\n    mat4 P = mat4(\n        x, 0, 0, 0,\n        0, y, 0, 0,\n        A, B, C, -1.,\n        0, 0, D, 0.\n    );\n    return P;\n}\n\nmat4 camera(vec3 pa, vec3 pb, vec3 pc, vec3 pe, float n, float f) {\n    vec3 vr = normalize(pb - pa);\n    vec3 vu = normalize(pc - pa);\n    vec3 vn = cross(vr, vu);\n    mat4 cam = mat4(\n        vec4(vr, 0), \n        vec4(vu, 0), \n        vec4(vn, 0), \n        vec4(-pe, 1));\n    return cam;\n}\n\nvec2 quad(float id) {\n    float ux = floor(id / 6.) + mod (id, 2.);\n    float vy = mod(floor(id / 2.) + floor(id / 3.), 2.);\n    float x = ux;\n    float y = vy;\n    // generate vertices [-1, 1] x [-,1 1]\n    return 2. * mod(vec2(x, y), vec2(2, 2)) - 1.;\n}\n\nvec3 position(float id) {\n    // For across = 2, we want:\n    // x -> [0; 6], [1; 6]\n    // y -> [0; 6], [1; 6]\n    // quad 0, id = 0 - 6\n    // x -> 0\n    // y -> 0\n    // quad 1, id = 6 - 12\n    // x -> 1\n    // y -> 0\n    // quad 2, id = 12 - 18\n    // x -> 0\n    // y -> 1\n    float across = 100.;\n    float x = mod(floor(id / 6.), across);\n    float y = floor(id / (6. * across));\n    float u = x / (across - 1.0);\n    float v = y / (across - 1.0);\n    float ux = 2. * u - 1.;\n    float vy = 2. * v - 1.;\n    return vec3(ux, vy, 0);\n}\n\nvec3 position_offset(float id) {\n    vec3 pos = position(id);\n    vec3 offset = thash33(pos.xyz);\n    offset = 2. * offset - 1.;\n    return offset;\n}\n\nfloat circleSDF(float radius, vec2 pos) {\n    return length(pos) - radius;\n}\n\nvoid main() {\n    // screen + camera setup\n    float screen_width_mm = 350.90; // 14 inch\n    float screen_height_mm = 247.1; // \n    float head_to_screen_mm = 300.; // 1 ft\n    vec3 pa = 0.5 * vec3(-screen_width_mm, -screen_height_mm, 0);\n    vec3 pb = 0.5 * vec3(screen_width_mm, -screen_height_mm, 0);\n    vec3 pc = 0.5 * vec3(-screen_width_mm, screen_height_mm, 0);\n    vec3 pe = 1.*vec3(0, 0, head_to_screen_mm);\n    float n = 0.1;\n    float f = 10000.;\n    mat4 P = projection(pa, pb, pc, pe, n, f);\n    mat4 C = camera(pa, pb, pc, pe, n, f);\n\n    // write the position\n    float id = vertexId;\n    float param = 0.5 + 0.5 * sin(time);\n    vec3 world_scale = vec3(20, 20, 100);\n    vec3 pos_offset = position_offset(id);\n    vec3 xyz = position(id) + world_scale*pos_offset;\n\n    float sphere_radius = 20.;\n    vec3 sphere_xyz = vec3(0);\n    sphere_xyz.z = -(3. * world_scale.z - mod(time, 10.) * 0.6 * world_scale.z);\n    float sphere_dist = length(xyz - sphere_xyz) - sphere_radius;\n    float m = 5. * sphere_radius;\n    float s = 1.4 * sphere_radius + 60.0*hash11(xyz.z);\n    //float s = 80.*hash11(id);\n    vec3 scatter_dir = normalize(2. * hash33(pos_offset) - 1.);\n    xyz.xy += scatter_dir.xy * s * smoothstep(1.*m, -1.0*m, sphere_dist);\n\n    xyz = xyz + vec3(quad(id), 0);\n    mat3 model = rotX(3.14 * -.3) * rotZ(3.14 * time * 0.5 * pos_offset.z);\n    gl_Position = P * C * vec4(model * (xyz + 0.5*vec3(quad(id), 0)), 1.0);\n\n    // write the color\n    vec4 base = vec4(0.1 * hash13(position(id)));\n    base.a = 0.15;\n    vec4 shocked = vec4(0.4 * hsv2rgb(vec3(1. - 0.1*pos_offset.z, 1., 1.)), 0.2);\n    v_color = mix(base, shocked, smoothstep(1.*m, -1.*m, sphere_dist));\n}"
  },
  "screenshotURL": "data/images/images-29udcfgi4z50blicm-thumbnail.jpg",
  "hasSound": "",
  "views": "441",
  "likes": "4",
  "revisionId": "v5xPHwhfnEz8aYeuY"
}