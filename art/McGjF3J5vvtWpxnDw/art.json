{
  "_id": "McGjF3J5vvtWpxnDw",
  "owner": {
    "_id": "2X4iv76yo3TGFXLzD",
    "createdAt": {
      "$date": {
        "$numberLong": "1493207163185"
      }
    },
    "profile": {
      "name": "Thomas Hooper",
      "avatarUrl": "https://avatars.githubusercontent.com/tdhooper?s=200"
    },
    "username": "tdhooper"
  },
  "createdAt": {
    "$date": {
      "$numberLong": "1493928894128"
    }
  },
  "modifiedAt": {
    "$date": {
      "$numberLong": "1494086086478"
    }
  },
  "origId": null,
  "name": "geodesic2",
  "notes": "",
  "rank": {
    "$numberDouble": "1.6510177107766402"
  },
  "private": false,
  "unlisted": true,
  "username": "tdhooper",
  "avatarUrl": "https://avatars.githubusercontent.com/tdhooper?s=200",
  "settings": "{\"num\":12093,\"mode\":\"TRIANGLES\",\"sound\":\"https://soundcloud.com/chahinesounds/kirby-chahine\",\"lineSize\":\"NATIVE\",\"backgroundColor\":[0,0,0,1],\"shader\":\"// --------------------------------------------------------\\n// Spectrum colour palette\\n// IQ https://www.shadertoy.com/view/ll2GD3\\n// --------------------------------------------------------\\n\\nvec3 pal( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d ) {\\n    return a + b*cos( 6.28318*(c*t+d) );\\n}\\n\\nvec3 spectrum(float n) {\\n    return pal( n, vec3(0.5,0.5,0.5),vec3(0.5,0.5,0.5),vec3(1.0,1.0,1.0),vec3(0.0,0.33,0.67) );\\n}\\n\\n\\n// --------------------------------------------------------\\n// Camera and display\\n// gman https://www.vertexshaderart.com/art/7TrYkuK4aHzLqvZ7r\\n// --------------------------------------------------------\\n\\n#define PI radians(180.0)\\n\\nvec3 hsv2rgb(vec3 c) {\\n  c = vec3(c.x, clamp(c.yz, 0.0, 1.0));\\n  vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\\n}\\n\\nmat4 rotX(float angleInRadians) {\\n    float s = sin(angleInRadians);\\n    float c = cos(angleInRadians);\\n    \\n    return mat4( \\n      1, 0, 0, 0,\\n      0, c, s, 0,\\n      0, -s, c, 0,\\n      0, 0, 0, 1);  \\n}\\n\\nmat4 rotY(float angleInRadians) {\\n    float s = sin(angleInRadians);\\n    float c = cos(angleInRadians);\\n    \\n    return mat4( \\n      c, 0,-s, 0,\\n      0, 1, 0, 0,\\n      s, 0, c, 0,\\n      0, 0, 0, 1);  \\n}\\n\\nmat4 rotZ(float angleInRadians) {\\n    float s = sin(angleInRadians);\\n    float c = cos(angleInRadians);\\n    \\n    return mat4( \\n      c,-s, 0, 0, \\n      s, c, 0, 0,\\n      0, 0, 1, 0,\\n      0, 0, 0, 1); \\n}\\n\\nmat4 trans(vec3 trans) {\\n  return mat4(\\n    1, 0, 0, 0,\\n    0, 1, 0, 0,\\n    0, 0, 1, 0,\\n    trans, 1);\\n}\\n\\nmat4 ident() {\\n  return mat4(\\n    1, 0, 0, 0,\\n    0, 1, 0, 0,\\n    0, 0, 1, 0,\\n    0, 0, 0, 1);\\n}\\n\\nmat4 scale(vec3 s) {\\n  return mat4(\\n    s[0], 0, 0, 0,\\n    0, s[1], 0, 0,\\n    0, 0, s[2], 0,\\n    0, 0, 0, 1);\\n}\\n\\nmat4 uniformScale(float s) {\\n  return mat4(\\n    s, 0, 0, 0,\\n    0, s, 0, 0,\\n    0, 0, s, 0,\\n    0, 0, 0, 1);\\n}\\n\\nmat4 persp(float fov, float aspect, float zNear, float zFar) {\\n  float f = tan(PI * 0.5 - 0.5 * fov);\\n  float rangeInv = 1.0 / (zNear - zFar);\\n\\n  return mat4(\\n    f / aspect, 0, 0, 0,\\n    0, f, 0, 0,\\n    0, 0, (zNear + zFar) * rangeInv, -1,\\n    0, 0, zNear * zFar * rangeInv * 2., 0);\\n}\\n\\nmat4 trInv(mat4 m) {\\n  mat3 i = mat3(\\n    m[0][0], m[1][0], m[2][0], \\n    m[0][1], m[1][1], m[2][1], \\n    m[0][2], m[1][2], m[2][2]);\\n  vec3 t = -i * m[3].xyz;\\n    \\n  return mat4(\\n    i[0], t[0], \\n    i[1], t[1],\\n    i[2], t[2],\\n    0, 0, 0, 1);\\n}\\n\\nmat4 transpose(mat4 m) {\\n  return mat4(\\n    m[0][0], m[1][0], m[2][0], m[3][0], \\n    m[0][1], m[1][1], m[2][1], m[3][1],\\n    m[0][2], m[1][2], m[2][2], m[3][2],\\n    m[0][3], m[1][3], m[2][3], m[3][3]);\\n}\\n\\nmat4 lookAt(vec3 eye, vec3 target, vec3 up) {\\n  vec3 zAxis = normalize(eye - target);\\n  vec3 xAxis = normalize(cross(up, zAxis));\\n  vec3 yAxis = cross(zAxis, xAxis);\\n\\n  return mat4(\\n    xAxis, 0,\\n    yAxis, 0,\\n    zAxis, 0,\\n    eye, 1);\\n}\\n\\nmat4 inverse(mat4 m) {\\n  float\\n      a00 = m[0][0], a01 = m[0][1], a02 = m[0][2], a03 = m[0][3],\\n      a10 = m[1][0], a11 = m[1][1], a12 = m[1][2], a13 = m[1][3],\\n      a20 = m[2][0], a21 = m[2][1], a22 = m[2][2], a23 = m[2][3],\\n      a30 = m[3][0], a31 = m[3][1], a32 = m[3][2], a33 = m[3][3],\\n\\n      b00 = a00 * a11 - a01 * a10,\\n      b01 = a00 * a12 - a02 * a10,\\n      b02 = a00 * a13 - a03 * a10,\\n      b03 = a01 * a12 - a02 * a11,\\n      b04 = a01 * a13 - a03 * a11,\\n      b05 = a02 * a13 - a03 * a12,\\n      b06 = a20 * a31 - a21 * a30,\\n      b07 = a20 * a32 - a22 * a30,\\n      b08 = a20 * a33 - a23 * a30,\\n      b09 = a21 * a32 - a22 * a31,\\n      b10 = a21 * a33 - a23 * a31,\\n      b11 = a22 * a33 - a23 * a32,\\n\\n      det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;\\n\\n  return mat4(\\n      a11 * b11 - a12 * b10 + a13 * b09,\\n      a02 * b10 - a01 * b11 - a03 * b09,\\n      a31 * b05 - a32 * b04 + a33 * b03,\\n      a22 * b04 - a21 * b05 - a23 * b03,\\n      a12 * b08 - a10 * b11 - a13 * b07,\\n      a00 * b11 - a02 * b08 + a03 * b07,\\n      a32 * b02 - a30 * b05 - a33 * b01,\\n      a20 * b05 - a22 * b02 + a23 * b01,\\n      a10 * b10 - a11 * b08 + a13 * b06,\\n      a01 * b08 - a00 * b10 - a03 * b06,\\n      a30 * b04 - a31 * b02 + a33 * b00,\\n      a21 * b02 - a20 * b04 - a23 * b00,\\n      a11 * b07 - a10 * b09 - a12 * b06,\\n      a00 * b09 - a01 * b07 + a02 * b06,\\n      a31 * b01 - a30 * b03 - a32 * b00,\\n      a20 * b03 - a21 * b01 + a22 * b00) / det;\\n}\\n\\nmat4 cameraLookAt(vec3 eye, vec3 target, vec3 up) {\\n  #if 1\\n  return inverse(lookAt(eye, target, up));\\n  #else\\n  vec3 zAxis = normalize(target - eye);\\n  vec3 xAxis = normalize(cross(up, zAxis));\\n  vec3 yAxis = cross(zAxis, xAxis);\\n\\n  return mat4(\\n    xAxis, 0,\\n    yAxis, 0,\\n    zAxis, 0,\\n    -dot(xAxis, eye), -dot(yAxis, eye), -dot(zAxis, eye), 1);  \\n  #endif\\n  \\n}\\n\\nstruct Tri {\\n    vec3 a;\\n    vec3 b;\\n    vec3 c;\\n};\\n  \\nvec3 bToC(Tri tri, float a, float b, float c) {\\n    return a * tri.a + b * tri.b + c * tri.c;\\n}\\n\\nvec3 bToC(Tri tri, vec3 bary) {\\n    return bary.x * tri.a + bary.y * tri.b + bary.z * tri.c;\\n}\\n\\n\\nfloat calcTriRow(float n) {\\n  return floor( (1. + sqrt(1. + 8. * n)) / 2. ) - 1.;\\n}\\n\\n\\nvec3 triVertex(Tri tri, float row, float column, float rows, float index, float doSecondPass) {\\n  float doFirstPass = 1. - doSecondPass;\\n  \\n  // First pass offsets\\n  row += min(index, 1.) * doFirstPass;\\n  column += max(index - 1., 0.) * doFirstPass;\\n\\n  // Second pass offsets\\n  row += max(index, 1.) * doSecondPass;\\n  column += min(index, 1.) * doSecondPass;\\n\\n  // Cartesian coordinates for column/row\\n  float mixA = row / rows;\\n  float mixB = column / max(row, 1.);\\n  vec3 vertex = mix(tri.a, mix(tri.b, tri.c, mixB), mixA);\\n  return vertex;\\n}\\n\\nvec3 pick(vec3 a, vec3 b, vec3 c, float index) {\\n\\treturn mix(mix(a, b, index), c, max(index - 1., 0.));\\n}\\n\\n\\nstruct GeoPoints {\\n\\tvec3 vertex;\\n  \\tvec3 center;\\n};\\n  \\n\\n// Find vertex and center in triangle with n subdivision rows at index\\nGeoPoints geoPoints(Tri tri, float rows, float i) {\\n  float firstPass = (rows - 1.) * (rows + 2.) / 2. + 1.;\\n  \\n  // Sub-tringle vertex index\\n  float id = mod(i, 3.);\\n  \\n  //firstPass = 56.;\\n  \\n  // Repeat whole triangle\\n  ///i = mod(i, rows * rows* 3.);\\n  \\n  // Sub-triangle index\\n  i = floor(i / 3.);\\n  \\n  \\n  // First pass is upwards pointing triangles,\\n  // second pass fills in the gaps\\n  float doSecondPass = max(0., sign(i - firstPass + 1.));\\n  \\n  i -= firstPass * doSecondPass;\\n  \\n  float row = calcTriRow(i);\\n  float startOfRow = row * (row + 1.) / 2.;\\n  float column = mod(i - startOfRow, row + 1.);\\n\\n  \\n  vec3 vertexA = triVertex(tri, row, column, rows, 0., doSecondPass);  \\n  vec3 vertexB = triVertex(tri, row, column, rows, 1., doSecondPass);  \\n  vec3 vertexC = triVertex(tri, row, column, rows, 2., doSecondPass);  \\n  \\n  vec3 vertex = pick(vertexA, vertexB, vertexC, id);\\n  vec3 center = (vertexA + vertexB + vertexC) / 3.;\\n  \\n  return GeoPoints(vertex, center);\\n}\\n\\n#define PHI (1.618033988749895)\\n     // PHI (sqrt(5)*0.5 + 0.5)\\n\\n\\n#define IcoVert0 normalize(vec3(0, PHI, 1))\\n#define IcoVert1 normalize(vec3(0, PHI, -1))\\n#define IcoVert2 normalize(vec3(0, -PHI, 1))\\n#define IcoVert3 normalize(vec3(0, -PHI, -1))\\n#define IcoVert4 normalize(vec3(1, 0, PHI))\\n#define IcoVert5 normalize(vec3(1, 0, -PHI))\\n#define IcoVert6 normalize(vec3(-1, 0, PHI))\\n#define IcoVert7 normalize(vec3(-1, 0, -PHI))\\n#define IcoVert8 normalize(vec3(PHI, 1, 0))\\n#define IcoVert9 normalize(vec3(PHI, -1, 0))\\n#define IcoVert10 normalize(vec3(-PHI, 1, 0))\\n#define IcoVert11 normalize(vec3(-PHI, -1, 0))\\n\\nfloat beat(float i, float loop) {\\n\\treturn 1. - min(mod(i, loop), 1.);\\n} \\n\\nfloat signbeat(float i, float loop) {\\n\\treturn beat(i, loop) * 2. - 1.;\\n}\\n\\n\\nvec3 shift(vec3 v, float offset) {\\n\\toffset = mod(offset, 3.);\\n  \\tif (offset == 0.) {\\n      return v.xyz;\\n  \\t}\\n \\tif (offset == 1.) {\\n      return v.zxy;\\n  \\t}\\n \\tif (offset == 2.) {\\n      return v.yzx;\\n  \\t}\\n}\\n\\nfloat round(float a) {\\n\\treturn floor(a + .5);\\n}\\n\\n// Step through each vertex of each icosahedron face\\nvec3 icosahedronFaceVertex(float i) {\\n  \\n  float stage, stageIndexOffset, stageLength;\\n  float a, a0, a1, a2, b, b0, b1, b2, offset, offset0, offset1,offset2;\\n  \\n  stage = round( log2( floor(i / 6.) + 2.) - 1.);\\n  stageIndexOffset = 6. * (stage * stage);\\n  i -= stageIndexOffset;\\n  stageLength = 3. * (stage + 1.) * (stage + 2.);\\n  \\n  float floatFudge = .01; // Fixes rounding issue on OS X\\n  float invert = floor(i / stageLength * (2. + floatFudge)) * 2. - 1.;\\n  \\n  // Stage 0\\n  a0 = invert;\\n  b0 = invert;\\n  offset0 = mod(i, 3.);\\n  \\n  // Stage 1\\n  a1 = invert;\\n  b1 = signbeat(i, 3.) * -1. * invert;\\n  offset1 = mod(floor(i / 3.) - beat(i - 2., 3.), 3.);\\n\\n  // Stage 2\\n  a2 = b1;\\n  b2 = signbeat(i - 2., 3.) * -1. * invert;\\n  offset2 = mod(floor(i / 6.) + (1. - beat(i, 3.)) + beat(i - 5., 6.), 3.);\\n  \\n  // Pick stage to show\\n  float blend1 = stage;\\n  float blend2 = max(0., stage - 1.);\\n  a = mix(mix(a0, a1, blend1), a2, blend2);\\n  b = mix(mix(b0, b1, blend1), b2, blend2);\\n  offset = mix(mix(offset0, offset1, blend1), offset2, blend2);\\n\\n  vec3 icoVert = normalize(vec3(PHI, 1, 0));\\n  icoVert *= vec3(a, b, 1.);\\n  icoVert = shift(icoVert, offset);  \\n  //icoVert = normalize(icoVert);\\n  return icoVert;\\n}\\n\\n\\nfloat mb(GeoPoints geo, vec3 origin, float index) {\\n  \\tvec3 o2 = vec3(1,0,0);\\n  \\t//origin = vec3(0,1,0);\\n  \\tvec3 pos = mix(geo.center, geo.vertex, sin(time) * .5 + .5);\\n\\t\\n  \\tfloat blendVertex = abs(dot(geo.vertex, origin));\\t\\n\\tfloat blendCenter = abs(dot(geo.center, origin));\\t\\n\\t\\n  \\tfloat b1 = sin(blendVertex * 20. + time) * .5 + .5;\\n  \\tfloat b2 = sin(blendCenter * 10. + time*-2.) * .5 + .5;\\n  \\n  \\treturn b1 + b2 * (sin(time * .5) * .5 + .5) * 1.2;\\n  \\n  \\tfloat x = abs(dot(pos, vec3(0,1,0)));\\n  \\tfloat y = abs(dot(pos, vec3(1,0,0)));\\n  \\tvec4 a = texture2D(sound, vec2(x, 240. * y));\\n\\treturn a.a;\\n\\t//return blend;\\t\\n\\t//return sin(blend * 20. + time * -5.) * .5 + .5;\\n}\\n\\n\\n\\nvoid main() {\\n  float numQuads = floor(vertexCount / 6.);\\n  float around = 100.;\\n  float down = numQuads / around;\\n  float quadId = floor(vertexId / 6.);\\n  \\n  float qx = mod(quadId, around);\\n  float qy = floor(quadId / around);\\n  \\n  // 0--1 3\\n  // | / /|\\n  // |/ / |\\n  // 2 4--5\\n  //\\n  // 0 1 0 1 0 1\\n  // 0 0 1 0 1 1\\n  \\n  float edgeId = mod(vertexId, 6.);\\n  float ux = mod(edgeId, 2.);\\n  float vy = mod(floor(edgeId / 2.) + floor(edgeId / 3.), 2.); \\n  \\n  float qu = (qx + ux) / around;\\n  float qv = (qy + vy) / down;\\n  \\n  float r = sin(qv * PI);\\n  float x = cos(qu * PI * 2.) * r;\\n  float z = sin(qu * PI * 2.) * r;\\n  \\n  vec3 pos = vec3(x, cos(qv * PI), z);\\n  float maxPoints = vertexCount;\\n  \\n  \\n  float subdivisionRows = floor(sqrt(vertexCount / 20. / 3.));\\n  //subdivisionRows = 2.;\\n  float trianglesPerFace = subdivisionRows * subdivisionRows;\\n  maxPoints = trianglesPerFace * 3. * 20.;\\n  float i = min(vertexId, maxPoints);\\n  float faceIndex = floor(i / (trianglesPerFace * 3.));\\n  \\n  //faceIndex = 0.;\\n  \\n  Tri tri = Tri(\\n  \\ticosahedronFaceVertex(faceIndex * 3. + 0.),\\n    icosahedronFaceVertex(faceIndex * 3. + 1.),\\n    icosahedronFaceVertex(faceIndex * 3. + 2.)\\n  );\\n  \\n  i = mod(i, trianglesPerFace * 3.);\\n  GeoPoints geo = geoPoints(tri, subdivisionRows, i);\\n  pos = geo.vertex;\\n  pos = normalize(pos);\\n\\n  //pos = icosahedronFaceVertex(vertexId);\\n  \\n  \\n  float blend2 = 0.;\\n  blend2 += mb(geo, IcoVert0, 0.);\\n  blend2 += mb(geo, IcoVert1, 1.);\\n  blend2 += mb(geo, IcoVert4, 2.);\\n  blend2 += mb(geo, IcoVert5, 3.);\\n  blend2 += mb(geo, IcoVert8, 4.);\\n  blend2 += mb(geo, IcoVert9, 5.);\\n  \\n  blend2 /= 5.;\\n \\n  float blend = blend2;\\n  //blend = pow(blend, (sin(time * 5.) * .5 + .5) * 10.);\\n  //blend = blend2 * 5. - 10.;\\n  \\n  pos *= mix(.5, .8, blend);\\n  \\n  float tm = time * .5;\\n  tm = 8.;\\n  float rd = 3.;\\n  mat4 mat = persp(PI * 0.25, resolution.x / resolution.y, 0.1, 100.);\\n  vec3 eye = vec3(\\n    cos(tm) * rd,\\n    cos(tm) * rd,\\n    sin(tm) * rd\\n  );\\n  vec3 target = vec3(0);\\n  vec3 up = vec3(0,1,0);\\n  \\n  mat *= cameraLookAt(eye, target, up);  \\n  \\n  vec4 pos4 = mat * vec4(pos, 1);\\n  //pos4 = vec4(pos, 1.);\\n  \\n  \\n  gl_Position = pos4;\\n  gl_PointSize = 4.;\\n\\n  vec3 col = vec3(spectrum(vertexId / maxPoints));\\n  //col = vec3(.5);\\n  col *= smoothstep(rd*3., rd, pos4.z);\\n  col += pow((dot(normalize(pos4.xyz), vec3(.5,-.5,0))) * 2., 2.);\\n  \\n  col = spectrum(blend);\\n  \\n  v_color = vec4(col, 1.);\\n  \\n  \\n}\"}",
  "screenshotURL": "data/images/images-9dxn7oklyspslz893-thumbnail.jpg",
  "hasSound": true,
  "views": {
    "$numberInt": "7"
  },
  "likes": {
    "$numberInt": "0"
  },
  "revisionId": "C7MBo3WMLKpSHNcL9"
}