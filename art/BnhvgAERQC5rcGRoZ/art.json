{
  "_id": "BnhvgAERQC5rcGRoZ",
  "owner": {
    "username": "anon"
  },
  "createdAt": {
    "$date": {
      "$numberLong": "1555887621705"
    }
  },
  "modifiedAt": {
    "$date": {
      "$numberLong": "1555887621705"
    }
  },
  "origId": "TGGLggjxQgLPEFHWx",
  "name": "seascape",
  "notes": "",
  "rank": {
    "$numberDouble": "1.533305406799065"
  },
  "private": false,
  "unlisted": false,
  "username": "-anon-",
  "avatarUrl": "",
  "settings": "{\"num\":16384,\"mode\":\"POINTS\",\"sound\":\"\",\"lineSize\":\"NATIVE\",\"backgroundColor\":[0,0,0,1],\"shader\":\"// classic retro effect\\n// rotate and scale by moving mouse\\n// \\n// pixel shader version: https://www.shadertoy.com/view/lt2SWc\\n// (a little slower)\\n//\\n// update:\\n//  enlarged points for better visibility\\n//\\n\\n\\n#define POINTSIZE 2.0\\nfloat SCALE = 1.0;\\nfloat SIZE = floor( sqrt( vertexCount ) );\\nfloat TSCALE = 0.2 * 4096./vertexCount;\\nfloat MSCALE = 0.12 * 64.0/SIZE;\\n\\n// sea\\nconst int ITER_GEOMETRY = 3;\\nconst int ITER_FRAGMENT = 5;\\nconst float SEA_HEIGHT = 0.6;\\nconst float SEA_CHOPPY = 4.0;\\nconst float SEA_SPEED = 0.8;\\nconst float SEA_FREQ = 0.16;\\nconst vec3 SEA_BASE = vec3(0.1,0.19,0.22);\\nconst vec3 SEA_WATER_COLOR = vec3(0.8,0.9,0.6);\\n#define SEA_TIME (1.0 + iTime * SEA_SPEED)\\nconst mat2 octave_m = mat2(1.6,1.2,-1.2,1.6);\\n\\nvec3 rotateY( vec3 p, float a )\\n{\\n    float sa = sin(a);\\n    float ca = cos(a);\\n    vec3 r;\\n    r.x = ca*p.x + sa*p.z;\\n    r.y = p.y;\\n    r.z = -sa*p.x + ca*p.z;\\n    return r;\\n}\\n\\n// terrain function from mars shader by reider\\n// https://www.shadertoy.com/view/XdsGWH\\nconst mat2 mr = mat2 (0.84147,  0.54030,\\n\\t\\t\\t\\t\\t  0.54031230, -0.84147 );\\n\\n\\nfloat hash( vec2 p ) {\\n\\tfloat h = dot(p,vec2(127.1,311.7));\\t\\n    return fract(sin(h)*43758.5453123);\\n}\\nfloat noise( in vec2 p ) {\\n    vec2 i = floor( p );\\n    vec2 f = fract( p );\\t\\n\\tvec2 u = f*f*(3.0-2.0*f);\\n    return -1.0+2.0*mix( mix( hash( i + vec2(0.0,0.0) ), \\n                     hash( i + vec2(1.0,0.0) ), u.x),\\n                mix( hash( i + vec2(0.0,1.0) ), \\n                     hash( i + vec2(1.0,1.0) ), u.x), u.y);\\n}\\nfloat fbm( vec2 uv, float choppy )\\n{\\n    uv += noise(uv);        \\n    vec2 wv = 1.0-abs(sin(uv));\\n    vec2 swv = abs(cos(uv));    \\n    wv = mix(wv,swv,wv);\\n    return pow(1.0-pow(wv.x * wv.y,0.65),choppy);\\n}\\n\\n\\nvec3 GetPoint( float vertexid )\\n{\\n  float SPACING = 16.0 / SIZE;\\n  float x = mod( vertexid, SIZE );\\n  if (x==SIZE-1.) // last in 'line'\\n  {\\n  \\t//x = SIZE-2.; // equals previous\\n  }\\n  float y = floor( vertexid / SIZE );\\n  if (mod(y,2.)>0.0)\\n  {\\n    // odd - change direction\\n    x = SIZE - 1. - x;\\n  }\\n  vec2 trans = vec2( time * 16., time * 23.0 ) * MSCALE;\\n  return vec3( (-SIZE/2.0 + x) * SPACING, fbm( vec2( x, y ) * TSCALE + trans, SEA_CHOPPY ) * SCALE, (-SIZE/2.0 + y) * SPACING );\\n}\\n\\nvoid main()\\n{\\n  if (mod(SIZE,2.)>0.) SIZE += 1.; // need even number of points on side\\n  vec3 p = GetPoint( vertexId );\\n  float fov = 1.1;\\n  p = rotateY( p, -mouse.x*2.0 );\\n  float origz = p.z;\\n  p += vec3( 0.0, -5.0, 15.0 );\\n  gl_Position = vec4( p.xy*fov, 1.0/(p.z-0.0), p.z );   \\n  gl_PointSize = POINTSIZE;\\n  v_color = vec4(max( 0.0, 1.0 - p.z/24. ) );\\n}\"}",
  "screenshotURL": "data/images/images-knvd0q6ni7tain02o-thumbnail.jpg",
  "hasSound": "",
  "views": {
    "$numberInt": "145"
  },
  "likes": {
    "$numberInt": "0"
  },
  "revisionId": "YpudJ3BbyJHxf8mzz"
}