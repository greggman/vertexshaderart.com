{
  "_id": "Qa3ssdh39M6HGfPqM",
  "owner": {
    "_id": "Pexi77zfde4iNKmrT",
    "createdAt": {
      "$date": {
        "$numberLong": "1493741221077"
      }
    },
    "profile": {
      "name": "Kolargon Generative",
      "avatarUrl": "https://lh3.googleusercontent.com/-tiKYx1U71-Q/AAAAAAAAAAI/AAAAAAAAAGg/b-eEUsFpspc/photo.jpg"
    },
    "username": "kolargon"
  },
  "createdAt": {
    "$date": {
      "$numberLong": "1551662603640"
    }
  },
  "modifiedAt": {
    "$date": {
      "$numberLong": "1551662603640"
    }
  },
  "origId": "k9wLKsfTxHABY5b7P",
  "name": "group trajectory small",
  "notes": "",
  "rank": {
    "$numberDouble": "1.0471186449889511"
  },
  "private": true,
  "unlisted": false,
  "username": "kolargon",
  "avatarUrl": "https://lh3.googleusercontent.com/-tiKYx1U71-Q/AAAAAAAAAAI/AAAAAAAAAGg/b-eEUsFpspc/photo.jpg",
  "settings": "{\"num\":50000,\"mode\":\"TRI_STRIP\",\"sound\":\"https://soundcloud.com/caseandpoint/case-point-upgrade-free-download\",\"lineSize\":\"NATIVE\",\"backgroundColor\":[0,0,0,1],\"shader\":\" #define ITERS 10\\n\\n//KDrawmode=GL_TRIANGLE_STRIP\\n\\n\\n#define lineNumber 10.//KParameter0 1.>>10.\\n#define speedFactor 1.//KParameter1 1.>>5.\\n#define sndFactor 3.//KParameter7 0.>>5.\\n#define cubeRotFactor 1.//KParameter2 1.>>15.\\n\\n\\n\\n#define HPI 1.570796326795\\n\\n\\n#define PI   3.14159265358988\\n\\n\\nmat4 lookAt(vec3 eye, vec3 target, vec3 up) {\\n  vec3 zAxis = normalize(eye - target);\\n  vec3 xAxis = normalize(cross(up, zAxis));\\n  vec3 yAxis = cross(zAxis, xAxis);\\n\\n  return mat4(\\n    xAxis, 0,\\n    yAxis, 0,\\n    zAxis, 0,\\n    eye, 1);\\n}\\n\\nmat4 inverse(mat4 m) {\\n  float\\n      a00 = m[0][0], a01 = m[0][1], a02 = m[0][2], a03 = m[0][3],\\n      a10 = m[1][0], a11 = m[1][1], a12 = m[1][2], a13 = m[1][3],\\n      a20 = m[2][0], a21 = m[2][1], a22 = m[2][2], a23 = m[2][3],\\n      a30 = m[3][0], a31 = m[3][1], a32 = m[3][2], a33 = m[3][3],\\n\\n      b00 = a00 * a11 - a01 * a10,\\n      b01 = a00 * a12 - a02 * a10,\\n      b02 = a00 * a13 - a03 * a10,\\n      b03 = a01 * a12 - a02 * a11,\\n      b04 = a01 * a13 - a03 * a11,\\n      b05 = a02 * a13 - a03 * a12,\\n      b06 = a20 * a31 - a21 * a30,\\n      b07 = a20 * a32 - a22 * a30,\\n      b08 = a20 * a33 - a23 * a30,\\n      b09 = a21 * a32 - a22 * a31,\\n      b10 = a21 * a33 - a23 * a31,\\n      b11 = a22 * a33 - a23 * a32,\\n\\n      det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;\\n\\n  return mat4(\\n      a11 * b11 - a12 * b10 + a13 * b09,\\n      a02 * b10 - a01 * b11 - a03 * b09,\\n      a31 * b05 - a32 * b04 + a33 * b03,\\n      a22 * b04 - a21 * b05 - a23 * b03,\\n      a12 * b08 - a10 * b11 - a13 * b07,\\n      a00 * b11 - a02 * b08 + a03 * b07,\\n      a32 * b02 - a30 * b05 - a33 * b01,\\n      a20 * b05 - a22 * b02 + a23 * b01,\\n      a10 * b10 - a11 * b08 + a13 * b06,\\n      a01 * b08 - a00 * b10 - a03 * b06,\\n      a30 * b04 - a31 * b02 + a33 * b00,\\n      a21 * b02 - a20 * b04 - a23 * b00,\\n      a11 * b07 - a10 * b09 - a12 * b06,\\n      a00 * b09 - a01 * b07 + a02 * b06,\\n      a31 * b01 - a30 * b03 - a32 * b00,\\n      a20 * b03 - a21 * b01 + a22 * b00) / det;\\n}\\n\\nvec3 noise(vec3 _v) {\\n    return fract(sin(_v * vec3(43758.5453123, 12345.6789012,76543.2109876)));\\n}\\n\\nvec3 rotX(vec3 _v, float _rad) {\\n    vec2 f = sin(vec2(_rad, _rad + HPI));\\n    vec3 r = _v;\\n    r.y = _v.y * f.y + _v.z * -f.x;\\n    r.z = _v.y * f.x + _v.z *  f.y;\\n    return r;\\n}\\n\\nvec3 rotY(vec3 _v, float _rad) {\\n    vec2 f = sin(vec2(_rad, _rad + HPI));\\n    vec3 r = _v;\\n    r.x =  _v.x *  f.y + _v.z *  f.x;\\n    r.z =  _v.x * -f.x + _v.z *  f.y;\\n    return r;\\n}\\n\\nvec3 rotZ(vec3 _v, float _rad) {\\n    vec2 f = sin(vec2(_rad, _rad + HPI));\\n    vec3 r = _v;\\n    r.x =  _v.x *  f.x + _v.y * f.y;\\n    r.y =  _v.x * -f.y + _v.y * f.x;\\n    return r;\\n}\\n\\n\\nvec4 perspective(vec3 _v, float _fov, float _near, float _far, vec2 _res) {\\n    vec4 r = vec4(_v, -_v.z);\\n    r.xy *= vec2(_res.y / _res.x, 1.0) / tan(radians(_fov * 0.5));\\n    r.z = (-_v.z * (_far + _near) - 2.0 * _far * _near) / (_far - _near);\\n    return r;\\n}\\n\\nvec3 lookAt(vec3 _v, vec3 _eye, vec3 _look, vec3 _up) {\\n    vec3 z = normalize(_eye - _look);\\n    vec3 x = normalize(cross(_up, z));\\n    vec3 y = cross(z, x);\\n    vec4 r = mat4(x.x, y.x, z.x, 0.0, x.y, y.y, z.y, 0.0, x.z, y.z, z.z, 0.0, 0.0, 0.0, 0.0, 1.0) *mat4(1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, -_eye.x, -_eye.y, -_eye.z, 1.0)* vec4(_v, 1.0);\\n    return r.xyz;\\n}\\n\\n\\nvec3 shade(vec3 _eye, vec3 _p, vec3 _n, vec3 _dfscol, float _amb, vec2 _spec)\\n{\\n    vec3 rgb;\\n    vec3 lit = normalize(vec3(1.0, 1.0, 4.0));\\n    \\n    float diffuse = max(0.0, dot(_n, lit)) * (1.0 - _amb) + _amb;\\n    \\n    vec3 h = normalize(normalize(_eye - _p) + lit);\\n    float specular = 1.0;\\n    if(diffuse > 0.0) {\\n        specular = max(0.1,dot(_n, h));\\n    }\\n    \\n    rgb = diffuse * _dfscol + specular * _spec.y;\\n    \\n    return rgb;\\n}\\n\\n#define kShapeVertexCount 36.0\\n#define kVertexPerShape 6.0\\n\\n\\nvec3 shapeVertex(float _vId, out vec4 _nI)\\n{\\n    float faceId = floor(_vId / kVertexPerShape);\\n    float vtxId = mod(_vId, kVertexPerShape);\\n    vec2 fp;\\n    vec3 v;\\n    \\n    if(vtxId <= 1.0) {\\n        fp = vec2(1.0, 1.0);\\n    }\\n    else if(vtxId == 2.0) {\\n        fp = vec2(-1.0, 1.0);\\n    }\\n    else if(vtxId == 3.0) {\\n        fp = vec2(1.0, -1.0);\\n    }\\n    else {\\n        fp = vec2(-1.0, -1.0);\\n    }\\n    \\n    if(faceId == 0.0) {\\n        \\n        v = vec3(fp.x, fp.y, 1.0);\\n        _nI = vec4(0.0, 0.0, 1.0, faceId);\\n    }\\n    else if(faceId == 1.0) {\\n        \\n        v = vec3(-fp.x, fp.y, -1.0);\\n        _nI = vec4(0.0, 0.0, -1.0, faceId);\\n    }\\n    else if(faceId == 2.0) {\\n        \\n        v = vec3(fp.x, 1.0, -fp.y);\\n        _nI = vec4(0.0, 1.0, 0.0, faceId);\\n    }\\n    else if(faceId == 3.0) {\\n        \\n        v = vec3(fp.x, -1.0, fp.y);\\n        _nI = vec4(0.0, -1.0, 0.0, faceId);\\n    }\\n    else if(faceId == 4.0) {\\n        \\n        v = vec3(-1.0, fp.y, -fp.x);\\n        _nI = vec4(-1.0, 0.0, 0.0, faceId);\\n    }\\n    else {\\n        \\n        v = vec3(1.0, fp.y, fp.x);\\n        _nI = vec4(1.0, 0.0, 0.0, faceId);\\n    }\\n    \\n    return v;\\n}\\n/*\\nvec3 getCurvePoint(const float id, const float _time) {\\n  return vec3(\\n    sin(id * 1.+_time*10.),\\n    sin(id * 0.5+_time*10.),\\n    sin(id * 0.25+_time*10.));\\n}\\n*/\\nvec3 getCurvePoint(const float id) {\\n  return vec3(\\n    sin(id * 1.),\\n    sin(id * 0.5),\\n    sin(id * 0.25));\\n}\\n\\n\\nconst float expand = 120.;\\nconst float off = 0.1;\\n\\nvoid track(float vertexId, float vertexCount, float base, out vec3 pos, out vec4 color, out mat4 _wmat, out mat4 _emat) \\n{\\n  \\n  float sv = vertexId / vertexCount;\\n  float v = sv + base;\\n  \\n  //float off = 0.1;\\n  \\n  vec3 r0 = getCurvePoint(v + off * 0.);\\n  vec3 r1 = getCurvePoint(v + off * 1.);\\n  vec3 r2 = getCurvePoint(v + off * 2.);\\n  \\n  vec3 s0 = normalize(r1 - r0);\\n  vec3 s1 = normalize(r2 - r1);\\n  \\n  vec3 zaxis = normalize(s1 - s0);\\n  vec3 xaxis = normalize(cross(s0, s1));\\n  vec3 yaxis = normalize(cross(zaxis, xaxis));\\n  \\n  \\n  mat4 wmat = mat4(\\n    vec4(xaxis, 0),\\n    vec4(yaxis, 0),\\n    vec4(zaxis, 0),\\n    vec4(r0 * expand, 1)); \\n  \\n  _wmat = wmat;//mat4(\\n  \\n  //vec3 eye    = b0 * expand + cyaxis * .001 + czaxis * 1.;\\n  vec3 eye    = r0 * expand + zaxis * 1.;\\n  //vec3 target = b1 * expand + cyaxis * .002 + czaxis + ms.x * cxaxis * 2. + ms.y * cyaxis * 40.;\\n  vec3 target = r1 * expand + zaxis;\\n  vec3 up     = yaxis;\\n  \\n  \\n  mat4 cmat = lookAt(eye, target, up);\\n  _emat = inverse(cmat);\\n  \\n  /*_emat = mat4(\\n    1.,0.,0.,0.,\\n    0.,1.,0.,0.,\\n    0.,0.,1.,0.,\\n    0.,0.,0.,1.); \\n  */\\n  \\n  pos = (wmat * vec4(1.,1.,1., 1)).xyz;\\n  //_cubep =  (wmat * vec4(_cubep, 1)).xyz;\\n  color = vec4(1.,1.,1., 1);\\n\\n}\\nmat4 scale(vec3 s) {\\n  return mat4(\\n    s[0], 0, 0, 0,\\n    0, s[1], 0, 0,\\n    0, 0, s[2], 0,\\n    0, 0, 0, 1);\\n}\\n\\nvoid main() {\\n   \\n    float sizeFactor = 1./100.;\\n\\n    float shapeCount = floor(vertexCount / kShapeVertexCount);\\n    float shapeId = floor(vertexId / kShapeVertexCount);\\n    float shapeVertexId = mod(vertexId, kShapeVertexCount);\\n \\n    float shapeRelId = shapeId/shapeCount;\\n    \\n    \\n    float numberOfElementPerGroup = lineNumber;\\n    \\n  \\n    float groupId = floor(shapeId/numberOfElementPerGroup);\\n    float groupCount = floor(shapeCount/numberOfElementPerGroup);\\n    float shapeIdInGroup = mod(shapeId,numberOfElementPerGroup);\\n  \\n    vec4 cbNi;\\n  \\n    vec3 cubep = shapeVertex(shapeVertexId, cbNi);;\\n    mat4 scaleMat = scale(vec3(1.*sizeFactor,1.*sizeFactor,1.*sizeFactor));\\n    cubep = (scaleMat*vec4(cubep,1.)).xyz;\\n   \\n    //create the circle group\\n    float radius = 10.*sizeFactor;\\n    cubep.x+= radius*sin(2.*PI*shapeIdInGroup/numberOfElementPerGroup);\\n    cubep.y+= radius*cos(2.*PI*shapeIdInGroup/numberOfElementPerGroup);\\n  \\n  \\n  mat4 wmat;\\n  mat4 emat;\\n  \\n  float base = 14.5; \\n  base = time * 30.0;\\n  vec4 color2 = vec4(1.,1.,1.,1.);\\n  vec3 pos;\\n  //void track(shapeId, shapeCount, base, pos, out vec4 color, out mat4 _wmat, out mat4 _emat) \\n  track(groupId, groupCount/10., base, pos, color2, wmat, emat);\\n  \\n // track(shapeId, shapeCount, base, pos, color, wmat, emat);\\n   \\n  //mat4 invmat = inverse(wmat);\\n  //wmat.z = vec4(0.,0.,0.,1.);\\n  \\n  vec3 posi = (wmat * vec4(0.,0.,0., 1)).xyz;\\n  \\n  \\n  cubep = (vec4(cubep.xyz,1.)*emat).xyz;\\n  \\n  cbNi = cbNi*wmat;\\n  cubep+= posi/expand;\\n  \\n    //cubep = vec3(cubep.x+xPos, cubep.y+sndFactor*snd, cubep.z+lineId*patternSize +mod(time*speedFactor,patternSize));//position\\n    //vec3 eye = vec3(0.5, 0.5, 1.5);\\n    vec3 eye = vec3(2.5+sin(time/1.3)/4., 2.5+sin(time/1.)/4., 2.5*cos(time/5.));\\n    //vec3 eye = vec3(sin(time/1.3), sin(time/1.), 0.5);//29./2.*abs(cos(time/5.))\\n    //vec3 eye = vec3(0., 1., 0.5);//29./2.*abs(cos(time/5.))\\n    vec3 color = shade(eye, cubep, cbNi.xyz, vec3(1.), 0.6, vec2(64.0, .8));\\n    \\n    vec3 p = lookAt(cubep, eye, vec3(0.5, 0.5, 0.), vec3(0.0, 01.0, 0.0));\\n    gl_Position = perspective(p, 60.0, 0.1, 10.0, resolution);\\n    gl_PointSize = 2.;\\n  \\n    v_color = vec4(color, 1.0);\\n    //v_color.x = acc/10.;\\n    \\n}\\n\\n\\n\\n\"}",
  "screenshotURL": "data/images/images-xseot4t5svrshwpw9-thumbnail.jpg",
  "hasSound": true,
  "views": {
    "$numberInt": "2"
  },
  "likes": {
    "$numberInt": "0"
  },
  "revisionId": "xsncu4pNXadNM3ccD"
}