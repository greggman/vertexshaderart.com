{
  "_id": "vcYrT69DDanvyFBTr",
  "owner": {
    "username": "anon"
  },
  "createdAt": {
    "$date": "1476705250893"
  },
  "modifiedAt": {
    "$date": "1476705250893"
  },
  "origId": "TdqvseMQyoJ3ZrjrD",
  "name": "Garden Fireworks",
  "notes": "",
  "rank": "1.7791064596913406",
  "private": false,
  "unlisted": false,
  "username": "-anon-",
  "avatarUrl": "",
  "settings": {
    "num": 100000,
    "mode": "TRIANGLES",
    "sound": "",
    "lineSize": "NATIVE",
    "backgroundColor": [
      0,
      0,
      0,
      1
    ],
    "shader": "// Garden Fireworks - @P_Malin\n// Playing with motion blurred hexagonal bokeh\n\n#define SHAKY_CAM\n\nfloat Cross( const in vec2 A, const in vec2 B )\n{\n    return A.x * B.y - A.y * B.x;\n}\n\nvoid GetTriInfo( const float vertexIndex, out vec2 triVertId, out float triId )\n{\n    float triVertexIndex = mod( vertexIndex, 3.0 );\n  \n    if \t\t( triVertexIndex < 0.5 ) \ttriVertId = vec2( 0.0, 0.0 );\n    else if\t( triVertexIndex < 1.5 )\ttriVertId = vec2( 1.0, 1.0 );\n    else \t\t\t\t\t\t\t\ttriVertId = vec2( 0.0, 1.0 );\n\n    triId = floor( vertexIndex / 3.0 );\n}\n\nvoid GetQuadInfo( const float vertexIndex, out vec2 quadVertId, out float quadId )\n{\n    float twoTriVertexIndex = mod( vertexIndex, 6.0 );\n    float triVertexIndex = mod( vertexIndex, 3.0 );\n  \n    if \t\t( twoTriVertexIndex < 0.5 ) quadVertId = vec2( 0.0, 0.0 );\n    else if\t( twoTriVertexIndex < 1.5 )\tquadVertId = vec2( 1.0, 0.0 );\n    else if ( twoTriVertexIndex < 2.5 )\tquadVertId = vec2( 0.0, 1.0 );\n    else if ( twoTriVertexIndex < 3.5 )\tquadVertId = vec2( 1.0, 0.0 );\n    else if ( twoTriVertexIndex < 4.5 )\tquadVertId = vec2( 1.0, 1.0 );\n    else \t\t\t\t\t\t\t\tquadVertId = vec2( 0.0, 1.0 );\n\n    quadId = floor( vertexIndex / 6.0 );\n}\n\nvoid GetMatrixFromZY( const vec3 vZ, const vec3 vY, out mat3 m )\n{\n   vec3 vX = normalize( cross( vY, vZ ) );\n   vec3 vOrthoY = normalize( cross( vZ, vX ) );\n   m[0] = vX;\n   m[1] = vOrthoY;\n   m[2] = vZ;\n}\n\n\nvoid GetMatrixFromZ( vec3 vZAxis, out mat3 m )\n{\n  \tvec3 vZ = normalize(vZAxis);\n   \tvec3 vY = vec3( 0.0, 1.0, 0.0 );\n  \tif ( abs(vZ.y) > 0.99 )\n    {\n       vY = vec3( 1.0, 0.0, 0.0 );\n    }\n  \tGetMatrixFromZY( vZ, vY, m );\n}\n\n\nmat3 RotMatrixX( float fAngle )\n{\n    float s = sin( fAngle );\n    float c = cos( fAngle );\n  \t\n    return mat3( 1.0, 0.0, 0.0, \n                 0.0, c, s,\n                 0.0, -s, c );  \n}\n\n\nmat3 RotMatrixY( float fAngle )\n{\n    float s = sin( fAngle );\n    float c = cos( fAngle );\n  \t\n    return mat3( c, 0.0, s, \n                         0.0, 1.0, 0.0,\n                         -s, 0.0, c );\n  \n}\n\n\nmat3 RotMatrixZ( float fAngle )\n{\n    float s = sin( fAngle );\n    float c = cos( fAngle );\n  \t\n    return mat3( c, s, 0.0, \n                 -s, c, 0.0,\n                 0.0, 0.0, 1.0 );\n  \n}\n\n// hash function from https://www.shadertoy.com/view/4djSRW\nfloat Hash(float p)\n{\n\tvec2 p2 = fract(vec2(p * 5.3983, p * 5.4427));\n    p2 += dot(p2.yx, p2.xy + vec2(21.5351, 14.3137));\n\treturn fract(p2.x * p2.y * 95.4337);\n}\n\n#define MOD3 vec3(.1031,.11369,.13787)\n#define MOD4 vec4(.1031,.11369,.13787, .09987)\nvec3 Hash3(float p)\n{\n   vec3 p3 = fract(vec3(p) * MOD3);\n   p3 += dot(p3, p3.yzx + 19.19);\n   return fract(vec3((p3.x + p3.y)*p3.z, (p3.x+p3.z)*p3.y, (p3.y+p3.z)*p3.x));\n}\n\nvec3 Hash32(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * MOD3);\n    p3 += dot(p3, p3.yxz+19.19);\n    return fract(vec3((p3.x + p3.y)*p3.z, (p3.x+p3.z)*p3.y, (p3.y+p3.z)*p3.x));\n}\n\n\nvec3 Noise23( vec2 p )\n{\n\tvec2 fl = floor(p);\n\n\tvec3 h00 = Hash32( fl + vec2( 0.0, 0.0 ) );\n\tvec3 h10 = Hash32( fl + vec2( 1.0, 0.0 ) );\n\tvec3 h01 = Hash32( fl + vec2( 0.0, 1.0 ) );\n\tvec3 h11 = Hash32( fl + vec2( 1.0, 1.0 ) );\n\n\tvec2 fr = p - fl;\n\t\n\tvec2 fr2 = fr * fr;\n\tvec2 fr3 = fr2 * fr;\n\t\n\tvec2 t1 = 3.0 * fr2 - 2.0 * fr3;\t\n\tvec2 t0 = 1.0 - t1;\n\t\n\treturn h00 * t0.x * t0.y\n\t\t + h10 * t1.x * t0.y\n\t\t + h01 * t0.x * t1.y\n\t\t + h11 * t1.x * t1.y;\n}\n\nstruct CameraSettings\n{\n  float fAperture;\n  float fFocalLength;\n  float fPlaneInFocus; \n  float fExposure;\n};\n\nstruct CameraPosition\n{\n  \tvec3 vPosition;\n  \tvec3 vTarget;\n  \tvec3 vUp;\n  \n  \tmat3 mRotation;\n};\n  \nstruct OutVertex\n{\n  \tvec2 vPos;\n  \tvec3 vColor;\n};  \n  \n#define HEXAGON_OUTLINE_VERTEX_COUNT \t6.0 * (6.0 + 2.0)\n\nvoid GetHexagonOutlineVertex( CameraSettings settings, const float fVertexIndex, const vec2 vOrigin, const vec2 vDir, const float r0, const float r1, const vec3 col0, const vec3 col1, inout OutVertex vertex )\n{\n  \tfloat fAngleOffset = settings.fAperture * 0.5;\n  \n  \tif ( fVertexIndex < 6.0 * 6.0 ) \n    {\n      float fQuadId;\n\n      vec2 vQuadVertId;\n      GetQuadInfo( fVertexIndex, vQuadVertId, fQuadId );\n\n      float fIndex = fQuadId + vQuadVertId.x;\n\n      float fAngle = fIndex * radians(360.0) / 6.0;\n\n      float fRadius = mix( r0, r1, vQuadVertId.y);\n\n      vec2 vPos = vec2( sin( fAngle + fAngleOffset), cos( fAngle + fAngleOffset) ) * fRadius;\n\n      float fCurrIndex = fQuadId;\n      float fCurrAngle = fCurrIndex * radians(360.0) / 6.0;\n      vec2 vCurrPos = vec2( sin( fCurrAngle + fAngleOffset), cos( fCurrAngle + fAngleOffset) );\n\n      float fNextIndex = fQuadId + 1.0;\n      float fNextAngle = fNextIndex * radians(360.0) / 6.0;\n      vec2 vNextPos = vec2( sin( fNextAngle + fAngleOffset), cos( fNextAngle + fAngleOffset) );\n\n      if ( Cross( vNextPos - vCurrPos, vDir ) >= 0.0 )\n      {\n          vPos += vDir;\n      }\n\n      vertex.vPos.xy = vOrigin + vPos;\n      vertex.vColor.rgb = mix( col0, col1, vQuadVertId.y );\n    }\n    else\n    {\n\t  float fVertexIndexB = fVertexIndex - 6.0 * 6.0;\n      float fQuadId;\n\n      vec2 vQuadVertId;\n      GetQuadInfo( fVertexIndexB, vQuadVertId, fQuadId );\n      \n      float fEdgeAngle = atan( vDir.x, vDir.y )- fAngleOffset;\n      \n      fEdgeAngle = floor( fEdgeAngle * 6.0 / radians(360.0) - 1.0 ) * radians(360.0) / 6.0;\n      \n      if ( fQuadId > 0.0 )\n      {\n\t\tfEdgeAngle += radians( 180.0 );\n      }\n      \n      float fRadius = mix( r0, r1, vQuadVertId.y);\n      vec2 vPos = vec2( sin( fEdgeAngle + fAngleOffset), cos( fEdgeAngle + fAngleOffset) ) * fRadius;\n      vPos += vDir * vQuadVertId.x;\n\n      vertex.vPos.xy = vOrigin + vPos;\n      vertex.vColor.rgb = mix( col0, col1, vQuadVertId.y );\n    }\n}\n  \n#define HEXAGON_VERTEX_COUNT (6.0 * 3.0 + 6.0 * 2.0)\nvoid GetHexagonVertex( CameraSettings settings, const float fVertexIndex, const vec2 vOrigin, const vec2 vDir, const float r, const vec3 col0, const vec3 col1, inout OutVertex vertex )\n{\n  \tfloat fAngleOffset = settings.fAperture * 0.5;\n  \n  \tif ( fVertexIndex < 6.0 * 3.0 ) \n    {\n      float fTriId;\n\n      vec2 vTriVertId;\n      GetTriInfo( fVertexIndex, vTriVertId, fTriId );\n\n      float fIndex = fTriId + vTriVertId.x;\n\n      float fAngle = fIndex * radians(360.0) / 6.0;\n\n      float fRadius = vTriVertId.y * r;\n\n      vec2 vPos = vec2( sin( fAngle + fAngleOffset), cos( fAngle + fAngleOffset) ) * fRadius;\n\n      float fCurrIndex = fTriId;\n      float fCurrAngle = fCurrIndex * radians(360.0) / 6.0;\n      vec2 vCurrPos = vec2( sin( fCurrAngle + fAngleOffset), cos( fCurrAngle + fAngleOffset) );\n\n      float fNextIndex = fTriId + 1.0;\n      float fNextAngle = fNextIndex * radians(360.0) / 6.0;\n      vec2 vNextPos = vec2( sin( fNextAngle + fAngleOffset), cos( fNextAngle + fAngleOffset) );\n\n      if ( Cross( vNextPos - vCurrPos, vDir ) >= 0.0 )\n      {\n          vPos += vDir;\n      }\n\n      vertex.vPos.xy = vOrigin + vPos;\n      vertex.vColor.rgb = mix( col0, col1, vTriVertId.y );\n    }\n    else\n    {\n\t  float fVertexIndexB = fVertexIndex - 6.0 * 3.0;\n      float fQuadId;\n\n      vec2 vQuadVertId;\n      GetQuadInfo( fVertexIndexB, vQuadVertId, fQuadId );\n      \n      float fEdgeAngle = atan( vDir.x, vDir.y )- fAngleOffset;\n      \n      fEdgeAngle = floor( fEdgeAngle * 6.0 / radians(360.0) - 1.0 ) * radians(360.0) / 6.0;\n      \n      if ( fQuadId > 0.0 )\n      {\n\t\tfEdgeAngle += radians( 180.0 );\n      }\n      \n      float fRadius = vQuadVertId.y * r;\n      vec2 vPos = vec2( sin( fEdgeAngle + fAngleOffset), cos( fEdgeAngle + fAngleOffset) ) * fRadius;\n      vPos += vDir * vQuadVertId.x;\n\n      vertex.vPos.xy = vOrigin + vPos;\n      vertex.vColor.rgb = mix( col0, col1, vQuadVertId.y );\n    }\n}\n\n\n#define BOKEH_VERTEX_COUNT ( HEXAGON_VERTEX_COUNT + HEXAGON_OUTLINE_VERTEX_COUNT ) \nvoid GetBokehVertex( CameraSettings settings, const float fVertexIndex, const vec2 vOrigin, const vec2 vDir, const float fSize, const float fCoC, const vec3 vCol, out OutVertex vertex )\n{\n  \tfloat fInnerSize = fSize + fCoC;\n  \tfloat fGlowSize = 0.02;\n  \tfloat fOuterSize = fInnerSize + fGlowSize;\n  \n  \tif ( fVertexIndex < HEXAGON_VERTEX_COUNT )\n    {\n  \t\tGetHexagonVertex( settings, fVertexIndex, vOrigin, vDir, fInnerSize, vCol, vCol, vertex );\n    }\n  \telse\n    {\n\t  \tvec3 vGlowCol = pow(vCol, vec3(0.5)) * 0.0001;    \n      \tif ( length( vGlowCol ) > 0.0000001 )\n        {\n  \t\t\tGetHexagonOutlineVertex( settings, fVertexIndex - HEXAGON_VERTEX_COUNT, vOrigin, vDir, fInnerSize, fOuterSize, vGlowCol, vCol * 0.0, vertex );\n        }\n        else\n        {\n          \tvertex.vPos.xy = vec2(0.0);\n          \tvertex.vColor.rgb = vec3(0.0);\n        }\n    }\n}\n\nfloat GetCoC( CameraSettings settings, float objectdistance )\n{\n  // http://http.developer.nvidia.com/GPUGems/gpugems_ch23.html\n\n\treturn abs(settings.fAperture * (settings.fFocalLength * (objectdistance - settings.fPlaneInFocus)) /\n          (objectdistance * (settings.fPlaneInFocus - settings.fFocalLength)));  \n}\n\n\nvec3 GetViewPos( CameraSettings settings, CameraPosition cameraPos, vec3 vWorldPos )\n{\n  \treturn (vWorldPos - cameraPos.vPosition) * cameraPos.mRotation;\n}\n\nvec2 GetScreenPos( CameraSettings settings, vec3 vViewPos )\n{  \n  \treturn vViewPos.xy * settings.fFocalLength * 5.0 / vViewPos.z;\n}\n\nCameraSettings GetCameraSettings( CameraPosition cameraPosition )\n{\n  \tCameraSettings settings;\n  \n  \tfloat aVal = sin(time * 0.25) * 0.5 + 0.5;\n  \taVal = aVal * aVal;\n  \tsettings.fAperture = aVal * 2.9 + 0.1;\n  \tfloat fVal = sin(time * 0.123) * 0.5 + 0.5;\n  \tsettings.fFocalLength = 0.2 + 0.2 * fVal;\n  \tsettings.fPlaneInFocus = length(cameraPosition.vTarget - cameraPosition.vPosition);\n  \n  \tfloat oldAVal = sin((time - 0.5) * 0.25) * 0.5 + 0.5;\n  \toldAVal = oldAVal * oldAVal;\n  \n\tsettings.fExposure = 3.0 + oldAVal *3.0;\n\n  \treturn settings;\n}\n\nstruct LightInfo\n{\n\tvec3 vWorldPos;\n  \tfloat fRadius;\n  \tvec3 vColor;\n};\n  \n  \nvec2 SolveQuadratic( float a, float b, float c )\n{\n  float d = sqrt( b * b - 4.0 * a * c );\n  vec2 dV = vec2( d, -d );\n  return (-b + dV) / (2.0 * a);\n}\n\n\nvec3 BounceParticle( vec3 vOrigin, vec3 vInitialVel, float fGravity, float fFloorHeight, float fTime )\n{\n  \tvec3 u = vInitialVel;\n  \tvec3 a = vec3(0.0, fGravity, 0.0);\n  \tvec3 vPos = vOrigin;\n\n  \tfloat t = fTime;\n    \t  \t\n  \tfor( int iBounce=0; iBounce < 3; iBounce++)\n    {\n      // When will we hit the ground?\n      vec2 q = SolveQuadratic( 0.5 * a.y, u.y, -fFloorHeight + vPos.y);\n      float tInt = max( q.x, q.y );\n      tInt -= 0.0001;\n      \n\n      if ( t < tInt )\n      {\n\t     vPos += u * t + 0.5 * a * t * t;\n         break;\n      }\n      else\n      {        \n          // Calculate velocity at intersect time\n          vec3 v = u + a * tInt;\n\n          // step to intersect time\n          vPos += u * tInt + 0.5 * a * tInt * tInt;\n       \t  u = v;\n        \n          // bounce\n          u.y = -u.y * 0.3;\n          u.xz *= 0.6;\n\n          t -= tInt;\n      }\n    }\n\n  \treturn vPos;\n}\n\nfloat fFloorHeight = 0.0;\n\nLightInfo Fountain( const in float fLightIndex, const in vec3 vPos, float fTime, vec3 vCol, float fSpread )\n{\n    float fParticleLifetime = 1.5;\n  \tLightInfo lightInfo;\n  \n  \tfloat h = Hash( fLightIndex + 12.0 );\n  \tvec3 h3 = Hash3( fLightIndex + 13.0 );\n  \n  \tfloat fAngle = fLightIndex;\n  \n  \tvec3 vInitialVel = (normalize(h3 * 2.0 - 1.0) * fSpread + vec3( 0.0, 10.0 - fSpread * 1.3, 0.0 )) * (0.4 + h * 0.4);\n  \tvec3 vOrigin = vPos + vec3( 0.0, fFloorHeight + 0.1, 0.0 ) + vInitialVel * 0.1;\n  \tlightInfo.vWorldPos = BounceParticle( vOrigin, vInitialVel, -9.81, fFloorHeight, fTime );\n\n    \n  \tlightInfo.fRadius = 0.01;  \n//  \tlightInfo.vColor = vec3(1.0, 0.4, 0.1);\n  \tlightInfo.vColor = vCol;\n       \tlightInfo.vColor *= clamp( 1.0 - fTime + fParticleLifetime - 1.0, 0.0, 1.0);\n\treturn lightInfo;  \n}\n\nLightInfo CatherineWheel( const in float fLightIndex, const in vec3 vPos, float fSequenceStart, float fSpawnTime, float fParticleT, vec3 vCol )\n{\n    \tfloat h = Hash( fLightIndex + 4.0 );\n\n\t    float fParticleLifetime = 0.3 + h *0.5;\n \tLightInfo lightInfo;\n\n  \tvec3 h3 = Hash3( fLightIndex + 12.0 );\n  \tfloat t = fSpawnTime - fSequenceStart;\n  \tif( t < 5.0 ) t = t * t;\n  \telse t = t * 5.0 + 5.0 * 5.0;\n  \t\n  \tfloat fSpawnAngle = t * 5.0;\n  \n  \tif ( h > 0.5 )\n    {\n      fSpawnAngle += radians( 180.0 );\n    }\n  \n  \tmat3 m = RotMatrixZ(fSpawnAngle);\n  \n  \tvec3 vInitialVel = vec3(-3.0, 0.0, 0.0 ) + h3 * 0.5;\n  \tvInitialVel = vInitialVel * m;\n  \tvec3 vOffset = vec3( 0.0, 0.03, 0.0 * m);\n  \tvec3 vOrigin = vPos + vOffset + vInitialVel * 0.1;\n  \tlightInfo.vWorldPos = BounceParticle( vOrigin, vInitialVel, -9.81, fFloorHeight, fParticleT );\n\n    \n  \tlightInfo.fRadius = 0.01;  \n//  \tlightInfo.vColor = vec3(1.0, 0.4, 0.1);\n  \tlightInfo.vColor = vCol;\n       \tlightInfo.vColor *= clamp( 1.0 - fParticleT + fParticleLifetime - 1.0, 0.0, 1.0);\n\treturn lightInfo;  \n}\n\n\nstruct SequenceInfo\n{\n  \tfloat fSequenceSet;\n  \tfloat fSequenceSetLength;\n  \n  \tfloat fSequenceIndex;\n  \tfloat fSequenceStartTime;\n  \n  \tfloat fSequenceSeed;\n  \tvec3 vSequenceHash;\n  \n  \tvec3 vCol;\n  \n  \tfloat fType;\n  \tvec3 vPos;\n  \tvec3 vTarget;\n};\n  \nSequenceInfo GetSequenceInfo( float fSetIndex, float fTime )\n{\n  \tSequenceInfo sequenceInfo;\n\n  \t\tfloat fSequenceSetCount = 2.0;\n  \tsequenceInfo.fSequenceSet = mod(fSetIndex, fSequenceSetCount);\n\n  \t\tfloat sh = Hash( sequenceInfo.fSequenceSet );\n  \t\tfloat fSequenceSetLength = 10.0 + sh * 5.0;\n  \n\n  \t\tsequenceInfo.fSequenceIndex = floor( fTime / fSequenceSetLength );\n  \t\tsequenceInfo.fSequenceStartTime = (sequenceInfo.fSequenceIndex * fSequenceSetLength);\n  \n  \t\tsequenceInfo.fSequenceSeed = sequenceInfo.fSequenceIndex + sequenceInfo.fSequenceSet * 12.3;\n  \t\tsequenceInfo.vSequenceHash = Hash3(sequenceInfo.fSequenceSeed);\n\n  \t\tfloat ch = Hash( sequenceInfo.fSequenceSeed * 2.34 );\n  \t\tsequenceInfo.vCol =  vec3(1.0, 0.4, 0.1);\n  \n  \t\tif( ch < 0.25 )\n        {\n          sequenceInfo.vCol =  vec3(1.0, 0.08, 0.08);\n        }\n  \t\telse if( ch < 0.5 )\n        {\n          sequenceInfo.vCol =  vec3(0.08, 0.08, 1.0);\n        }\n  \t\telse if( ch < 0.75 )\n        {\n          sequenceInfo.vCol =  vec3(0.08, 1.0, 0.08 );\n        }\n  \n  \n    \tif ( sequenceInfo.vSequenceHash.x < 0.7)\n        {\n  \t\t\tsequenceInfo.vPos = vec3(0.0);\n\t  \t\tsequenceInfo.vPos.xz = sequenceInfo.vSequenceHash.yz * 6.0 - 3.0;\n\t  \t\tsequenceInfo.fType = 0.0;\n          \tsequenceInfo.vTarget = sequenceInfo.vPos;\n          \tsequenceInfo.vTarget.y = 1.5;\n        }\n  \t\telse\n        {\n          \tsequenceInfo.vPos = vec3(0.0, 2.5, 7.0);\n\t  \t\tsequenceInfo.vPos += (sequenceInfo.vSequenceHash.xyz * 2.0 - 1.0) * vec3(5.0, 1.5, 3.0);\n\t  \t\tsequenceInfo.fType = 1.0;\n          \tsequenceInfo.vTarget = sequenceInfo.vPos;\n        }  \n  \n  \treturn sequenceInfo;\n}\n\nLightInfo GetFireworkSparkInfo( in float fLightIndex, float fTime, float fDeltaTime, vec3 h3 )\n{      \n\t    float fParticleLifetime = 1.5;\n      \tfloat fParticleSpawnTime = (floor( (fTime / fParticleLifetime) + h3.x) - h3.x) * fParticleLifetime;\n      \tfloat fParticleEndTime = fParticleSpawnTime + fParticleLifetime;\n      \tfloat fParticleGlobalT = fTime - fParticleSpawnTime;\n      \tfloat fParticleT = mod( fParticleGlobalT, fParticleLifetime ) + fDeltaTime;\n  \n  \t\tSequenceInfo sequenceInfo = GetSequenceInfo( fLightIndex, fParticleSpawnTime );\n  \n      \tLightInfo lightInfo;\n  \n  \t\tif ( sequenceInfo.fType < 0.5)\n        {\n          \tfloat fSpread = fract( sequenceInfo.vSequenceHash.z + sequenceInfo.vSequenceHash.y ) + 1.0;\n\t  \t\tlightInfo = Fountain( fLightIndex, sequenceInfo.vPos, fParticleT, sequenceInfo.vCol, fSpread );\n        }\n  \t\telse\n        {\n          \tlightInfo = CatherineWheel( fLightIndex, sequenceInfo.vPos, sequenceInfo.fSequenceStartTime, fParticleSpawnTime, fParticleT, sequenceInfo.vCol );\n        }      \n        \n        return lightInfo;        \n}\n\nLightInfo GetLightInfo( const in float fLightIndex, float fTime, float fDeltaTime, CameraPosition cameraPos )\n{\n  \tLightInfo lightInfo;\n\n  \t//float h = Hash( fLightIndex );\n  \tvec3 h3 = Hash3(fLightIndex);\n\n  \tfloat kHangingLightCount = 32.0;\n  \tfloat kHangingLightMax = 0.0 + kHangingLightCount;\n  \n  \tfloat kStarCount = 0.0;\n  \tfloat kStarMax = kHangingLightMax + kStarCount;\n  \t\n  \tfloat kDirtCount = 16.0;\n  \tfloat kDirtMax = kStarMax + kDirtCount;\n\n  \tfloat kStreetLightCount = 64.0;\n  \tfloat kStreetLightMax = kDirtMax + kStreetLightCount;\n  \n  \tfloat kGardenLightCount = 16.0;\n  \tfloat kGardenLightMax = kStreetLightMax + kGardenLightCount;\n\n  \tif( fLightIndex < kHangingLightMax )\n  \t{\n  \t// hanging lights\n    \tlightInfo.vWorldPos.x = ((fLightIndex / 10.0) * 2.0 - 1.0) * 3.0;\n    \tlightInfo.vWorldPos.y = 2.0 + -abs( cos( fLightIndex * 0.4 ) * 0.8 ); \n    \tlightInfo.vWorldPos.z = 20.0;\n  \t\tlightInfo.vColor = vec3(0.01) * 0.5;\n      \tfloat fColIndex = mod(fLightIndex, 3.0);\n      \tif ( fColIndex == 0.0 ) lightInfo.vColor.x = 1.0;\n      \tif ( fColIndex == 1.0 ) lightInfo.vColor.y = 1.0;\n      \tif ( fColIndex == 2.0 ) lightInfo.vColor.z = 1.0;\n\t      lightInfo.vColor *= 0.05;\n  \t\t//lightInfo.vColor = normalize(vec3(sin(fLightIndex) * .5 + 0.5, sin(fLightIndex * 3.45) * .5 + 0.5, sin(fLightIndex * 4.56) * .5 + 0.5)) * 0.5;\n    \n  \t\tlightInfo.fRadius = 0.05;\n\t}\n  \telse\n  \tif( fLightIndex < kStarMax )\n  \t{\n      // stars\n    \tlightInfo.vWorldPos = normalize( h3 * 2.0 - 1.0 ) * 5000.0;\n    \tlightInfo.vWorldPos.y = abs(lightInfo.vWorldPos.y);\n  \t\tlightInfo.vColor = vec3(0.01);\n  \t\tlightInfo.fRadius = 0.001;\n    }\n  \telse\n  \tif( fLightIndex < kDirtMax )\n  \t{\n      // lens dirt\n    \tlightInfo.vWorldPos.xy = (Hash3(fLightIndex).xy * 2.0 - 1.0);\n      \tlightInfo.vWorldPos.xy = normalize(lightInfo.vWorldPos.xy) * pow( length(lightInfo.vWorldPos.xy), 0.3 ) * 0.35;\n\t    lightInfo.vWorldPos.y *= resolution.y / resolution.x;\n    \tlightInfo.vWorldPos.z = 0.3;\n      \tvec3 vOffset = cameraPos.mRotation * lightInfo.vWorldPos;\n      \tlightInfo.vWorldPos = vOffset + cameraPos.vPosition;\n  \t\tlightInfo.vColor = vec3(0.2, 0.18, 0.1) * abs( dot(normalize(vOffset), vec3(0.0, 0.0, 1.0)) ) * 1.0;\n  \t\tlightInfo.fRadius = 0.0001;\n    }\n  \telse\n  // street lights\n  \tif( fLightIndex < kStreetLightMax )\n  \t{\n      \tlightInfo.vWorldPos.xz = (h3.xy * 2.0 - 1.0) * 500.0;\n    \tlightInfo.vWorldPos.y = 10.0; \n  \t\tlightInfo.vColor = vec3(1.0, 0.3, 0.01) * 0.5;\n    \n  \t\tlightInfo.fRadius = 0.2;\n\t}\n  \telse if( fLightIndex < kGardenLightMax )\n  \t{\n    \tlightInfo.vWorldPos.y = 0.05 + h3.y * 0.5; \n      \tvec2 vOffset = (h3.xz * 2.0 - 1.0);\n      \tlightInfo.vWorldPos.xz = vOffset * 50.0 + normalize( vOffset ) * 10.0;\n  \t\tlightInfo.vColor = sin(h3 * 10.0 + vec3(0.1, 0.2, 0.3)) * 0.5 + 0.5;\n      \tlightInfo.vColor = normalize(lightInfo.vColor);\n\t    lightInfo.vColor *= 0.005;\n    \n  \t\tlightInfo.fRadius = 0.05;\n\t}\n  \telse\n    {\n      \tlightInfo = GetFireworkSparkInfo( fLightIndex, fTime, fDeltaTime, h3 );\n    }\n     \n\n  \treturn lightInfo;\n}\n\n\nvec3 GetCameraTarget( float fTime )\n{\n  \t//return vec3(0.0, 1.8, 0.0);\n\n  \tfloat fInterval = 8.0;\n  \n  \tfloat t0 = floor(fTime / fInterval) * fInterval; \n  \tfloat t1 = (floor(fTime / fInterval+ 1.0) ) * fInterval; \n  \n  \tSequenceInfo inf0 = GetSequenceInfo( 0.0, t0 );\n  \tSequenceInfo inf1 = GetSequenceInfo( 0.0, t1 );\n  \n  \tfloat fBlend = (fTime - t0) / fInterval;\n  \n  \tfBlend = smoothstep( 0.0, 1.0, fBlend);\n  \n  \treturn mix( inf0.vTarget, inf1.vTarget, fBlend );\n}\n\nCameraPosition GetCameraPosition( float fTime, vec2 vTouch )\n{\n  \tCameraPosition cameraPos;\n  \n  \tif(  (vTouch.y > 0.9) && (vTouch.x > -0.83)  && (vTouch.x < -0.80) )\n    {\t\n      \tvTouch.xy = vec2(0.0);\n    }\n  \n  \tcameraPos.vTarget = GetCameraTarget( fTime );\n   \n  \tcameraPos.vPosition += cameraPos.vTarget;\n  \t\n  \tcameraPos.vPosition = vec3( sin(fTime * 0.2) * 5.0, 2.0, -6.0 + sin(fTime * 0.0567) * 3.0);\n  \tcameraPos.vUp = vec3( 0.0, 1.0, 0.0 );\n  \n  \tGetMatrixFromZY( normalize(cameraPos.vTarget - cameraPos.vPosition), cameraPos.vUp, cameraPos.mRotation );\n  \n  \tvec3 vRot = vec3( vTouch.y * 0.5,  vTouch.x  * 0.5, 0.0 );\n  \n#ifdef SHAKY_CAM\n\tvRot += Noise23( cameraPos.vPosition.xz * 4.0 ) * vec3( 0.05, 0.03, 0.01 ); //shaky cam\n#endif\n  \n  \tcameraPos.mRotation = cameraPos.mRotation * RotMatrixZ(vRot.z) * RotMatrixY(vRot.y) * RotMatrixX( vRot.x ) ; \n  \n  \treturn cameraPos;\n}\n\nvoid main() \n{\n  float fVertexIndex = vertexId;\n\n  vec4 touch1 = texture2D(touch, vec2(0.0, 0.0));\n  vec4 touch2 = texture2D(touch, vec2(0.0, 0.01));  \n\n\tfloat fShutterSpeed = 1.0 / 60.0;\n  \n  CameraPosition cameraPos = GetCameraPosition( time, touch1.xy );\n  CameraPosition lastCameraPos = GetCameraPosition( time - fShutterSpeed, touch2.xy );\n\n  CameraSettings cameraSettings = GetCameraSettings( cameraPos );\n\n  OutVertex vertex;\n\n  float fBokehIndex = floor( fVertexIndex / BOKEH_VERTEX_COUNT );\n  \n  LightInfo lightInfo = GetLightInfo( fBokehIndex, time, 0.0, cameraPos );\n  LightInfo prevLightInfo = GetLightInfo( fBokehIndex, time, -fShutterSpeed, lastCameraPos );\n  \n  vec3 vViewPos = GetViewPos( cameraSettings, cameraPos, lightInfo.vWorldPos );\n  vec3 vLastViewPos = GetViewPos( cameraSettings, lastCameraPos, prevLightInfo.vWorldPos );\n\n  vec2 vScreenPos = GetScreenPos( cameraSettings, vViewPos );\n  vec2 vLastScreenPos = GetScreenPos( cameraSettings, vLastViewPos );  \n\n  float fScreenSize = GetScreenPos( cameraSettings, vec3( lightInfo.fRadius, lightInfo.fRadius, vViewPos.z ) ).x;\n  \n  vec2 vOrigin = vScreenPos.xy;\n  vec2 vDir = vLastScreenPos.xy - vScreenPos.xy;\n  \n  float fCoC = GetCoC( cameraSettings, vViewPos.z );\n\n  vec3 vCol = lightInfo.vColor;\n\n  float fSize = fCoC + fScreenSize;\n  vCol *= fScreenSize * fScreenSize * 3.14 / (length( vDir ) * fSize + fSize * fSize * 3.14);\n  \n  float fBokehVertexIndex = mod( fVertexIndex, BOKEH_VERTEX_COUNT );\n  GetBokehVertex( cameraSettings, fBokehVertexIndex, vOrigin, vDir, fScreenSize, fCoC, vCol, vertex );\n  \n  vertex.vPos.y *= resolution.x / resolution.y;\n  \n  gl_Position = vec4(vertex.vPos.x, vertex.vPos.y, 1.0 / vertexId, 1);\n  float fFinalExposure = cameraSettings.fExposure / (cameraSettings.fAperture * cameraSettings.fAperture);\n  v_color.rgb = 1.0 - exp2( vertex.vColor * -fFinalExposure );\n  v_color.rgb = pow( v_color.rgb, vec3(1.0 / 2.2) );\n  v_color.a = 0.0;\n  \n  float fNearClip = 0.25;\n  if ( vViewPos.z <= fNearClip || vLastViewPos.z <= fNearClip)\n  {\n    gl_Position = vec4(0.0);\n    v_color = vec4(0.0);\n  }\n    \n}"
  },
  "screenshotURL": "data/images/images-epsepn196c6cvr6te-thumbnail.jpg",
  "hasSound": "",
  "views": "75",
  "likes": "0",
  "revisionId": "cGgWmHexqAQMxL2Ks"
}