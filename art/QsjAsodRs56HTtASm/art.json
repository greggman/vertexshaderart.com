{
  "_id": "QsjAsodRs56HTtASm",
  "owner": {
    "_id": "GoQyZYs7FujajLiLx",
    "createdAt": {
      "$date": "1485892064893"
    },
    "username": "paul-jan",
    "profile": {
      "avatarUrl": "https://secure.gravatar.com/avatar/40d0673cb04e3c59ed5f9086f215bb8d?default=retro&size=200",
      "info": "Happily running a nice mix of art and technology over at https://www.eponalabs.com\n\nDon't hesitate to contact me if you want to hire me or talk about a collab!"
    }
  },
  "createdAt": {
    "$date": "1485981457799"
  },
  "modifiedAt": {
    "$date": "1485981648558"
  },
  "origId": null,
  "name": "Pixel ... err vertex shader",
  "notes": "",
  "rank": "1.8270630823950982",
  "private": false,
  "unlisted": true,
  "username": "paul-jan",
  "avatarUrl": "https://secure.gravatar.com/avatar/40d0673cb04e3c59ed5f9086f215bb8d?default=retro&size=200",
  "settings": {
    "num": 100,
    "mode": "POINTS",
    "sound": "",
    "lineSize": "NATIVE",
    "backgroundColor": [
      0,
      0,
      0,
      1
    ],
    "shader": "// Based on https://www.shadertoy.com/view/llsXRX\n\n\n// number of samples (for blurring)\n#define NS 2\n\n\n\n//------------ primitives ------------\n\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n\tvec3 pa = p-a, ba = b-a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\treturn length( pa - ba*h ) - r;\n}\n\nfloat sdSphere( in vec3 p, in vec4 s )\n{\n    return length(p-s.xyz) - s.w;\n}\n\nfloat sdEllipsoid( in vec3 p, in vec3 c, in vec3 r )\n{\n    return (length( (p-c)/r ) - 1.0) * min(min(r.x,r.y),r.z);\n}\n\nfloat udRoundBox( vec3 p, vec3 b, float r )\n{\n  return length(max(abs(p)-b,0.0))-r;\n}\n\n//------------ operators ------------\n\nfloat smin( float a, float b, float k )\n{\n\tfloat h = clamp( 0.5 + 0.5*(b-a)/k, 0.0, 1.0 );\n\treturn mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat smax( float a, float b, float k )\n{\n\tfloat h = clamp( 0.5 + 0.5*(b-a)/k, 0.0, 1.0 );\n\treturn mix( a, b, h ) + k*h*(1.0-h);\n}\n\nvec2 minx( in vec2 a, in vec2 b )\n{\n    return (a.x<b.x)?a:b;\n}\n\n//------------ maths ------------\n\nmat4 matRotate( in vec3 xyz )\n{\n    vec3 si = sin(xyz);\n    vec3 co = cos(xyz);\n\n\treturn mat4( co.y*co.z,                co.y*si.z,               -si.y,       0.0,\n                 si.x*si.y*co.z-co.x*si.z, si.x*si.y*si.z+co.x*co.z, si.x*co.y,  0.0,\n                 co.x*si.y*co.z+si.x*si.z, co.x*si.y*si.z-si.x*co.z, co.x*co.y,  0.0,\n\t\t\t     0.0,                      0.0,                      0.0,        1.0 );\n}\n\nmat4 matTranslate( float x, float y, float z )\n{\n    return mat4( 1.0, 0.0, 0.0, 0.0,\n\t\t\t\t 0.0, 1.0, 0.0, 0.0,\n\t\t\t\t 0.0, 0.0, 1.0, 0.0,\n\t\t\t\t x,   y,   z,   1.0 );\n}\n\nmat4 matInverse( in mat4 m )\n{\n\treturn mat4(\n        m[0][0], m[1][0], m[2][0], 0.0,\n        m[0][1], m[1][1], m[2][1], 0.0,\n        m[0][2], m[1][2], m[2][2], 0.0,\n        -dot(m[0].xyz,m[3].xyz),\n        -dot(m[1].xyz,m[3].xyz),\n        -dot(m[2].xyz,m[3].xyz),\n        1.0 );\n}\n\n//--------------------------------------------\n\nfloat hash( float n )\n{\n    return fract(sin(n)*1751.5453);\n}\n\n//--------------------------------------------\n\n\nmat4 mtxHead;\n\nvec2 map( vec3 p )\n{\n    vec3 q = p; q.x = abs(q.x);\n    vec3 hp = (mtxHead*vec4(p,1.0)).xyz;\n\n    // body\n    p.yz = mat2(0.98,-0.2,0.2,0.98)*p.yz;\n    \n    float d1 = sdEllipsoid( p, vec3(0.0,0.15,0.0), vec3(0.41,0.83,0.41) );\n    float d2 = sdSphere( p, vec4(0.0,1.4,0.0,1.2) );\n    float d9 = sdCapsule( q, vec3(0.5,-0.6,0.02), vec3(0.45,0.07,-0.02), 0.15 );\n    float body = smax( d1, -d2, 0.03 );\n    body = smax( body, -d9, 0.01 );\n    \n    \n    // head\n    float d3 = sdSphere( hp, vec4(0.0,0.0,0.0,0.4) );\n    float d4 = sdSphere( hp, vec4(0.0,0.45,0.008,0.65) );\n    float head = smax( d3, d4, 0.05 );\n    // head hole    \n    float d5 = sdEllipsoid( hp, vec3(0.0,0.0,0.4), vec3(0.48,0.3,0.2) );\n    //d5 = smax( d5, sdSphere( hp, vec4(0.0,0.34,0.2, 0.46 )), 0.07 );\n    d5 = smax( d5, sdSphere( hp, vec4(0.0,0.49,0.2, 0.6 )), 0.07 );\n    head = smax( head, -d5, 0.025 );\n    \n    // face\n    float d6 = sdSphere( hp, vec4(0.0,0.04,-0.05,0.41) );\n    float m2 = smax(d6,d5,0.01);\n\n    \n    // arm\n    float d7 = sdEllipsoid( q, vec3(0.5,-0.15,0.0), vec3(0.1,0.35,0.1) );\n    float d8 = sdEllipsoid( q, vec3(0.54,-0.15,0.0), vec3(0.1,0.35,0.1) );\n//    d8 = sdCapsule( q, vec3(0.6,-0.6,0.02), vec3(0.55,0.09,-0.02), 0.15 );\n    d7 = max( d7, d8 );\n    float arm = d7;\n    \n\n    float m1 = min( min( body, head ), arm );\n                        \n    return minx( vec2(m1,0.0),\n                 vec2(m2,1.0) );\n}\n\nvec3 calcNormal( in vec3 pos, in float eps )\n{\n    vec2 e = vec2(1.0,-1.0)*0.5773*eps;\n    return normalize( e.xyy*map( pos + e.xyy ).x + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx ).x + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy ).x + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx ).x );\n}\n\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n\tfloat occ = 0.0;\n    for( int i=0; i<8; i++ )\n    {\n        //float h = 0.01 + 0.22*float(i)/7.0;\n        float h = 0.01 + 0.21*float(i)/7.0;\n        occ += (h-map( pos + h*nor )).x;\n    }\n    return clamp( 1.0 - 5.8*occ/8.0, 0.0, 1.0 );    \n}\n\nfloat calcSoftshadow( in vec3 ro, in vec3 rd, float k )\n{\n    float res = 1.0;\n    float t = 0.01;\n    for( int i=0; i<16; i++ )\n    {\n        float h = map(ro + rd*t ).x;\n        res = min( res, smoothstep(0.0,1.0,k*h/t) );\n        t += clamp( h, 0.04, 0.1 );\n\t\tif( res<0.01 ) break;\n    }\n    return clamp(res,0.0,1.0);\n}\n\n\nvec3 sundir = normalize( vec3(1.0,0.3,-0.5) );\n\nvec3 shade( in vec3 ro, in vec3 rd, in float t, float m )\n{\n    float eps = 0.001;\n    vec3 pos = ro + t*rd;\n    vec3 nor = calcNormal( pos, eps );\n    vec3 ref = reflect( rd, nor );\n    \n    vec3 mate = vec3(1.0,1.0,1.0);\n    \n    if( m<0.5 )\n    {\n        mate = vec3(0.7);\n    }\n\telse\n    {\n        mate = vec3(0.0,0.0,0.0);\n        \n        vec2 uv = (mtxHead * vec4(pos,1.0)).xy;\n        //uv.x += 0.004*sin(500.0*uv.y);\n\n        uv.x = abs(uv.x);\n        uv -= vec2(0.11,0.565-0.5);\n        vec2 st  = uv;\n        uv = mat2(0.9,-0.4,0.4,0.9)*uv;\n        vec3 eye = vec3(0.02,0.2,0.9)*1.9;\n        eye *= 0.9 + 0.1*sin(512.0*st.x + sin(512.0*st.y));\n        \n        float eyesN = 1.0-smoothstep( 0.03, 0.06, length(uv * vec2(0.7,1.0)) );\n        float eyesB = 1.0-smoothstep( 0.00,0.008,abs(st.y));\n        float bl = smoothstep( 0.9,0.91, sin(10.0*time)*sin(3.0*time) );\n        float eyes = mix( eyesN, eyesB, bl );\n        mate = mix( mate, eye, eyes );\n        \n        mate += (0.01+mate)*0.9*smoothstep(-0.1,0.1,sin(st.y*400.0));\n    }\n    \n    vec3 hal = normalize( sundir - rd );\n    \n    float fre = clamp( 1.0 + dot(nor,rd), 0.0, 1.0 );\n    float occ = calcAO( pos, nor );\n\n    float bak = clamp( dot(nor,normalize(vec3(-sundir.x,0.0,-sundir.z))), 0.0, 1.0 );\n    float dif = clamp( dot(nor,sundir), 0.0, 1.0 );\n    //float dif = clamp( dot(nor,lig)*0.8+0.2, 0.0, 1.0 );\n    float spe = clamp( dot(nor,hal), 0.0, 1.0 );\n    float sha = calcSoftshadow( pos, sundir, 8.0 ); \n    dif *= sha;\n\n    vec3 col = 1.4*vec3(1.0,0.9,0.8)*dif +  0.8*vec3(0.2,0.28,0.35)*occ;\n    col += vec3(1.2,1.0,0.8)*fre*(0.3+0.7*dif)*occ*3.5;\n    //col += vec3(1.2,1.0,0.8)*fre*fre*(0.6+0.4*dif)*(0.6+0.4*occ)*2.0;\n    col += vec3(0.4,0.3,0.2)*bak*occ;\n    \n    col *= mate;\n    \n    col += 3.5*vec3(0.3,0.4,0.5) * smoothstep( -0.1, 0.1, ref.y ) * (0.04 + 0.96*pow( fre, 5.0 )) * occ;\n    col += 2.0*vec3(1.0)*pow( spe, 64.0 ) * (0.2 + 0.8*pow( fre, 5.0 )) * (occ*dif);\n    \n    col = pow( col, vec3(0.8,1.0,0.9) );\n\n    col *= mix( vec3(0.3,0.2,0.1), vec3(1.0), smoothstep(-1.0,0.4,pos.y) );\n    return col;        \n}\n\nvec2 intersect( in vec3 ro, in vec3 rd, const float maxdist )\n{\n    vec2 res = vec2(-1.0);\n    vec3 resP = vec3(0.0);\n    float t = 3.0;\n    for( int i=0; i<100; i++ )\n    {\n        vec3 p = ro + t*rd;\n        vec2 h = map( p );\n        res = vec2( t, h.y );\n\n        if( h.x<(0.001*t) || t>maxdist ) break;\n        \n        t += h.x;//*0.5;\n    }\n\treturn res;\n}\n\n//----------------------------------------------------------------------------------\nvec2 mapTerrain( vec3 p )\n{\n    float h = -2.5;\n    h -= 1.5*sin( 5.0 + 0.2*p.z);\n    h += 1.5*sin( 0.0 - 0.05*p.x - 0.05*p.z);\n    float g = h;\n    if( (p.y-h)<0.2 )\n    // h += 0.1*(texture2D( iChannel0, 0.1*p.xz ).x);\n\n    float d1 = 0.2*(p.y-h);\n        \n    // TODO, PJ: WTF ?\n    // vec2 res = vec2( d1, 1.0 );\n    vec2 res = vec2( 1.0, 1.0);\n    \n#if 1   \n    if( -p.z>11.0 )\n    {\n    float ss = 4.0;\n    vec3 q = p;\n    vec2 id = floor( (q.xz+0.5*ss)/ss );\n    q.xz = mod( q.xz+0.5*ss, ss ) - 0.5*ss;\n    \n\n    float r1 = hash(121.11*id.x+id.y*117.4);\n    float r2 = hash( 71.72*id.x+id.y* 61.9);\n    float r3 = hash( 31.74*id.x+id.y*317.1);\n    mat4 rm = matRotate( vec3(1.0*r1,313.13*r2,0.2) );\n    \n    vec3 r = (rm*vec4(q,0.0)).xyz;\n    r.y -= g + 0.25;\n    \n    float d2 = 0.8*udRoundBox( r, vec3(2.,0.01+0.2*r3,0.1+0.5*r3), 0.002 );\n    // TODO, PJ: WTF?\n    // res.x = min( d1, d2 );\n    res.x = 2.0;\n    }\n#endif\n        \n    return res;\n}\n\nvec2 mapTerrainH( vec3 p )\n{\n    float h = -2.5;\n    h -= 1.5*sin( 5.0 + 0.2*p.z);\n    h += 1.5*sin( 0.0 - 0.05*p.x - 0.05*p.z);\n    float g = h;\n    // TODO, PJ: Find a smart alternative\n    // h += 0.1*(texture2D( iChannel0, 0.1*p.xz ).x);\n\n    float d1 = 0.2*(p.y-h);\n        \n    vec2 res = vec2( d1, 1.0 );\n    \n#if 1   \n    if( -p.z>11.0 )\n    {\n    float ss = 4.0;\n    vec3 q = p;\n    vec2 id = floor( (q.xz+0.5*ss)/ss );\n    q.xz = mod( q.xz+0.5*ss, ss ) - 0.5*ss;\n    \n\n    float r1 = hash(121.11*id.x+id.y*117.4);\n    float r2 = hash( 71.72*id.x+id.y* 61.9);\n    float r3 = hash( 31.74*id.x+id.y*317.1);\n    mat4 rm = matRotate( vec3(1.0*r1,313.13*r2,0.2) );\n    \n    vec3 r = (rm*vec4(q,0.0)).xyz;\n    r.y -= g + 0.25;\n    \n    float d2 = 0.8*udRoundBox( r, vec3(2.,0.01+0.2*r3,0.1+0.5*r3), 0.002 );\n    res.x = min( d1, d2 );\n    }\n#endif\n        \n    return res;\n}\n\n\nvec3 calcNormalTerrain( in vec3 pos, in float eps )\n{\n    vec2 e = vec2(1.0,-1.0)*0.5773*eps;\n    return normalize( e.xyy*mapTerrainH( pos + e.xyy ).x + \n\t\t\t\t\t  e.yyx*mapTerrainH( pos + e.yyx ).x + \n\t\t\t\t\t  e.yxy*mapTerrainH( pos + e.yxy ).x + \n\t\t\t\t\t  e.xxx*mapTerrainH( pos + e.xxx ).x );\n}\n\nfloat calcSoftshadowTerrain( in vec3 ro, in vec3 rd, float k )\n{\n    float res = 1.0;\n    float t = 0.01;\n    for( int i=0; i<16; i++ )\n    {\n        float h = mapTerrain(ro + rd*t ).x;\n        res = min( res, smoothstep(0.0,1.0,k*h/t) );\n        t += clamp( h, 0.04, 0.1 );\n\t\tif( res<0.01 ) break;\n    }\n    return clamp(res,0.0,1.0);\n}\n\nvec3 shadeTerrain( in vec3 ro, in vec3 rd, in float t, float m )\n{\n    vec3 pos = ro + rd * t;\n    vec3 nor = calcNormalTerrain( pos, 0.01 );\n    vec3 hal = normalize( sundir - rd );\n    \n    // vec3 col = texture2D( iChannel0, 0.01*pos.xz ).xyz*0.14 * vec3(1.1,1.0,0.9);\n    vec3 col = vec3(0.5, 0.5, 0.5);\n\n    float dif = clamp( dot(sundir,nor), 0.0, 1.0 );\n    float spe = clamp( dot(nor,hal), 0.0, 1.0 );\n    float amb = clamp( 0.3 + 0.7*nor.y, 0.0, 1.0 );\n    //dif *= calcSoftshadowTerrain( pos+nor*0.1, sundir, 32.0 );\n    vec3 lig = dif*vec3(3.0,2.0,1.5)*2.0 + pow(spe,8.0)*3.0*dif*4.0 + vec3(0.5,0.6,1.0)*amb;\n        \n    col *= lig;\n\n    return col;\n}\n    \nvec2 intersectTerrain( in vec3 ro, in vec3 rd, float maxdist )\n{\n    vec2 res = vec2(-1.0);\n    float t = 1.0;\n    \n    for( int i=0; i<256; i++ )\n    {\n        vec3 p = ro + t*rd;\n        vec2 h = mapTerrain( p );\n        res = vec2( t, h.y );\n        if( h.x<(0.001*t) || t>maxdist ) break;\n        t += h.x;\n    }\n    \n    \n\treturn res;\n}\n\n\nvec3 render( in vec3 ro, in vec3 rd )\n{\n    vec3 col = mix( vec3(1.0,1.0,1.0),\n               vec3(0.8,0.6,0.4),\n               sqrt(max(rd.y,0.0)) );\n\n    float sun = clamp( dot(rd,sundir), 0.0, 1.0 );\n    col += 0.9*pow( sun, 64.0 );\n    \n    // terrain\n    float maxdistTerrain = 200.0;\n    float bp = (4.0-ro.y)/rd.y; if( bp>0.0 && bp<maxdistTerrain ) maxdistTerrain = bp;\n    vec2 res = intersectTerrain( ro, rd, maxdistTerrain );\n    float t = res.x;\n    if( t < maxdistTerrain )\n    {\n        col = shadeTerrain( ro, rd, t, res.y );\n    }\n    \n    // eve\n    const float maxdist = 6.5;\n    res = intersect( ro, rd, maxdist );\n    if( res.x < maxdist )\n    {\n        t = res.x;\n        col = shade( ro, rd, t, res.y );\n    }\n\n\n    // fog\n    if( t<maxdistTerrain )\n    {\n        float f = exp(-0.03*t);\n        col *= f;\n        vec3 fcol = mix( vec3(1.0,0.9,0.9), vec3(1.1,0.8,0.4), exp(-0.01*t) );\n        col += (1.0-f)*fcol*0.8;    \n    }\n\n    col += 0.4*pow( sun, 20.0 );\n    \n    return pow( col, vec3(0.45) );\n}\n\nmat3 setCamera( in vec3 ro, in vec3 rt, in float cr )\n{\n\tvec3 cw = normalize(rt-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, -cw );\n}\n\n\nvec3 title( in vec3 col, in vec2 p )\n{\n    return col;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float rt = mod( time, 15.0 );\n    float zo = step( 11.0, rt );\n    float zf = clamp( (rt-11.0)/(15.0-11.0), 0.0, 1.0 );\n\n    float an1 = sin(0.5*time*1.0+0.4)*(1.0-zo);\n    float an2 = sin(0.5*time*1.3+0.0)*(1.0-zo);\n    float an3 = sin(2.0*time);\n    an1 = an1*an1*an1;\n    an2 = an2*an2*an2;\n    \n    mat4 hRot = matRotate( vec3(-0.2*an1*an1*an1 - 0.1*zo,-1.0*an2*an2*an2, 0.0) );\n    mat4 hTra = matTranslate( 0.0,0.5+0.015*an3-0.02*zo,0.11 );\n\n    mtxHead = matInverse( hTra * hRot );\n\n    vec2 q = fragCoord.xy/resolution.xy;\n\n    float an4 = 0.3 + 0.2*sin(0.04*time);\n    vec3 ro = vec3( -5.2*sin(an4), 0.0+0.05*zo, 5.2*cos(an4) );\n    \n    vec3 ta = vec3(0.0,0.2+0.3*zo,0.0);\n    ta += 0.02*cos( 1.0*time + vec3(0.0,2.0,3.0) )*(1.0-0.25*zo);\n    ro += 0.02*cos( 1.0*time + vec3(1.0,3.5,5.0) )*(1.0-0.25*zo);\n    mat3 ca = setCamera( ro, ta, 0.0 );\n    float fl = 1.5 * (2.2 + 2.5*zo*(1.0+0.25*zf));\n    \n\n    vec3 col = vec3(0.0);\n    for( int j=0; j<NS; j++ )\n    for( int i=0; i<NS; i++ )\n    {    \n        vec2 o = (1.0+abs(q.x-0.5)*8.0)*(vec2(float(i),float(j))/float(NS)-0.5);\n        vec2 p = (-resolution.xy+2.0*(fragCoord.xy+o))/resolution.y;\n\n        vec3 rd = normalize( ca * vec3(p,-fl) );\n\n        col += render( ro, rd );\n    }\n    col /= float(NS*NS);\n    \n    // saturate\n    col = mix( col, vec3(dot(col,vec3(0.333))), -0.1 );\n\n    // vignette\n    col *= 0.2 + 0.8*pow(16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y), 0.1 );\n\n    // letterbox\n    col *= 1.0 - smoothstep( 0.4, 0.41, abs(q.y-0.5) );\n\n    // flicker\n    col *= 1.0 + 0.015*fract( 17.1*sin( 13.1*floor(12.0*time) ));\n    \n\n    col = title( col, q );\n    \n    fragColor = vec4( col, 1.0 );\n    //fragColor = vec4(1.0, 1.0, 1.0, 1.0);\n}\n\n\nvoid main() {\n  float across = floor(sqrt(vertexCount));\n  \n  float x = mod(vertexId, across);\n  float y = floor(vertexId / across);\n  \n  float u = x / (across - 1.0);\n  float v = y / (across - 1.0);\n  \n  float xoff = 0.0; //sin(time + 0.2 * y) * 0.1 * 1000. / vertexCount;\n  float yoff = 0.0; //sin(time * 1.1 + 0.3 * x) * 0.2 * 1000. / vertexCount;\n  \n  float ux = 2.0 * u - 1.0 + xoff;\n  float uy = 2.0 * v - 1.0 + yoff;\n  \n  vec2 xy = vec2(ux, uy) * 1.3;\n  \n  float soff = 0.0; // sin(time * 1.2 + x * y * 0.02) * 5.;\n  \n  float hue = 0.5 + 0.1 * u + 0.1 * sin(time * 1.3 + v * 20.);\n  float sat = 0.5;\n  float val = .8 + sin(time * 1.4 + u * v * 20.0) * 0.5;\n  \n  mainImage( v_color, xy * resolution);\n  \n  gl_Position = vec4(xy, 0, 1);\n  gl_PointSize = 20.0 * 20.0 / across + soff;\n  // v_color = vec4(0, 1, 0, 1);\n}"
  },
  "screenshotURL": "data/images/images-6e6qbscq2zj0o2kxp-thumbnail.jpg",
  "hasSound": "",
  "views": "1",
  "likes": "0",
  "revisionId": "WmBCWDgZg54LAAFrh"
}