{
  "_id": "9QBfBKazwRDgwzka8",
  "owner": {
    "_id": "vkPwAHM8PnAebFPxW",
    "createdAt": {
      "$date": 1501857924166
    },
    "profile": {
      "name": "Macro Machines",
      "avatarUrl": "https://lh3.googleusercontent.com/-hZKcNaW8AT0/AAAAAAAAAAI/AAAAAAAAEGM/geaXegN2s9U/photo.jpg",
      "info": "axiom-crux.net macromachines.net"
    },
    "username": "macro"
  },
  "createdAt": {
    "$date": 1510640761436
  },
  "modifiedAt": {
    "$date": 1510640761436
  },
  "origId": "X74uYKiDLZJmqhLnh",
  "name": "Planet Polygon",
  "notes": "",
  "rank": 1.3735684924178415,
  "private": false,
  "unlisted": true,
  "username": "macro",
  "avatarUrl": "https://lh3.googleusercontent.com/-hZKcNaW8AT0/AAAAAAAAAAI/AAAAAAAAEGM/geaXegN2s9U/photo.jpg",
  "settings": {
    "num": 100000,
    "mode": "TRIANGLES",
    "sound": "https://soundcloud.com/feuerhaus/donauwalzer-1",
    "lineSize": "NATIVE",
    "backgroundColor": [
      0.7372549019607844,
      0.7372549019607844,
      0.7372549019607844,
      1
    ],
    "shader": "// Planet Polygon - @P_Malin\n\n// Switch the primitive type to LINES to see how the background sun flare is rendered!\n\nfloat g_cameraFar = 2000.0;\nvec3 g_sunColor = vec3( 1.0, 0.8, 0.5 ) * 100.0;\n\n\n#define PI radians( 180.0 )\n\nvec3 GetSunPosition()\n{\n  \tfloat fSunDistance = 14000.0;\n  \treturn vec3( 0.0, 0.1, 1.0 ) * fSunDistance;\n}\n\nvec3 GetSunDir( vec3 vCameraPos )\n{\n  \treturn normalize( GetSunPosition() - vCameraPos );\n}\n\nfloat GetCosSunRadius( vec3 vCameraPos )\n{\n  \tfloat d = length( vCameraPos - GetSunPosition() );\n  \treturn 100.0 / d;\n}\n\nfloat GetSunIntensity( vec3 vCameraPos )\n{\n  \tfloat d = length( vCameraPos - GetSunPosition() );\n  \treturn 1000.0 / (d * d);\n}\n\nvoid GetQuadInfo( const float vertexIndex, out vec2 quadVertId, out float quadId )\n{\n    float twoTriVertexIndex = mod( vertexIndex, 6.0 );\n    float triVertexIndex = mod( vertexIndex, 3.0 );\n  \n    if \t\t( twoTriVertexIndex < 0.5 ) quadVertId = vec2( 0.0, 0.0 );\n    else if\t( twoTriVertexIndex < 1.5 )\tquadVertId = vec2( 1.0, 0.0 );\n    else if ( twoTriVertexIndex < 2.5 )\tquadVertId = vec2( 0.0, 1.0 );\n    else if ( twoTriVertexIndex < 3.5 )\tquadVertId = vec2( 1.0, 0.0 );\n    else if ( twoTriVertexIndex < 4.5 )\tquadVertId = vec2( 1.0, 1.0 );\n    else \t\t\t\t\t\t\t\tquadVertId = vec2( 0.0, 1.0 );\n\n    quadId = floor( vertexIndex / 6.0 );\n}\n\n\nvoid GetQuadTileInfo( const vec2 quadVertId, const float quadId, const vec2 vDim, out vec2 vQuadTileIndex, out vec2 vQuadUV )\n{\n    vQuadTileIndex.x = floor( mod( quadId, vDim.x ) );\n    vQuadTileIndex.y = floor( quadId / vDim.x );\n\n  \tvQuadUV.x = floor(quadVertId.x + vQuadTileIndex.x);\n    vQuadUV.y = floor(quadVertId.y + vQuadTileIndex.y);\n\n    vQuadUV = vQuadUV * (1.0 / vDim);\n}\n\n\nvoid GetQuadTileInfo( const float vertexIndex, const vec2 vDim, out vec2 vQuadTileIndex, out vec2 vQuadUV )\n{\n  \tvec2 quadVertId;\n  \tfloat quadId;\n\tGetQuadInfo( vertexIndex, quadVertId, quadId );  \n  \tGetQuadTileInfo( quadVertId, quadId, vDim, vQuadTileIndex, vQuadUV );   \n}\n\n\nstruct SurfaceInfo\n{\n\tvec3 vPos;\n  \tvec3 vNormal;\n\tfloat fGloss;\n};\n\nvoid AddDirectionalLight( vec3 vLightDir, vec3 vLightColor, const SurfaceInfo surfaceInfo, const vec3 vCameraPos, inout vec3 vDiffuse, inout vec3 vSpecular )\n{\n  vec3 vViewDir = normalize(vCameraPos-surfaceInfo.vPos);\n  \n  float NdotL = max( 0.0, dot( vLightDir, surfaceInfo.vNormal ) );\n  \n  vec3 vHalfAngle = normalize( vViewDir + vLightDir );\n\n  float NdotH = max( 0.0, dot( vHalfAngle, surfaceInfo.vNormal ) );\n  \n  vDiffuse += NdotL * vLightColor;\n\n  float fPower = surfaceInfo.fGloss;\n  vSpecular += pow( NdotH, fPower ) * 2.0 * NdotL * vLightColor;\n}\n\n\n\n\nvec3 LightSurface( const SurfaceInfo surfaceInfo, const vec3 vCameraPos, const vec3 vAlbedo, float fShadow )\n{   \n  vec3 vDiffuseLight = vec3(0.0);\n  vec3 vSpecLight = vec3(0.0);\n\n  AddDirectionalLight( GetSunDir(vCameraPos), g_sunColor * 0.01 * fShadow, surfaceInfo, vCameraPos, vDiffuseLight, vSpecLight );\n  \n  vec3 vViewDir = normalize(vCameraPos-surfaceInfo.vPos);\n  \n  float fNdotD = clamp(dot(surfaceInfo.vNormal, vViewDir), 0.0, 1.0);\n  vec3 vR0 = vec3(0.04);\n  vec3 vFresnel = vR0 + (1.0 - vR0) * pow(1.0 - fNdotD, 5.0);  \n  \n  vec3 vColor = mix( vDiffuseLight * vAlbedo, vSpecLight, vFresnel );\n  \n  return vColor;\n}\n\nvec3 PostProcess( vec3 vColor, float fExposure )\n{\n  vColor = vec3(1.0) - exp2( vColor * -fExposure );\n\n  vColor = pow( vColor, vec3(1.0 / 2.2) );\n\n  return vColor;\n}\n\nvec3 ApplyVignetting( const in vec2 vUV, const in vec3 vInput )\n{\n\tvec2 vOffset = (vUV - 0.5) * sqrt(2.0);\n\t\n\tfloat fDist = dot(vOffset, vOffset);\n\t\n\tconst float kStrength = 0.95;\n\tconst float kPower = 1.5;\n\n\treturn vInput * ((1.0 - kStrength) +  kStrength * pow(max(0.0, 1.0 - fDist), kPower));\n}\n\n\nstruct SceneVertex\n{\n  \tvec3 vWorldPos;\n  \tvec3 vColor;\n\tfloat fAlpha;\n};\n\n\n\nvoid GetMatrixFromZY( const vec3 vZ, const vec3 vY, out mat3 m )\n{\n   vec3 vX = normalize( cross( vY, vZ ) );\n   vec3 vOrthoY = normalize( cross( vZ, vX ) );\n   m[0] = vX;\n   m[1] = vOrthoY;\n   m[2] = vZ;\n}\n\nvoid GetMatrixFromZ( vec3 vZAxis, out mat3 m )\n{\n  \tvec3 vZ = normalize(vZAxis);\n   \tvec3 vY = vec3( 0.0, 1.0, 0.0 );\n  \tif ( abs(vZ.y) > 0.99 )\n    {\n       vY = vec3( 1.0, 0.0, 0.0 );\n    }\n  \tGetMatrixFromZY( vZ, vY, m );\n}\n\nvec3 GetBackdropColor( vec3 vViewDir, vec3 vCameraPos )\n{\n  \tfloat VdotL = dot( normalize(vViewDir), GetSunDir(vCameraPos) );\n  \n  \tVdotL = clamp( VdotL, 0.0, 1.0 );\n  \n  \tfloat fShade = 0.0;\n\n  \tfShade = acos( VdotL ) * (1.0 / PI);\n  \n  \tfloat fCosSunRadius = GetCosSunRadius(vCameraPos);\n  \n  \tfShade = max( 0.0, (fShade - fCosSunRadius) / (1.0 - fCosSunRadius) );    \n  \n  \tfShade = GetSunIntensity( vCameraPos ) / pow(fShade, 1.5);\n  \n    return vec3( fShade * g_sunColor );    \n}\n\n#define g_backdropSegments \t\t\t32.0\n#define g_backdropSlices \t\t\t32.0\n#define g_backdropQuads \t\t\t( g_backdropSegments * g_backdropSlices )\n#define g_backdropVertexCount \t\t( g_backdropQuads * 6.0 )\n\nvoid GenerateBackdropVertex( const float vertexIndex, const vec3 vCameraPos, out SceneVertex outSceneVertex )\n{\n    vec2 vBackdropDim = vec2( g_backdropSegments, g_backdropSlices );\n    \n  \tvec2 vQuadTileIndex;\n    vec2 vUV;  \n  \tGetQuadTileInfo( vertexIndex, vBackdropDim, vQuadTileIndex, vUV );\n\n    float fSlicePos = 0.0;\n  \n  \tfloat fSunMeshPinch = 5.0;\n  \n  \tif (vUV.y > 0.0)\n    {\n      \tfloat t = pow( vUV.y, fSunMeshPinch );\n  \t\tfloat fCosSunRadius = GetCosSunRadius(vCameraPos);\n      \tfSlicePos = fCosSunRadius + t * (1.0- fCosSunRadius);\n    }\n    \n  \tvec3 vSpherePos;\n  \tfloat fElevation = fSlicePos * PI;\n  \tvSpherePos.z = cos( fElevation );\n\n  \tfloat fHeading = vUV.x * PI * 2.0;\n  \tfloat fSliceRadius = sqrt( 1.0 - vSpherePos.z * vSpherePos.z );\n  \tvSpherePos.x = sin( fHeading ) * fSliceRadius;\n  \tvSpherePos.y = cos( fHeading ) * fSliceRadius;\n  \n\tmat3 m;\n  \n  \tGetMatrixFromZ( GetSunDir(vCameraPos), m );\n    \n  \tvec3 vLocalSpherePos = m * vSpherePos;\n\n  \tfloat fBackdropDistance = g_cameraFar; \n  \tvec3 vWorldSpherePos = vLocalSpherePos * fBackdropDistance;\n\n  \tvWorldSpherePos += vCameraPos;\n  \n    outSceneVertex.vWorldPos = vWorldSpherePos;\n      \n  \toutSceneVertex.vColor = GetBackdropColor( vLocalSpherePos, vCameraPos );\n\n  \toutSceneVertex.fAlpha = 1.0;\n}  \n\n// From Shadertoy \"Hash without sine - Dave Hoskins\"\n// https://www.shadertoy.com/view/4djSRW\n#define MOD3 vec3(.1031,.11369,.13787)\n#define MOD4 vec4(.1031,.11369,.13787, .09987)\nfloat hash11(float p)\n{\n\tvec3 p3  = fract(vec3(p) * MOD3);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nvec4 hash41(float p)\n{\n\tvec4 p4 = fract(vec4(p) * MOD4);\n    p4 += dot(p4, p4.wzxy+19.19);\n    return fract(vec4((p4.x + p4.y)*p4.z, (p4.x + p4.z)*p4.y, (p4.y + p4.z)*p4.w, (p4.z + p4.w)*p4.x));\n    \n}\n\nfloat SmoothNoise(in vec2 o) \n{\n\tvec2 p = floor(o);\n\tvec2 f = fract(o);\n\t\t\n\tfloat n = p.x + p.y*57.0;\n\n\tfloat a = hash11(n+  0.0);\n\tfloat b = hash11(n+  1.0);\n\tfloat c = hash11(n+ 57.0);\n\tfloat d = hash11(n+ 58.0);\n\t\n\tvec2 f2 = f * f;\n\tvec2 f3 = f2 * f;\n\t\n\tvec2 t = 3.0 * f2 - 2.0 * f3;\n\t\n\tfloat u = t.x;\n\tfloat v = t.y;\n\n\tfloat res = a + (b-a)*u +(c-a)*v + (a-b+d-c)*u*v;\n    \n    return res;\n}\n\n#define k_fmbSteps 10\nfloat FBM( vec2 p, float repeat, float ps ) {\n\tfloat f = 0.0;\n    float tot = 0.0;\n    float a = 1.0;  \t\n    for( int i=0; i<k_fmbSteps; i++)\n    {\n        f += SmoothNoise( fract(p / repeat) * repeat ) * a;\n        p *= 2.0;\n        tot += a;\n        a *= ps;\n    }\n    return f / tot;\n}\n\n#define g_starCount \t\t\t\t3000.0\n#define g_starSegments\t\t\t\t6.0\n#define g_verticesPerStar\t\t\t( g_starSegments * 3.0 )\n#define g_starVertexCount \t\t\t( g_starCount * g_verticesPerStar )\n\nvoid GenerateStarVertex( const float vertexIndex, const vec3 vCameraPos, out SceneVertex outSceneVertex )\n{\n\tfloat fStarIndex = floor( vertexIndex / g_verticesPerStar );\n\n  \tvec4 vRandom = hash41(fStarIndex);  \n  \tvec3 vStarPos = normalize( vRandom.xyz * 2.0 - 1.0 );\n\n    float fBrightness = 0.25 / (0.5 + vRandom.w * 20.0);\n  \n  \tfloat fStarVertexIndex = mod( vertexIndex, g_verticesPerStar );\n  \tfloat fSegmentIndex = floor( fStarVertexIndex / 3.0 );\n  \tfloat fTriVertexIndex = mod( fStarVertexIndex, 3.0 );\n    \n  \tfloat fAngle0 = (fSegmentIndex + 0.0) * PI * 2.0 / g_starSegments;\n  \tfloat fAngle1 = (fSegmentIndex + 1.0) * PI * 2.0 / g_starSegments;\n  \n  \tvec3 vData;\n  \n  \tif ( fTriVertexIndex < 0.5 )  \t\tvData = vec3( 0.0, 0.0, 1.0 );\n    else if ( fTriVertexIndex < 1.5 )  \tvData = vec3( sin(fAngle0), cos(fAngle0), 0.0 );\n  \telse \t\t\t\t\t\t\t\tvData = vec3( sin(fAngle1), cos(fAngle1), 0.0 );\n      \n  \tfloat fSize = 15.0;\n    vec3 vOffset = vec3( vData.x, vData.y, 0.0 ) * fSize;\n    float fAlpha = vData.z;\n\n  \tmat3 m;\n  \tGetMatrixFromZ( vStarPos, m );\n            \n    outSceneVertex.vWorldPos = m * vOffset;\n    outSceneVertex.vWorldPos += vStarPos * (g_cameraFar - 200.0);\n  \toutSceneVertex.vWorldPos += vCameraPos;\n  \n    vec3 vBackdropColor = GetBackdropColor(outSceneVertex.vWorldPos - vCameraPos, vCameraPos);\n      \n\n  \toutSceneVertex.vColor = vBackdropColor + fAlpha * fBrightness;\n\n  \toutSceneVertex.fAlpha = 1.0;\n}\n\nstruct PlanetInfo\n{\n\tvec3 vSurfaceColor0;\n\tvec3 vSurfaceColor1;\n  \tfloat textureScale;\n    float texturePersistence;\n  \tfloat surfaceType;\n  \n  \tvec3 vRingColor0;\n\tvec3 vRingColor1;\n  \tbool hasRings;\n  \n  \tvec3 vOrigin;\n  \tfloat fRadius;\n  \n  \tfloat fSegments;\n  \tfloat fSlices;\n  \n  \tint iMoonCount;\n};\n  \nvec3 PlanetPosToWorld( PlanetInfo planetInfo, vec3 vPos )\n{\n\treturn planetInfo.vOrigin + vPos;\n}\n\nvec3 PlanetNormalToWorld( PlanetInfo planetInfo, vec3 vNormal )\n{\n\treturn vNormal;\n}\n\n\nfloat GetPlanetQuadCount( PlanetInfo planetInfo )\n{\n  \treturn planetInfo.fSegments * planetInfo.fSlices;\n}\n\nfloat GetPlanetVertexCount( PlanetInfo planetInfo )\n{\n  \treturn GetPlanetQuadCount( planetInfo ) * 6.0;\n}\n\nvoid GeneratePlanetVertex( const float vertexIndex, const vec3 vCameraPos, PlanetInfo planetInfo, out SceneVertex outSceneVertex )\n{\n    vec2 vDim = vec2( planetInfo.fSegments, planetInfo.fSlices );\n    \n  \tvec2 vQuadTileIndex;\n    vec2 vUV;  \n  \tGetQuadTileInfo( vertexIndex, vDim, vQuadTileIndex, vUV );\n\n  \tvec3 vSpherePos;\n  \tfloat fElevation = vUV.y * PI;\n  \tvSpherePos.y = cos( fElevation );\n\n  \tfloat fHeading = vUV.x * PI * 2.0;\n  \tfloat fSliceRadius = sqrt( 1.0 - vSpherePos.y * vSpherePos.y );\n  \tvSpherePos.x = sin( fHeading ) * fSliceRadius;\n  \tvSpherePos.z = cos( fHeading ) * fSliceRadius;\n  \n  \tvec3 vPlanetNormal = normalize( vSpherePos );  \n  \tvec3 vPlanetSpherePos = vSpherePos * planetInfo.fRadius;\n\n  \tvec3 vWorldNormal = PlanetNormalToWorld( planetInfo, vPlanetNormal );\n    outSceneVertex.vWorldPos = PlanetPosToWorld( planetInfo, vPlanetSpherePos );\n  \n  \tfloat fBandPos = cos( fElevation ) * 0.5 + 0.5;\n  \n  \tfloat fBandBlend = (sin(fElevation * 50.0 * fBandPos) + sin( fElevation * 3.0) * 0.1)  * 0.25 + 0.5;\n  \n  \tfloat fFBMBlend = FBM( vUV * planetInfo.textureScale, planetInfo.textureScale, planetInfo.texturePersistence );\n  \tfloat fBlend = mix( fBandBlend, fFBMBlend, planetInfo.surfaceType );//fBandBlend;\n  \n  \tfBlend = fBlend * fBlend;\n  \tvec3 vAlbedo = mix( planetInfo.vSurfaceColor0, planetInfo.vSurfaceColor1, fBlend );\n  \n  \n  \tvec3 vDiffuse = vec3(0.0);\n  \tvec3 vSpecular = vec3(0.0);\n  \n  \tSurfaceInfo surfaceInfo;\n  \tsurfaceInfo.vPos = outSceneVertex.vWorldPos;\n  \tsurfaceInfo.vNormal = vWorldNormal;\n  \tsurfaceInfo.fGloss = 5.0;\n\n    outSceneVertex.vColor = LightSurface( surfaceInfo, vCameraPos, vAlbedo, 1.0 );\n\n  \toutSceneVertex.fAlpha = 1.0;\n}\n\nfloat GetPlanetShadow( vec3 vPos, vec3 vCameraPos, PlanetInfo planetInfo )\n{ \n  \tfloat fShadowAttn = 1.0;\n  \n  \tvec3 vSphereOrigin = PlanetPosToWorld( planetInfo, vec3(0.0) );\n  \tfloat fSphereRadius = planetInfo.fRadius;\n  \n  \tvec3 vRayOrigin = vPos;\n  \tvec3 vRayDir = GetSunDir(vCameraPos);  \n\t\n\tvec3 vToOrigin = vSphereOrigin - vRayOrigin;\n\tfloat fProjection = dot(vToOrigin, vRayDir);\n\tvec3 vClosest = vRayOrigin + vRayDir * fProjection;\n\t\n\tvec3 vClosestToOrigin = vClosest - vSphereOrigin;\n\tfloat fClosestDist2 = dot(vClosestToOrigin, vClosestToOrigin);\n\n\tfloat fSphereRadius2 = fSphereRadius * fSphereRadius;\n\t\n\tif(fClosestDist2 < fSphereRadius2)\n\t{\n\t\tfloat fHCL = sqrt(fSphereRadius2 - fClosestDist2);\n\n\t\tfloat fMinDist = fProjection - fHCL;\n\t\n      \tif ( (fMinDist >= 0.0) && (fMinDist < 100.0 ) )\n        {\n          \tfShadowAttn = (fClosestDist2 - fSphereRadius2) + 10.0;\n          \tfShadowAttn *= 0.025;\n          \tfShadowAttn = clamp( fShadowAttn, 0.0, 1.0);\n        }\n\t}  \n  \n  \treturn fShadowAttn;\n}\n\n#define g_ringSegments \t\t\t128.0\n#define g_ringQuads \t\t\t( g_ringSegments * 3.0 )\n#define g_ringVertexCount \t\t( g_ringQuads * 6.0 )\n\nvoid GenerateRingVertex( const float vertexIndex, const vec3 vCameraPos, PlanetInfo planetInfo, out SceneVertex outSceneVertex, float fInnerRadius, float fOuterRadius, float fRandom )\n{\n    vec2 vDim = vec2( g_ringSegments, 3 );\n    \n  \tvec2 vQuadTileIndex;\n    vec2 vUV;  \n  \tGetQuadTileInfo( vertexIndex, vDim, vQuadTileIndex, vUV );\n\n  \tvec3 vRingPos;\n\n  \tfloat fHeading = vUV.x * PI * 2.0;\n  \n  \tfloat fRadiusPos = vUV.y;\n  \n  \tif( vUV.y < 0.5 ) fRadiusPos = 0.0; else  fRadiusPos = 1.0;\n\n  \n  \tfloat fRadius = fInnerRadius + fRadiusPos * (fOuterRadius - fInnerRadius);\n\n  \tif ( vUV.y < 0.01 ) fRadius-= 0.02;\n  \tif ( vUV.y > 0.99 ) fRadius+= 0.02;\n  \n  \tvRingPos.y = 0.0;\n  \tvRingPos.x = sin( fHeading ) * fRadius;\n  \tvRingPos.z = cos( fHeading ) * fRadius;\n  \n    outSceneVertex.vWorldPos = PlanetPosToWorld( planetInfo, vRingPos );\n  \n  \tfloat fShadow = GetPlanetShadow( outSceneVertex.vWorldPos, vCameraPos, planetInfo );\n  \n  \tfloat fAlpha = ( fRandom * 0.5 + 0.5);\n\tfAlpha = fAlpha * fAlpha;\n  \n  \tvec3 vAlbedo = mix( planetInfo.vRingColor0, planetInfo.vRingColor1, fRandom );\n  \n   \tSurfaceInfo surfaceInfo;\n  \tsurfaceInfo.vPos = outSceneVertex.vWorldPos;\n  \tsurfaceInfo.vNormal = PlanetNormalToWorld( planetInfo, vec3(0.0, 1.0, 0.0) );\n  \tsurfaceInfo.fGloss = 20.0;\n\n    outSceneVertex.vColor = LightSurface( surfaceInfo, vCameraPos, vAlbedo, fShadow );\n\n  \t// Hack lighting from other side\n  \tvec3 vCameraDir = vCameraPos - surfaceInfo.vPos;\n  \tvCameraDir = reflect( vCameraDir, surfaceInfo.vNormal );\n  \tvec3 otherSideCameraPos = vCameraDir + surfaceInfo.vPos;\n    outSceneVertex.vColor += LightSurface( surfaceInfo, otherSideCameraPos, vAlbedo, fShadow ) * 0.1;\n\n   \tfAlpha *= 1.0 - abs( vUV.y * 2.0 - 1.0 );\n  \n  \tfloat NdotV = normalize(vCameraPos).y;\n  \tfAlpha = mix( fAlpha, 1.0, exp2( abs(NdotV) * -5.0 ) );\n  \n  \toutSceneVertex.fAlpha = fAlpha;\n}  \n\n\nvoid main()\n{ \n  \tSceneVertex sceneVertex;\n  \n  \tvec2 vMouse = mouse;\n  \tfloat orbitAngle = time * 0.4 + 2.5;\n  \n  \tfloat fov = 1.5;\n  \n  \tfloat fMouseX = (vMouse.x * 0.5 + 0.5);\n  \tfMouseX = fMouseX * fMouseX;\n  \n  \tPlanetInfo planetInfo;\n  \n#if 1\n  \tplanetInfo.vSurfaceColor0 = vec3(0.36, 0.16, 0.0001);\n  \tplanetInfo.vSurfaceColor1 = vec3(1.0, 0.36, 0.000001);\n  \n  \tplanetInfo.textureScale = 100.0;\n    planetInfo.texturePersistence = 0.5;\n  \tplanetInfo.surfaceType = 0.3;\n  \n  \n  \tplanetInfo.vRingColor0 = vec3(1.0, 0.64, 0.09);\n  \tplanetInfo.vRingColor1 = vec3(0.36, 0.16, 0.0001);\n  \n  \tplanetInfo.hasRings = true;\n  \n  \tplanetInfo.vOrigin = vec3(0.0);\n  \tplanetInfo.fRadius = 5.0;\n  \n  \tplanetInfo.fSegments = 32.0;\n  \tplanetInfo.fSlices = 48.0;\n  \n  \tplanetInfo.iMoonCount = 10;\n#else\n  \tplanetInfo.vSurfaceColor0 = vec3(0.01, 0.01, 0.5);\n  \tplanetInfo.vSurfaceColor1 = vec3(0.01, 1.0, 0.01);\n  \n  \tplanetInfo.textureScale = 16.0;\n    planetInfo.texturePersistence = 0.5;\n  \tplanetInfo.surfaceType = 0.8;\n  \n  \n  \tplanetInfo.vRingColor0 = vec3(1.0, 0.64, 0.09);\n  \tplanetInfo.vRingColor1 = vec3(0.36, 0.16, 0.0001);\n  \n  \tplanetInfo.hasRings = false;\n  \n  \tplanetInfo.vOrigin = vec3(0.0);\n  \tplanetInfo.fRadius = 0.1;\n  \n  \tplanetInfo.fSegments = 32.0;\n  \tplanetInfo.fSlices = 48.0;\n  \n  \tplanetInfo.iMoonCount = 1;\n#endif    \n  \n  \tfloat fOrbitDistance = (planetInfo.fRadius * 2.0) + exp2( fMouseX * 20.0 );\n  \n  \tvec3 vCameraPos = vec3( sin(orbitAngle), 0.2 + vMouse.y * 0.5, cos(orbitAngle) ) * fOrbitDistance;\n  \tvec3 vCameraTarget = vec3( 0.0, planetInfo.fRadius * 0.2, 0.0 );\n  \tvec3 vCameraUp = vec3( 0.1, 1.0, 0.0 );\n  \n  \tif( false )\n    {\n      vCameraPos = vec3( 10.0, 8.0, 30.0 );\n      vCameraTarget = vec3( 0.0, 0.0, 0.0 );\n      vCameraUp = vec3( 0.0, 1.0, 0.0);\n    }\n  \n  \tvec3 vCameraForwards = normalize(vCameraTarget - vCameraPos);\n  \n  \tmat3 mCamera;\n    GetMatrixFromZY( vCameraForwards, normalize(vCameraUp), mCamera );\n  \n  \tfloat vertexIndex = vertexId;\n  \n  \t// Backdrop\n  \tif ( vertexIndex >= 0.0 && vertexIndex < g_backdropVertexCount )\n    {\n    \tGenerateBackdropVertex( vertexIndex, vCameraPos, sceneVertex );\n    }\n  \tvertexIndex -= g_backdropVertexCount;\n\n  \t// Stars\n  \tif ( vertexIndex >= 0.0 && vertexIndex < g_starVertexCount )\n    {\n    \tGenerateStarVertex( vertexIndex, vCameraPos, sceneVertex );\n    }\n  \tvertexIndex -= g_starVertexCount;\n  \n  \t// Planet\n  \tfloat fPlanetVertexCount = GetPlanetVertexCount(planetInfo);\n  \tif ( vertexIndex >= 0.0 && vertexIndex < fPlanetVertexCount )\n    {\n    \tGeneratePlanetVertex( vertexIndex, vCameraPos, planetInfo, sceneVertex );\n    }\n  \tvertexIndex -= fPlanetVertexCount;\n\n  \t// Moon  \n  \tconst int kMaxMoonCount = 5;\n  \tfloat fMoonDist = planetInfo.fRadius * 6.0;\n  \tfor( int moonIndex=0; moonIndex < kMaxMoonCount; moonIndex++ )\n    {\n      \tif(moonIndex < planetInfo.iMoonCount)\n        {\n          PlanetInfo moonInfo;\n\n          moonInfo.vSurfaceColor0 = vec3(0.7);\n          moonInfo.vSurfaceColor1 = vec3(0.5);\n\n          moonInfo.textureScale = 100.0;\n          moonInfo.texturePersistence = 0.5;\n          moonInfo.surfaceType = 0.9;\n\n\n          moonInfo.vRingColor0 = vec3(1.0, 0.64, 0.09);\n          moonInfo.vRingColor1 = vec3(0.36, 0.16, 0.0001);\n\n          moonInfo.hasRings = false;\n\n          float fAngle = hash11(fMoonDist) * 12.345 + time * 0.1 / fMoonDist;\n          moonInfo.vOrigin = vec3(sin(fAngle), 0.0, cos(fAngle)) * fMoonDist;\n          moonInfo.fRadius = planetInfo.fRadius * 0.025;\n          fMoonDist = fMoonDist * 1.8;\n\n          moonInfo.fSegments = 16.0;\n          moonInfo.fSlices = 16.0;\n\n          moonInfo.iMoonCount = 0;\n          \n          float fMoonVertexCount = GetPlanetVertexCount(moonInfo);\n          if ( vertexIndex >= 0.0 && vertexIndex < fMoonVertexCount )\n          {\n              GeneratePlanetVertex( vertexIndex, vCameraPos, moonInfo, sceneVertex );\n          }\n          vertexIndex -= fMoonVertexCount;\n          \n        }      \n    }\n  \n  \n  \t// Ring\n  \tif ( planetInfo.hasRings )\n    {\n      float fRingInner = 8.0;\n      float fRingSize = 2.0;\n      float fRingSeed = 0.0;  \t\n      for ( int ringIndex = 0; ringIndex < 6; ringIndex++ )\n      {\n        if ( vertexIndex >= 0.0 && vertexIndex < g_ringVertexCount )\n        {\n            GenerateRingVertex( vertexIndex, vCameraPos, planetInfo, sceneVertex, fRingInner, fRingInner + fRingSize, hash11(fRingInner) );\n        }\n        vertexIndex -= g_ringVertexCount;\n\n        fRingInner += fRingSize;\n        fRingInner += 0.02 + (sin( fRingSeed * 123.432 ) * 0.5 + 0.5) * 0.25;\n        float fSizeRandom = sin( fRingSeed * 423.432 ) * 0.5 + 0.5;\n        fRingSize = 0.1 + fSizeRandom * fSizeRandom * 2.0;\n        fRingSeed += 1.0;\n      }\n    }\n    \n  \tif ( vertexIndex >= 0.0 )\n    {\n      sceneVertex.vWorldPos = vec3(0.0);\n      sceneVertex.vColor = vec3(0.0);\n      sceneVertex.fAlpha = 0.0;\n    }\n\n    // Fianl output position\n\tvec3 vViewPos = sceneVertex.vWorldPos;\n    vViewPos -= vCameraPos;\n  \tvViewPos =  vViewPos * mCamera;\n  \t\n  \tvec2 vFov = vec2( 1.0, resolution.x / resolution.y ) * fov;\n  \tvec2 vScreenPos = vViewPos.xy * vFov;\n\n\tgl_Position = vec4( vScreenPos.xy, -1.0, vViewPos.z );\n  \n  \t// Final output color\n  \tvec3 vFinalColor = sceneVertex.vColor;\n  \n  \tvFinalColor = ApplyVignetting( (gl_Position.xy / gl_Position.w) * 0.5 + 0.5, vFinalColor );  \n  \n  \tfloat VdotL = dot( vCameraForwards, -GetSunDir(vCameraPos) );\n  \n  \t// Adjust exposure if we are looking towards the sun\n  \tfloat fExposure = (0.5 + VdotL * 0.5) * 5.0;\n  \n  \tfExposure /= GetSunIntensity( vCameraPos ) * 100000.0;\n  \n  \tfExposure += 0.5;\n  \n  \tfExposure *= min( 1.0, time / 5.0 );\n  \n  \tvFinalColor = PostProcess( vFinalColor, fExposure );\n  \n  \tv_color = vec4(vFinalColor * sceneVertex.fAlpha, sceneVertex.fAlpha);  \n}\n"
  },
  "screenshotURL": "data/images/images-u32rohw6qzdepbopb-thumbnail.jpg",
  "hasSound": true,
  "views": 3,
  "likes": 0,
  "revisionId": "4GniX5DQnPkCSHkac"
}