{
  "_id": "oJEAooRzirpb8qcPe",
  "owner": {
    "_id": "tFSGYdMSg7J6WsAhF",
    "createdAt": {
      "$date": {
        "$numberLong": "1450381162182"
      }
    },
    "username": "aiekick",
    "profile": {
      "avatarUrl": "https://secure.gravatar.com/avatar/9423fa0d99c42e44e2b7d18c6f88b041?default=retro&size=200"
    }
  },
  "createdAt": {
    "$date": {
      "$numberLong": "1535737942011"
    }
  },
  "modifiedAt": {
    "$date": {
      "$numberLong": "1535911445716"
    }
  },
  "origId": "evAAwbGtYJLZKPkMq",
  "name": "ShaderDough",
  "notes": "conversion from tdhooper shader\nhttps://www.shadertoy.com/view/4tc3WB",
  "rank": {
    "$numberDouble": "10.075996905646344"
  },
  "private": false,
  "unlisted": false,
  "username": "aiekick",
  "avatarUrl": "https://secure.gravatar.com/avatar/9423fa0d99c42e44e2b7d18c6f88b041?default=retro&size=200",
  "settings": "{\"num\":100000,\"mode\":\"POINTS\",\"sound\":\"\",\"lineSize\":\"NATIVE\",\"backgroundColor\":[0.14901960784313725,0.0392156862745098,0.21176470588235294,1],\"shader\":\"/////////////////////////////////////////////////////////////////////\\n/// https://github.com/glslify/glsl-inverse/blob/master/index.glsl //\\n/////////////////////////////////////////////////////////////////////\\n\\nmat3 inverse(mat3 m) {\\n  float a00 = m[0][0], a01 = m[0][1], a02 = m[0][2];\\n  float a10 = m[1][0], a11 = m[1][1], a12 = m[1][2];\\n  float a20 = m[2][0], a21 = m[2][1], a22 = m[2][2];\\n\\n  float b01 = a22 * a11 - a12 * a21;\\n  float b11 = -a22 * a10 + a12 * a20;\\n  float b21 = a21 * a10 - a11 * a20;\\n\\n  float det = a00 * b01 + a01 * b11 + a02 * b21;\\n\\n  return mat3(b01, (-a22 * a01 + a02 * a21), (a12 * a01 - a02 * a11),\\n              b11, (a22 * a00 - a02 * a20), (-a12 * a00 + a02 * a10),\\n              b21, (-a21 * a00 + a01 * a20), (a11 * a00 - a01 * a10)) / det;\\n}\\n\\n//////////////////////////////////////////////\\n//// ShaderDough from @tdhooper in \\n//// https://www.shadertoy.com/view/4tc3WB\\n//////////////////////////////////////////////\\n// Disable to see more colour variety\\n#define SEAMLESS_LOOP\\n//#define COLOUR_CYCLE\\n#define PI 3.14159265359\\n#define PHI (1.618033988749895)\\nfloat t;\\n#define saturate(x) clamp(x, 0., 1.)\\n// --------------------------------------------------------\\n// http://www.neilmendoza.com/glsl-rotation-about-an-arbitrary-axis/\\n// --------------------------------------------------------\\nmat3 rotationMatrix(vec3 axis, float angle)\\n{\\n    axis = normalize(axis);\\n    float s = sin(angle);\\n    float c = cos(angle);\\n    float oc = 1.0 - c;\\n\\n    return mat3(\\n        oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,\\n        oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,\\n        oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c\\n    );\\n}\\n// --------------------------------------------------------\\n// http://math.stackexchange.com/a/897677\\n// --------------------------------------------------------\\nmat3 orientMatrix(vec3 A, vec3 B) {\\n    mat3 Fi = mat3(\\n        A,\\n        (B - dot(A, B) * A) / length(B - dot(A, B) * A),\\n        cross(B, A)\\n    );\\n    mat3 G = mat3(\\n        dot(A, B),              -length(cross(A, B)),   0,\\n        length(cross(A, B)),    dot(A, B),              0,\\n        0,                      0,                      1\\n    );\\n    return Fi * G * inverse(Fi);\\n}\\n// --------------------------------------------------------\\n// HG_SDF\\n// https://www.shadertoy.com/view/Xs3GRB\\n// --------------------------------------------------------\\n#define GDFVector3 normalize(vec3(1, 1, 1 ))\\n#define GDFVector3b normalize(vec3(-1, -1, -1 ))\\n#define GDFVector4 normalize(vec3(-1, 1, 1))\\n#define GDFVector4b normalize(vec3(-1, -1, 1))\\n#define GDFVector5 normalize(vec3(1, -1, 1))\\n#define GDFVector5b normalize(vec3(1, -1, -1))\\n#define GDFVector6 normalize(vec3(1, 1, -1))\\n#define GDFVector6b normalize(vec3(-1, 1, -1))\\n#define GDFVector7 normalize(vec3(0, 1, PHI+1.))\\n#define GDFVector7b normalize(vec3(0, 1, -PHI-1.))\\n#define GDFVector8 normalize(vec3(0, -1, PHI+1.))\\n#define GDFVector8b normalize(vec3(0, -1, -PHI-1.))\\n#define GDFVector9 normalize(vec3(PHI+1., 0, 1))\\n#define GDFVector9b normalize(vec3(PHI+1., 0, -1))\\n#define GDFVector10 normalize(vec3(-PHI-1., 0, 1))\\n#define GDFVector10b normalize(vec3(-PHI-1., 0, -1))\\n#define GDFVector11 normalize(vec3(1, PHI+1., 0))\\n#define GDFVector11b normalize(vec3(1, -PHI-1., 0))\\n#define GDFVector12 normalize(vec3(-1, PHI+1., 0))\\n#define GDFVector12b normalize(vec3(-1, -PHI-1., 0))\\n#define GDFVector13 normalize(vec3(0, PHI, 1))\\n#define GDFVector13b normalize(vec3(0, PHI, -1))\\n#define GDFVector14 normalize(vec3(0, -PHI, 1))\\n#define GDFVector14b normalize(vec3(0, -PHI, -1))\\n#define GDFVector15 normalize(vec3(1, 0, PHI))\\n#define GDFVector15b normalize(vec3(1, 0, -PHI))\\n#define GDFVector16 normalize(vec3(-1, 0, PHI))\\n#define GDFVector16b normalize(vec3(-1, 0, -PHI))\\n#define GDFVector17 normalize(vec3(PHI, 1, 0))\\n#define GDFVector17b normalize(vec3(PHI, -1, 0))\\n#define GDFVector18 normalize(vec3(-PHI, 1, 0))\\n#define GDFVector18b normalize(vec3(-PHI, -1, 0))\\n#define fGDFBegin float d = 0.;\\n// Version with variable exponent.\\n// This is slow and does not produce correct distances, but allows for bulging of objects.\\n#define fGDFExp(v) d += pow(abs(dot(p, v)), e);\\n// Version with without exponent, creates objects with sharp edges and flat faces\\n#define fGDF(v) d = max(d, abs(dot(p, v)));\\n#define fGDFExpEnd return pow(d, 1./e) - r;\\n#define fGDFEnd return d - r;\\n// Primitives follow:\\nfloat fDodecahedron(vec3 p, float r) {\\n    fGDFBegin\\n    fGDF(GDFVector13) fGDF(GDFVector14) fGDF(GDFVector15) fGDF(GDFVector16)\\n    fGDF(GDFVector17) fGDF(GDFVector18)\\n    fGDFEnd\\n}\\nfloat fIcosahedron(vec3 p, float r) {\\n    fGDFBegin\\n    fGDF(GDFVector3) fGDF(GDFVector4) fGDF(GDFVector5) fGDF(GDFVector6)\\n    fGDF(GDFVector7) fGDF(GDFVector8) fGDF(GDFVector9) fGDF(GDFVector10)\\n    fGDF(GDFVector11) fGDF(GDFVector12)\\n    fGDFEnd\\n}\\nfloat vmax(vec3 v) {\\n    return max(max(v.x, v.y), v.z);\\n}\\nfloat sgn(float x) {\\n\\treturn (x<0.)?-1.:1.;\\n}\\n// Plane with normal n (n is normalized) at some distance from the origin\\nfloat fPlane(vec3 p, vec3 n, float distanceFromOrigin) {\\n    return dot(p, n) + distanceFromOrigin;\\n}\\n\\n// Box: correct distance to corners\\nfloat fBox(vec3 p, vec3 b) {\\n\\tvec3 d = abs(p) - b;\\n\\treturn length(max(d, vec3(0))) + vmax(min(d, vec3(0)));\\n}\\n// Distance to line segment between <a> and <b>, used for fCapsule() version 2below\\nfloat fLineSegment(vec3 p, vec3 a, vec3 b) {\\n\\tvec3 ab = b - a;\\n\\tfloat t = saturate(dot(p - a, ab) / dot(ab, ab));\\n\\treturn length((ab*t + a) - p);\\n}\\n// Capsule version 2: between two end points <a> and <b> with radius r \\nfloat fCapsule(vec3 p, vec3 a, vec3 b, float r) {\\n\\treturn fLineSegment(p, a, b) - r;\\n}\\n// Rotate around a coordinate axis (i.e. in a plane perpendicular to that axis) by angle <a>.\\n// Read like this: R(p.xz, a) rotates \\\"x towards z\\\".\\n// This is fast if <a> is a compile-time constant and slower (but still practical) if not.\\nvoid pR(inout vec2 p, float a) {\\n    p = cos(a)*p + sin(a)*vec2(p.y, -p.x);\\n}\\n// Reflect space at a plane\\nfloat pReflect(inout vec3 p, vec3 planeNormal, float offset) {\\n    float t = dot(p, planeNormal)+offset;\\n    if (t < 0.) {\\n        p = p - (2.*t)*planeNormal;\\n    }\\n    return sign(t);\\n}\\n// Repeat around the origin by a fixed angle.\\n// For easier use, num of repetitions is use to specify the angle.\\nfloat pModPolar(inout vec2 p, float repetitions) {\\n\\tfloat angle = 2.*PI/repetitions;\\n\\tfloat a = atan(p.y, p.x) + angle/2.;\\n\\tfloat r = length(p);\\n\\tfloat c = floor(a/angle);\\n\\ta = mod(a,angle) - angle/2.;\\n\\tp = vec2(cos(a), sin(a))*r;\\n\\t// For an odd number of repetitions, fix cell index of the cell in -x direction\\n\\t// (cell index would be e.g. -5 and 5 in the two halves of the cell):\\n\\tif (abs(c) >= (repetitions/2.)) c = abs(c);\\n\\treturn c;\\n}\\n// Repeat around an axis\\nvoid pModPolar(inout vec3 p, vec3 axis, float repetitions, float offset) {\\n    vec3 z = vec3(0,0,1);\\n\\tmat3 m = orientMatrix(axis, z);\\n    p *= inverse(m);\\n    pR(p.xy, offset);\\n    pModPolar(p.xy, repetitions);\\n    pR(p.xy, -offset);\\n    p *= m;\\n}\\n// --------------------------------------------------------\\n// knighty\\n// https://www.shadertoy.com/view/MsKGzw\\n// --------------------------------------------------------\\nint Type=5;\\nvec3 nc;\\nvec3 pbc;\\nvec3 pca;\\nvoid initIcosahedron() {//setup folding planes and vertex\\n    float cospin=cos(PI/float(Type)), scospin=sqrt(0.75-cospin*cospin);\\n    nc=vec3(-0.5,-cospin,scospin);//3rd folding plane. The two others are xz and yz planes\\n\\tpbc=vec3(scospin,0.,0.5);//No normalization in order to have 'barycentric' coordinates work evenly\\n\\tpca=vec3(0.,scospin,cospin);\\n\\tpbc=normalize(pbc);\\tpca=normalize(pca);//for slightly better DE. In reality it's not necesary to apply normalization :) \\n\\n}\\nvoid pModIcosahedron(inout vec3 p) {\\n    p = abs(p);\\n    pReflect(p, nc, 0.);\\n    p.xy = abs(p.xy);\\n    pReflect(p, nc, 0.);\\n    p.xy = abs(p.xy);\\n    pReflect(p, nc, 0.);\\n}\\nfloat indexSgn(float s) {\\n\\treturn s / 2. + 0.5;\\n}\\nbool boolSgn(float s) {\\n\\treturn bool(s / 2. + 0.5);\\n}\\nfloat pModIcosahedronIndexed(inout vec3 p, int subdivisions) {\\n\\tfloat x = indexSgn(sgn(p.x));\\n\\tfloat y = indexSgn(sgn(p.y));\\n\\tfloat z = indexSgn(sgn(p.z));\\n    p = abs(p);\\n\\tpReflect(p, nc, 0.);\\n\\n\\tfloat xai = sgn(p.x);\\n\\tfloat yai = sgn(p.y);\\n    p.xy = abs(p.xy);\\n\\tfloat sideBB = pReflect(p, nc, 0.);\\n\\n\\tfloat ybi = sgn(p.y);\\n\\tfloat xbi = sgn(p.x);\\n    p.xy = abs(p.xy);\\n\\tpReflect(p, nc, 0.);\\n    \\n    float idx = 0.;\\n\\n    float faceGroupAi = indexSgn(ybi * yai * -1.);\\n    float faceGroupBi = indexSgn(yai);\\n    float faceGroupCi = clamp((xai - ybi -1.), 0., 1.);\\n    float faceGroupDi = clamp(1. - faceGroupAi - faceGroupBi - faceGroupCi, 0., 1.);\\n\\n    idx += faceGroupAi * (x + (2. * y) + (4. * z));\\n    idx += faceGroupBi * (8. + y + (2. * z));\\n    # ifndef SEAMLESS_LOOP\\n    \\tidx += faceGroupCi * (12. + x + (2. * z));\\n    # endif\\n    idx += faceGroupDi * (12. + x + (2. * y));\\n\\n\\treturn idx;\\n}\\n// --------------------------------------------------------\\n// IQ\\n// https://www.shadertoy.com/view/ll2GD3\\n// --------------------------------------------------------\\nvec3 pal( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d ) {\\n    return a + b*cos( 6.28318*(c*t+d) );\\n}\\n\\nvec3 spectrum(float n) {\\n    return pal( n, vec3(0.5,0.5,0.5),vec3(0.5,0.5,0.5),vec3(1.0,1.0,1.0),vec3(0.0,0.33,0.67) );\\n}\\n// --------------------------------------------------------\\n// tdhooper\\n// https://www.shadertoy.com/view/Mtc3RX\\n// --------------------------------------------------------\\nvec3 vMin(vec3 p, vec3 a, vec3 b, vec3 c) {\\n    float la = length(p - a);\\n    float lb = length(p - b);\\n    float lc = length(p - c);\\n    if (la < lb) {\\n        if (la < lc) {\\n            return a;\\n        } else {\\n            return c;\\n        }\\n    } else {\\n        if (lb < lc) {\\n            return b;\\n        } else {\\n            return c;\\n        }\\n    }\\n}\\nvec3 icosahedronVertex(vec3 p) {\\n    if (p.z > 0.) {\\n        if (p.x > 0.) {\\n            if (p.y > 0.) {\\n                return vMin(p, GDFVector13, GDFVector15, GDFVector17);\\n            } else {\\n                return vMin(p, GDFVector14, GDFVector15, GDFVector17b);\\n            }\\n        } else {\\n            if (p.y > 0.) {\\n                return vMin(p, GDFVector13, GDFVector16, GDFVector18);\\n            } else {\\n                return vMin(p, GDFVector14, GDFVector16, GDFVector18b);\\n            }\\n        }\\n    } else {\\n        if (p.x > 0.) {\\n            if (p.y > 0.) {\\n                return vMin(p, GDFVector13b, GDFVector15b, GDFVector17);\\n            } else {\\n                return vMin(p, GDFVector14b, GDFVector15b, GDFVector17b);\\n            }\\n        } else {\\n            if (p.y > 0.) {\\n                return vMin(p, GDFVector13b, GDFVector16b, GDFVector18);\\n            } else {\\n                return vMin(p, GDFVector14b, GDFVector16b, GDFVector18b);\\n            }\\n        }\\n    }\\n}\\nvec4 icosahedronAxisDistance(vec3 p) {\\n    vec3 iv = icosahedronVertex(p);\\n    vec3 originalIv = iv;\\n\\n    vec3 pn = normalize(p);\\n    pModIcosahedron(pn);\\n    pModIcosahedron(iv);\\n\\n    float boundryDist = dot(pn, vec3(1, 0, 0));\\n    float boundryMax = dot(iv, vec3(1, 0, 0));\\n    boundryDist /= boundryMax;\\n\\n    float roundDist = length(iv - pn);\\n    float roundMax = length(iv - vec3(0, 0, 1.));\\n    roundDist /= roundMax;\\n    roundDist = -roundDist + 1.;\\n\\n    float blend = 1. - boundryDist;\\n\\tblend = pow(blend, 6.);\\n    \\n    float dist = mix(roundDist, boundryDist, blend);\\n\\n    return vec4(originalIv, dist);\\n}\\nvoid pTwistIcosahedron(inout vec3 p, float amount) {\\n    vec4 a = icosahedronAxisDistance(p);\\n    vec3 axis = a.xyz;\\n    float dist = a.a;\\n    mat3 m = rotationMatrix(axis, dist * amount);\\n    p *= m;\\n}\\nstruct Model {\\n    float dist;\\n    vec3 colour;\\n    float id;\\n};\\nModel fInflatedIcosahedron(vec3 p, vec3 axis) {\\n    float d = 1000.;\\n    \\n    # ifdef SEAMLESS_LOOP\\n    \\t// Radially repeat along the rotation axis, so the\\n    \\t// colours repeat more frequently and we can use\\n    \\t// less frames for a seamless loop\\n    \\tpModPolar(p, axis, 3., PI/2.);\\n\\t# endif\\n    \\n    // Slightly inflated icosahedron\\n    float idx = pModIcosahedronIndexed(p, 0);\\n    d = min(d, dot(p, pca) - .9);\\n    d = mix(d, length(p) - .9, .5);\\n\\n    // Colour each icosahedron face differently\\n    # ifdef SEAMLESS_LOOP\\n    \\tif (idx == 3.) {\\n    \\t\\tidx = 2.;\\n    \\t}\\n    \\tidx /= 10.;\\n   \\t# else\\n    \\tidx /= 20.;\\n    # endif\\n    # ifdef COLOUR_CYCLE\\n    \\tidx = mod(idx + t*1.75, 1.);\\n    # endif\\n    vec3 colour = floor(spectrum(idx) * 6.) / 6. ;\\n    \\n    d *= .6;\\n\\treturn Model(d, colour, 1.);\\n}\\nvoid pTwistIcosahedron(inout vec3 p, vec3 center, float amount) {\\n    p += center;\\n    pTwistIcosahedron(p, 5.5);\\n    p -= center;\\n}\\nModel model(vec3 p) {\\n    float rate = PI/6.;\\n    vec3 axis = pca;\\n\\n    vec3 twistCenter = vec3(0);\\n    twistCenter.x = cos(t * rate * -3.) * .3;\\n\\ttwistCenter.y = sin(t * rate * -3.) * .3;\\n\\n\\tmat3 m = rotationMatrix(\\n        reflect(axis, vec3(0,1,0)),\\n        t * -rate\\n   \\t);\\n    p *= m;\\n    twistCenter *= m;\\n\\n    pTwistIcosahedron(p, twistCenter, 5.5);\\n\\n\\treturn fInflatedIcosahedron(p, axis);\\n}\\n// The MINIMIZED version of https://www.shadertoy.com/view/Xl2XWt\\nconst float MAX_TRACE_DISTANCE = 30.0;           // max trace distance\\nconst float INTERSECTION_PRECISION = 0.001;        // precision of the intersection\\nconst int NUM_OF_TRACE_STEPS = 100;\\nvec2 opU( vec2 d1, vec2 d2 ){\\n    return (d1.x<d2.x) ? d1 : d2;\\n}\\nModel map( vec3 p )\\n{\\n    return model(p*2.);\\n}\\n//////////////////////////////////////////////\\n//////////////////////////////////////////////\\n//////////////////////////////////////////////\\n\\n//////////////////////////////////////////////\\n//https://www.vertexshaderart.com/art/DSH7PskktA2rGgZ6F\\n//////////////////////////////////////////////\\n\\nvec3 meshSqhere(in float id) \\n{\\n    float split = floor(sqrt(floor(vertexCount/6.0)));\\n\\tsplit = floor(split/2.0);\\n\\tfloat d = split * 2.0;\\n    float n = floor(id / 6.0);\\n    vec2 q = vec2(mod(n,d), mod(floor(n/d),d));\\n    vec2 a = q+0.5-split;\\n    float s = sign(a.x*a.y);\\n    float c = abs(3.0 - mod(id, 6.0));  \\n    vec2 uv = vec2(mod(c, 2.0), abs(step(0.0, s)-floor(c / 2.0)));\\n    uv = (uv+q)/split -1.0;    \\n    if ( uv.x > abs(uv.y)) uv.y -= (uv.x - abs(uv.y))*s;\\n    if (-uv.x > abs(uv.y)) uv.y -= (uv.x + abs(uv.y))*s;\\n    if ( uv.y > abs(uv.x)) uv.x -= (uv.y - abs(uv.x))*s;\\n    if (-uv.y > abs(uv.x)) uv.x -= (uv.y + abs(uv.x))*s;\\n    return normalize(vec3(uv , 0.8*(1.0-pow(max(abs(uv.x),abs(uv.y)),2.0)) *s));\\n}\\n\\n//////////////////////////////////////////////\\n//////////////////////////////////////////////\\n//////////////////////////////////////////////\\n\\nvec3 getPoint(float vId)\\n{\\n\\tvec3 p = meshSqhere(vertexId);\\n\\t\\n\\tfloat d = 0.;\\n\\tvec3 rd = normalize(p);\\n\\tvec3 ro = rd * -3.;\\n\\tfor (int i=0;i<5;i++)\\n\\t{\\n\\t\\td += map(ro + rd * d).dist;\\n\\t}\\n\\t\\n\\treturn ro + rd * d;\\n}\\n\\nvec3 getNormal( vec3 p, float prec )\\n{\\n    vec2 e = vec2( prec, 0. );\\n    vec3 n = vec3(\\n        map(p+e.xyy).dist - map(p-e.xyy).dist,\\n        map(p+e.yxy).dist - map(p-e.yxy).dist,\\n        map(p+e.yyx).dist - map(p-e.yyx).dist );\\n    return normalize(n);\\n}\\n\\nvoid main() \\n{\\n\\tinitIcosahedron();\\n    t = time * 0.8;\\n  \\t//t = 0.;\\n  \\n    vec3 p = getPoint(vertexId);\\n\\t\\n  \\tvec3 ro = vec3(0,0,-3.);\\n    float d = length(ro-p);\\n\\t\\n  \\tgl_PointSize = 3.;//8.-d;\\n  \\n\\tvec3 rd = vec3(0,0,-1.);\\n\\tvec3 ld = normalize(vec3(1.,0,-1.));\\n\\tvec3 n = getNormal(p, 0.0001);\\n\\tfloat sd = map(p + n).dist;\\n\\t\\n\\tfloat diff = max(dot(n, ld), 0.);\\n    float spec = pow(max(dot( reflect(-ld, n), rd), 0.), 2.);   \\n\\tvec3 col = map(p).colour * 0.8 + diff * 0.2 + spec * 0.8;\\n  \\tcol /= sd;\\n\\t\\n  \\tfloat screenZ = -0.;\\n\\tfloat eyeZ = -4.5;\\n\\tp.xy *= (eyeZ - screenZ) / (p.z - eyeZ);\\n\\tp.x /= resolution.x / resolution.y;\\n  \\n\\tgl_Position = vec4(p, 1);\\n  \\t\\n  \\t//v_color = vec4(0.);\\n    //if (p.z < 0.)\\n\\t \\tv_color = vec4(clamp(col,0.,1.), 1);\\n}\"}",
  "screenshotURL": "data/images/images-h1gh8djesgxas9aba-thumbnail.jpg",
  "hasSound": "",
  "views": {
    "$numberInt": "1241"
  },
  "likes": {
    "$numberInt": "4"
  },
  "revisionId": "nnTD2azkT8pzQcxch"
}