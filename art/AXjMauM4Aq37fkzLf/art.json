{
  "_id": "AXjMauM4Aq37fkzLf",
  "owner": {
    "_id": "pFtCXpp8o7qaPQv3F",
    "createdAt": {
      "$date": {
        "$numberLong": "1493839555330"
      }
    },
    "profile": {
      "name": "Attila Török",
      "avatarUrl": "https://lh5.googleusercontent.com/-x0sWnYltj1w/AAAAAAAAAAI/AAAAAAAAFOw/6xAGpro1JhI/photo.jpg"
    },
    "username": "attila"
  },
  "createdAt": {
    "$date": {
      "$numberLong": "1493840515638"
    }
  },
  "modifiedAt": {
    "$date": {
      "$numberLong": "1493889303785"
    }
  },
  "origId": null,
  "name": "spinor",
  "notes": "",
  "rank": {
    "$numberDouble": "1.3929855930993473"
  },
  "private": false,
  "unlisted": true,
  "username": "attila",
  "avatarUrl": "https://lh5.googleusercontent.com/-x0sWnYltj1w/AAAAAAAAAAI/AAAAAAAAFOw/6xAGpro1JhI/photo.jpg",
  "settings": {
    "num": 14400,
    "mode": "TRIANGLES",
    "sound": "",
    "lineSize": "NATIVE",
    "backgroundColor": [
      0,
      0,
      0,
      1
    ],
    "shader": "#define PI radians(180.)\n\nvec3 hsv2rgb(vec3 c) {\n  c = vec3(c.x, clamp(c.yz, 0.0, 1.0));\n  vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvec3 quad(vec3 origin, vec3 center, vec3 tangent, int vert_of_quad) {\n  vec3 bitangent = cross(center, tangent);\n  center += origin;\n  if (vert_of_quad == 0)\n    return center + tangent + bitangent;\n  else if (vert_of_quad == 1)\n    return center + tangent - bitangent;\n  else if (vert_of_quad == 2)\n    return center - tangent + bitangent;\n  else if (vert_of_quad == 3)\n    return center - tangent - bitangent;\n  else if (vert_of_quad == 4)\n    return center + tangent - bitangent;\n  else if (vert_of_quad == 5)\n    return center - tangent + bitangent;\n  return center;\n}\n\nvec3 cube_quad(vec3 center, vec3 tangent, int vert_of_quad) {\n  return quad(vec3(0.0), center, tangent, vert_of_quad);\n}\n\nstruct Quad {\n  vec3 v0, v1, v2, v3;\n  vec3 nor;\n  int mat_id;\n};\n  \nvec3 vert_of_quad(Quad q, int vert_of_quad) {\n  if (vert_of_quad == 0)\n    return q.v0;\n  else if (vert_of_quad == 1)\n    return q.v1;\n  else if (vert_of_quad == 2)\n    return q.v2;\n  else if (vert_of_quad == 3)\n    return q.v0;\n  else if (vert_of_quad == 4)\n    return q.v2;\n  else if (vert_of_quad == 5)\n    return q.v3;\n  return q.v0;\n}\n\n  \nvec3 norm_of_quad(Quad q, int vert_of_quad) {\n  return normalize((vert_of_quad < 3)\n    ? cross(q.v0 - q.v1, q.v2 - q.v1)\n    : cross(q.v0 - q.v2, q.v3 - q.v2));\n}\n\n\nstruct Ring {\n  vec3 s0, s1, s2, s3;\n  vec3 e0, e1, e2, e3;\n};\n\nQuad quad_of_ring(Ring r, int quad_in_ring)\n{  \n  Quad q;\n  \n  if (quad_in_ring == 0) {\n    q.v0 = r.s0;\n    q.v1 = r.s1;\n    q.v2 = r.e1;\n    q.v3 = r.e0;\n    q.nor = normalize(r.s1 - r.s2);\n  } else if (quad_in_ring == 1) {\n    q.v0 = r.s1;\n    q.v1 = r.s2;\n    q.v2 = r.e2;\n    q.v3 = r.e1;\n    q.nor = normalize(r.s2 - r.s3);\n  } else if (quad_in_ring == 2) {\n    q.v0 = r.s2;\n    q.v1 = r.s3;\n    q.v2 = r.e3;\n    q.v3 = r.e2;\n    q.nor = normalize(r.s3 - r.s0);\n  } else if (quad_in_ring == 3) {\n    q.v0 = r.s3;\n    q.v1 = r.s0;\n    q.v2 = r.e0;\n    q.v3 = r.e3;\n    q.nor = normalize(r.s0 - r.s1);\n  }\n  \n  q.mat_id = quad_in_ring;\n  \n  return q;\n}\n\nstruct Segment {\n  vec3 d0, d1;\n  vec3 p0, p1;\n  vec3 n0, n1;\n};\n\nRing ring_from_segment(Segment s) {  \n  vec3 b0 = normalize(cross(s.d0, s.n0)) * 0.5;\n  vec3 b1 = normalize(cross(s.d1, s.n1)) * 0.5;\n  \n  vec3 n0 = normalize(s.n0) * 0.25;\n  vec3 n1 = normalize(s.n1) * 0.25;\n  \n  Ring r;\n  \n  r.s0 = s.p0 + n0 - b0;\n  r.s1 = s.p0 + n0 + b0;\n  r.s2 = s.p0 - n0 + b0;\n  r.s3 = s.p0 - n0 - b0;\n  \n  r.e0 = s.p1 + n1 - b1;\n  r.e1 = s.p1 + n1 + b1;\n  r.e2 = s.p1 - n1 + b1;\n  r.e3 = s.p1 - n1 - b1;\n  \n  return r;\n}\n\nvec3 curve_x_pos(float t) {\n  float alpha = smoothstep(0.3, 0.4, t);\n  float beta = smoothstep(0.3, 0.4, t) - smoothstep(0.5, 0.75, t);\n  \n  float phi = alpha * PI - time;\n  \n  float d = 5.0 * t;\n  \n  float A = alpha * d;\n  \n  float delta_x = -beta * (sin(time/2.0) * 0.5 + 0.5);\n  float delta_y = -beta*2.0 * (-sin(time));\n  float delta_z = -beta*3.0 * sin(time);\n  \n  return vec3(A + delta_x * 2.0, delta_y, delta_z);\n}\n\nvec3 curve_x_nor(float t) {\n  float r = t;//abs(t - 0.5) * 2.0;\n  float angle = 0.0;//-smoothstep(0.3, 0.6, r) * PI;\n  \n  return vec3(sin(angle), 0.0, cos(angle));\n}\n\nvec3 curve_y_pos(float t) {\n  return vec3(0.0);//, -10.0 + 20.0 * t, 0.0);\n}\nvec3 curve_y_nor(float t) {\n  return vec3(0.0);//sin(t*10.0), 0.0, cos(t*10.0));\n}\n\nvec3 curve_z_pos(float t) {\n  return vec3(0.0);//, 0.0, -10.0 + 20.0 * t);\n}\nvec3 curve_z_nor(float t) {\n  return vec3(sin(t*10.0), cos(t*10.0), 0.0);\n}\n\nSegment segment_x(float t1, float t2) {\n  Segment s;\n  \n  float d = (t2 - t1) * 0.1;\n  \n  s.d0 = curve_x_pos(t1+d) - curve_x_pos(t1-d);\n  s.d1 = curve_x_pos(t2+d) - curve_x_pos(t2-d);\n  \n  s.p0 = curve_x_pos(t1);\n  s.p1 = curve_x_pos(t2);\n    \n  s.n0 = curve_x_nor(t1);\n  s.n1 = curve_x_nor(t2);\n    \n  return s;\n}\n\nSegment segment_y(float t1, float t2) {\n  Segment s;\n    \n  \n  float d = (t2 - t1) * 0.1;\n  \n  s.d0 = curve_y_pos(t1+d) - curve_y_pos(t1-d);\n  s.d1 = curve_y_pos(t2+d) - curve_y_pos(t2-d);\n  \n  s.p0 = curve_y_pos(t1);\n  s.p1 = curve_y_pos(t2);\n    \n  s.n0 = curve_y_nor(t1);\n  s.n1 = curve_y_nor(t2);\n  \n  return s;\n}\n\nSegment segment_z(float t1, float t2) {\n  Segment s;\n  \n  \n  float d = (t2 - t1) * 0.1;\n  \n  s.d0 = curve_z_pos(t1+d) - curve_z_pos(t1-d);\n  s.d1 = curve_z_pos(t2+d) - curve_z_pos(t2-d);\n  \n  s.p0 = curve_z_pos(t1);\n  s.p1 = curve_z_pos(t2);\n    \n  s.n0 = curve_z_nor(t1);\n  s.n1 = curve_z_nor(t2);\n  \n  return s;\n}\n\nQuad quad_of_strip(int strip_id, int i, int n) {\n  int num_rings = n / 4;\n  int ring_id = i / 4;\n  int quad_in_ring = i - 4 * ring_id;\n  \n  Segment s;\n  \n  float t1 = float(ring_id) / float(num_rings);\n  float t2 = (float(ring_id) + 1.0) / float(num_rings);\n  \n  if (strip_id == 0)\n  \ts = segment_x(t1, t2);\n  else if (strip_id == 1)\n  \ts = segment_y(t1, t2);\n  else if (strip_id == 2)\n  \ts = segment_z(t1, t2);\n  \n  Ring r = ring_from_segment(s);\n  \n  Quad q = quad_of_ring(r, quad_in_ring);\n  q.nor = (s.n0 + s.n1) / 2.0;\n  return q;\n}\n\nvoid main() {\n  vec3 pos = vec3(0.0);\n  vec3 nor = vec3(0.0, 0.0, 0.0);\n  \n  int tri_id = int(floor(vertexId / 3.0));\n  int vert_in_tri = int(vertexId) - 3 * tri_id;\n  \n  int quad_id = tri_id / 2;\n  int tri_in_quad = int(tri_id) - 2 * quad_id;\n  \n  int mat_id = 0;\n    \n  vec3 cube_x = vec3(cos(time), sin(time), 0.0);\n  vec3 cube_y = vec3(-sin(time), cos(time), 0.0);\n  \n  if (quad_id < 6) {\n    int dim_id = quad_id / 2;\n    int side_in_dim = quad_id - 2 * dim_id;\n    \n    if (dim_id == 0) {\n      pos = cube_quad(vec3(0.0, 0.0, 1.0), cube_x, vert_in_tri + tri_in_quad*3);\n      nor = vec3(0.0, 0.0, 1.0);\n    } else if (dim_id == 1) {\n      pos = cube_quad(cube_y, cube_x, vert_in_tri + tri_in_quad*3);\n      nor = cube_y;\n    } else if (dim_id == 2) {\n      pos = cube_quad(cube_x, cube_y, vert_in_tri + tri_in_quad*3);\n      nor = cube_x;\n    }\n    mat_id = dim_id;\n    \n    if (side_in_dim == 1)\n      pos *= -1.0;\n    \n  }\n  else {\n    int vert_remaining = int(vertexCount) - 36;\n    int vert_per_strip = vert_remaining / 3;\n    int quad_per_strip = vert_per_strip / 6;\n    \n    int lvi = int(vertexId) - 36;\n      \n    int strip = lvi / vert_per_strip;\n    int first_vert_of_strip = 36 + strip * vert_per_strip;\n    int vert_in_strip = int(vertexId) - first_vert_of_strip;\n    \n    int quad_in_strip = vert_in_strip / 6;\n    int vert_in_quad = vert_in_strip - quad_in_strip * 6;\n    \n    Quad q;\n    \n    q = quad_of_strip(strip, quad_in_strip, quad_per_strip);\n    \n      /*\n    q.center = vec3(2.0, 0.0, 1.0);\n      q.tangent = vec3(1.0, 0.0, 0.0);\n    q.bitangent = vec3(0.0, 0.0, 1.0);\n      q.normal = vec3(0.0, 1.0, 0.0);\n    */\n    pos = vert_of_quad(q, vert_in_quad);\n    nor = q.nor;//norm_of_quad(q, vert_in_quad);\n    mat_id = q.mat_id;\n  }\n  \n  \n  vec3 base_x = vec3(cos(mouse.x*3.0), 1.0, sin(mouse.x*3.0));\n  vec3 base_y = vec3(sin(mouse.x*3.0), 1.0, -cos(mouse.x*3.0));\n  \n  base_x *= vec3(cos(mouse.y*3.0), sin(mouse.y*3.0), cos(mouse.y * 3.0));\n  base_y *= vec3(cos(mouse.y*3.0), sin(mouse.y*3.0), cos(mouse.y * 3.0));\n  \n  \n  vec3 base_z = cross(base_x, base_y);\n  base_x = cross(base_z, base_y);\n  \n  base_x = normalize(base_x) * 0.1;\n  base_y = normalize(base_y) * 0.1;\n  base_z = normalize(base_z) * 0.1;\n  \n  vec3 nor_mapped = normalize(nor.x * base_x + nor.y * base_y + nor.z * base_z);\n  \n  vec3 col = hsv2rgb(vec3(0.08 + float(mat_id) * 0.25, 1, 1));\n  \n  vec3 lightdir = normalize(vec3(-1, 1, -1));\n  \n  float diff = 0.25 + 0.75 * abs(dot(nor_mapped, lightdir));\n  v_color = vec4(col * diff, 1.0);\n  \n  vec3 pos_mapped = pos.x * base_x + pos.y * base_y + pos.z * base_z;\n  pos_mapped.x /= 1.0 + pos_mapped.z * 0.75;\n  pos_mapped.y /= 1.0 + pos_mapped.z * 0.75;\n  pos_mapped.x /= (resolution.x / resolution.y);\n  gl_Position = vec4(pos_mapped, 1.0);\n}"
  },
  "screenshotURL": "data/images/images-dk6k6p544c74c44vi-thumbnail.jpg",
  "hasSound": "",
  "views": {
    "$numberInt": "12"
  },
  "likes": {
    "$numberInt": "0"
  },
  "revisionId": "iWnr7EfnX7s2Pax2E"
}