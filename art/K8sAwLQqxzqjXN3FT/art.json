{
  "_id": "K8sAwLQqxzqjXN3FT",
  "owner": {
    "username": "anon"
  },
  "createdAt": {
    "$date": {
      "$numberLong": "1446222765293"
    }
  },
  "origId": "gqJ33JsAWdcuKjJHH",
  "name": "Knotted Candy",
  "username": "-anon-",
  "settings": {
    "num": 100000,
    "mode": "TRIANGLES",
    "sound": "",
    "lineSize": "NATIVE",
    "backgroundColor": [
      0.10196078431372549,
      0.19607843137254902,
      0.25098039215686274,
      1
    ],
    "shader": "// Knotted Candy - @P_Malin\n\n// Some different shapes...\n\n//#define SHAPE_TWO_BRAIDS\n//#define SHAPE_THREE_BRAIDS\n//#define SHAPE_TORUS\n#define SHAPE_MOBIUS\n\n\n//#define RIBBON  \n\n#ifdef SHAPE_TWO_BRAIDS  \n  float twist = 3.0;\n  float radius1 = 0.25;\n  float radius2 = 3.0;\n  float radius3 = 0.4;\n  \n  float waves = 4.0;\n  float braids = 2.0;\n\n  vec2 vShapeDim = vec2( 32.0, 256.0 );\n#elif defined(SHAPE_THREE_BRAIDS)\n  float twist = 5.0;\n  float radius1 = 0.15;\n  float radius2 = 3.0;\n  float radius3 = 0.5;\n  \n  float waves = 4.0;\n  float braids = 3.0;\n\n  vec2 vShapeDim = vec2( 24.0, 192.0 );\n#elif defined(SHAPE_TORUS)\n  // Torus\n  float twist = 0.0;\n  float radius1 = 1.0;\n  float radius2 = 3.0;\n  float radius3 = 0.0;\n  \n  float waves = 3.0;\n  float braids = 2.0;\n\n  vec2 vShapeDim = vec2( 32.0, 256.0 );\n#elif defined(SHAPE_MOBIUS)\n  // Torus\n  float twist = 2.0;\n  float radius1 = 1.0;\n  float radius2 = 2.0;\n  float radius3 = 0.0;\n  \n  float waves = 0.0;\n  float braids = 2.0;\n\n  #define RIBBON  \n  vec2 vShapeDim = vec2( 32.0, 256.0 );\n#else\n#error INVALID SHAPE DEFINE\n#endif\n\n// Inputs:\n// vertexId\n// time\n// resolution\n\n// Outputs:\n// gl_Position\n// v_color\n\n#define PI radians( 180.0 )\n\nvoid GetQuadInfo( const float vertexIndex, out float x, out float y, out float quadId )\n{\n  float twoTriVertexIndex = mod( vertexIndex, 6.0 );\n  float triVertexIndex = mod( vertexIndex, 3.0 );\n  float quadVertexIndex = triVertexIndex;\n  if ( twoTriVertexIndex >= 3.0 )\n  {\n    quadVertexIndex ++;\n  }\n  \n  if ( quadVertexIndex < 0.5 )\n  {\n    x = 0.0;\n    y = 0.0;\n  }\n  else if ( quadVertexIndex < 1.5 )\n  {\n    x = 1.0;\n    y = 0.0;\n  }\n  else if ( quadVertexIndex < 2.5 )\n  {\n    x = 0.0;\n    y = 1.0;\n  }\n  else if ( quadVertexIndex < 3.5 )\n  {\n    x = 1.0;\n    y = 1.0;\n  }\n\n  quadId = floor( vertexIndex / 6.0 );\n}\n\nvec2 Rotate( const in vec2 vPos, const in float fAngle )\n{\n    float s = sin(fAngle);\n    float c = cos(fAngle);\n    \n    vec2 vResult = vec2( c * vPos.x + s * vPos.y, -s * vPos.x + c * vPos.y);\n    \n    return vResult;\n}\n\nstruct SurfaceInfo\n{\n\tvec3 vPos;\n  \tvec3 vNormal;\n};\n\nvoid Translate( vec3 vTranslation, inout vec3 vPos )\n{\n\tvPos += vTranslation;\n}\n  \nvoid RotateX( float theta, inout vec3 vPos )\n{\n  \tvPos.yz = Rotate( vPos.yz, theta );\n}\n\nvoid RotateY( float theta, inout vec3 vPos )\n{\n  \tvPos.xz = Rotate( vPos.xz, theta );\n}\n\nvoid RotateZ( float theta, inout vec3 vPos )\n{\n  \tvPos.xy = Rotate( vPos.xy, theta );\n}\n\nvoid AddPointLight( vec3 vLightPos, vec3 vLightColor, const SurfaceInfo surfaceInfo, inout vec3 vDiffuse, inout vec3 vSpecular )\n{\n  vec3 vLightDir = normalize(vLightPos - surfaceInfo.vPos);\n  vec3 vViewDir = normalize(-surfaceInfo.vPos);\n  \n  float NdotL = max( 0.0, dot( vLightDir, surfaceInfo.vNormal ) );\n  \n  vec3 vHalfAngle = normalize( vViewDir + vLightDir );\n\n  float NdotH = max( 0.0, dot( vHalfAngle, surfaceInfo.vNormal ) );\n  \n  vDiffuse += NdotL * vLightColor;\n\n  float fPower = 80.0;\n  vSpecular += pow( NdotH, fPower ) * (fPower * 8.0 * PI) * NdotL * vLightColor;\n}\n\nvoid AddDirectionalLight( vec3 vLightDir, vec3 vLightColor, const SurfaceInfo surfaceInfo, inout vec3 vDiffuse, inout vec3 vSpecular )\n{\n  vec3 vViewDir = normalize(-surfaceInfo.vPos);\n  \n  float NdotL = max( 0.0, dot( vLightDir, surfaceInfo.vNormal ) );\n  \n  vec3 vHalfAngle = normalize( vViewDir + vLightDir );\n\n  float NdotH = max( 0.0, dot( vHalfAngle, surfaceInfo.vNormal ) );\n  \n  vDiffuse += NdotL * vLightColor;\n\n  float fPower = 80.0;\n  vSpecular += pow( NdotH, fPower ) * (fPower * 8.0 * PI) * NdotL * vLightColor;\n}\n\nvec3 GetSkyColor( vec3 vDir )\n{\n  return mix( vec3(0.01, 0.1, 0.4), vec3(0.2, 0.5, 0.6) * 5.0, vDir.y * 0.5 + 0.5 );\n}\n\n\n\nvec3 LightSurface( const SurfaceInfo surfaceInfo, const vec3 vAlbedo )\n{   \n  vec3 vDiffuseLight = vec3(0.0);\n  vec3 vSpecLight = vec3(0.0);\n\n  // use background color\n  vec3 vAmbient = GetSkyColor( surfaceInfo.vNormal );\n  vDiffuseLight += vAmbient;\n  vSpecLight += vAmbient;\n\n  AddPointLight( vec3(3.0, 2.0, 30.0), vec3( 0.5, 1.0, 1.0), surfaceInfo, vDiffuseLight, vSpecLight );\n  AddDirectionalLight( normalize(vec3(0.0, 1.0, 0.0)), vec3( 3.0, 2.9, 1.5), surfaceInfo, vDiffuseLight, vSpecLight );\n\n  //AddDirectionalLight( normalize(vec3(0.0, -1.0, 0.0)), vAmbient * 0.1, surfaceInfo, vDiffuseLight, vSpecLight );\n  \n  // viewer is at origin\n  vec3 vViewDir = normalize(-surfaceInfo.vPos);\n  \n  float fNdotD = clamp(dot(surfaceInfo.vNormal, vViewDir), 0.0, 1.0);\n  vec3 vR0 = vec3(0.04);\n  vec3 vFresnel = vR0 + (1.0 - vR0) * pow(1.0 - fNdotD, 5.0);\n  \n  \n  vec3 vColor = mix( vDiffuseLight * vAlbedo, vSpecLight, vFresnel );\n  \n  return vColor;\n}\n\nvec3 PostProcess( vec3 vColor )\n{\n  float kExposure = 1.0;\n  vColor = vec3(1.0) - exp2( vColor * -kExposure );\n\n  vColor = pow( vColor, vec3(1.0 / 2.2) );\n\n  return vColor;\n}\n\nvec3 ApplyVignetting( const in vec2 vUV, const in vec3 vInput )\n{\n\tvec2 vOffset = (vUV - 0.5) * sqrt(2.0);\n\t\n\tfloat fDist = dot(vOffset, vOffset);\n\t\n\tconst float kStrength = 0.95;\n\tconst float kPower = 1.5;\n\n\treturn vInput * ((1.0 - kStrength) +  kStrength * pow(1.0 - fDist, kPower));\n}\n\nvoid ProcessBackdrop( float vertexIndex )\n{\n  float quadX, quadY, quadId;\n  \n  GetQuadInfo( vertexId, quadX, quadY, quadId );\n\n  vec2 vDim = vec2( 8.0, 8.0 );\n  \n  vec2 vUV;\n  \n  vec2 quadTile;\n  quadTile.x = mod(quadId, vDim.x);\n  quadTile.y = floor(quadId / vDim.x);\n  \n  vUV.x = quadX + quadTile.x;\n  vUV.y = quadY + quadTile.y;\n\n  vUV = vUV * (1.0 / vDim);\n  \n  \n  gl_Position = vec4( vUV.xy * 2.0 - 1.0, 0.0, 1.0 );\n\n  vec3 vPos = vec3( vUV.xy * 2.0 - 1.0, 2.0 );\n  vPos.y *= resolution.x / resolution.y;\n  \n  vec3 vColor = GetSkyColor( normalize( vPos ) );\n  \n  vColor = ApplyVignetting( vUV.xy, vColor );\n  \n  vColor = PostProcess( vColor );\n  \n  v_color = vec4( vColor, 1.0 );\n}\n\nvoid TransformPoint( inout vec3 vPos, vec2 vUV, float t )\n{  \n  vPos += vec3(0.0, radius1, 0.0);\n  RotateZ( vUV.x * PI * 2.0  + vUV.y * PI * 2.0 * twist, vPos );\n  \n#ifdef RIBBON  \n  vPos.y *= 0.1;\n#endif  \n  \n  vPos += vec3(-radius3, 0.0, 0.0);\n  RotateZ( vUV.y * PI * 2.0 * (waves + 1.0 / braids), vPos );\n\n  vPos += vec3(-radius2, 0.0, 0.0); \n  \n  RotateY( vUV.y * PI * 2.0, vPos );\n  \n  // animated spin\n  RotateY( t * 0.5, vPos );  \n  RotateX( t, vPos );  \n\n  vPos += vec3(0.0, 0.0, 30.0);  \n}\n\nvoid ProcessShape( float vertexIndex )\n{\n  float quadX, quadY, quadId;\n  \n  GetQuadInfo( vertexId, quadX, quadY, quadId );  \n  \n  vec2 vUV;\n  \n  vec2 quadTile;\n  quadTile.x = mod(quadId, vShapeDim.x);\n  quadTile.y = floor(quadId / vShapeDim.x);\n  \n  vUV.x = quadX + quadTile.x;\n  vUV.y = quadY + quadTile.y;\n\n  vUV = vUV * (1.0 / vShapeDim);  \n\n  vec3 vPos = vec3(0.0, 0.0, 0.0);\n  TransformPoint( vPos, vUV, time );\n\n  // Lazy normal calculation\n  \n  float fDelta = 0.001;\n  vec3 vPosdU = vec3(0.0, 0.0, 0.0);\n  TransformPoint( vPosdU, vUV + vec2(fDelta, 0.0), time );\n  vec3 vPosdV = vec3(0.0, 0.0, 0.0);\n  TransformPoint( vPosdV, vUV + vec2(0.0, fDelta), time );\n\n  SurfaceInfo surfaceInfo;  \n  surfaceInfo.vPos = vPos;\n  surfaceInfo.vNormal = normalize(cross(vPosdV - vPos, vPosdU - vPos));\n\n  vec3 vViewPos = surfaceInfo.vPos;\n  vec2 vFov = vec2( 1.0, resolution.x / resolution.y ) * 4.0;\n  vec2 vScreenPos = vViewPos.xy * vFov;\n    \n  gl_Position = vec4( vScreenPos.xy, (1.0 / -vViewPos.z), vViewPos.z );\n\n  float stripes = 4.0;\n  vec3 vAlbedo = vec3(1.0);\n\n  float fTile = step( 0.5, fract( (quadTile.x * stripes / vShapeDim.x) ));\n  vAlbedo = mix( vec3(1.0, 0.01, 0.01), vec3(0.8, 0.8, 0.8), fTile );\n  \n  vec3 vColor = LightSurface( surfaceInfo, vAlbedo );  \n\n  vColor = ApplyVignetting( (vScreenPos.xy / vViewPos.z) * 0.5 + 0.5, vColor );  \n  \n  vColor = PostProcess( vColor );\n  \n  v_color = vec4(vColor, 1.0);\n}\n\nvoid main() \n{  \n\tif( vertexId < 64.0 * 6.0 )\n    {\n\t\tProcessBackdrop(vertexId);    \n    }\n  else\n  {\n\t\tProcessShape(vertexId - 64.0 * 6.0);\n  }\n  \n}\n"
  },
  "screenshotURL": "data/images/images-r3ddlegcc4cl04il4-thumbnail.jpg",
  "views": {
    "$numberInt": "128"
  },
  "likes": {
    "$numberInt": "0"
  },
  "revisionId": "PNW2mm6xieTaotsRA",
  "modifiedAt": {
    "$date": {
      "$numberLong": "1446222765297"
    }
  },
  "rank": {
    "$numberDouble": "1.5328379721451784"
  }
}