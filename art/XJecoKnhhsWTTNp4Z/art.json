{
  "_id": "XJecoKnhhsWTTNp4Z",
  "owner": {
    "username": "anon"
  },
  "createdAt": {
    "$date": {
      "$numberLong": "1446201202189"
    }
  },
  "origId": "PoyGoZL5Lmmn9N5SF",
  "name": "Jack-o'-lantern in a circle",
  "username": "-anon-",
  "settings": "{\"num\":100000,\"mode\":\"TRIANGLES\",\"sound\":\"\",\"lineSize\":\"NATIVE\",\"backgroundColor\":[0,0,0,1],\"shader\":\"\\n//\\n// Jack-o'-lantern\\n// @P_Malin\\n\\n#define kRaymarchMaxIter 64\\n\\n#define kBounceCount 1\\n\\n//#define SCENE_DOMAIN_REPEAT\\n\\nfloat kFarClip=100.0;\\n\\nvec2 GetWindowCoord( const in vec2 vUV );\\nvec3 GetCameraRayDir( const in vec2 vWindow, const in vec3 vCameraPos, const in vec3 vCameraTarget );\\nvec3 GetSceneColour( in vec3 vRayOrigin,  in vec3 vRayDir );\\nvec3 ApplyPostFX( const in vec2 vUV, const in vec3 vInput );\\n\\nfloat GetCarving2dDistance(const in vec2 vPos );\\n\\nvec3 vLightPos = vec3(0.0, -0.5, 0.0);\\t\\t\\t\\nvec3 vLightColour = vec3(1.0, 0.8, 0.4);\\n\\nfloat fCarving = 1.0;\\n\\n// from https://www.shadertoy.com/view/4djSRW\\nfloat hash(float p)\\n{\\n\\tvec2 p2 = fract(vec2(p * 5.3983, p * 5.4427));\\n    p2 += dot(p2.yx, p2.xy + vec2(21.5351, 14.3137));\\n\\treturn fract(p2.x * p2.y * 95.4337);\\n}\\n\\n// CAMERA\\n\\nvec2 GetWindowCoord( const in vec2 vUV )\\n{\\n\\tvec2 vWindow = vUV * 2.0 - 1.0;\\n\\tvWindow.x *= resolution.x / resolution.y;\\n\\n\\treturn vWindow;\\t\\n}\\n\\n\\nvec3 GetCameraRayDir( const in vec2 vWindow, const in vec3 vCameraPos, const in vec3 vCameraTarget )\\n{\\n\\tvec3 vForward = normalize(vCameraTarget - vCameraPos);\\n\\tvec3 vRight = normalize(cross(vec3(0.0, 1.0, 0.0), vForward));\\n\\tvec3 vUp = normalize(cross(vForward, vRight));\\n\\t\\t\\t\\t\\t\\t\\t  \\n\\tvec3 vDir = normalize(vWindow.x * vRight + vWindow.y * vUp + vForward * 1.5);\\n\\n\\treturn vDir;\\n}\\n\\n// POSTFX\\n\\nvec3 ApplyVignetting( const in vec2 vUV, const in vec3 vInput )\\n{\\n\\tvec2 vOffset = (vUV - 0.5) * sqrt(2.0);\\n\\t\\n\\tfloat fDist = dot(vOffset, vOffset);\\n\\t\\n\\tconst float kStrength = 0.95;\\n\\tconst float kPower = 1.5;\\n\\n\\treturn vInput * ((1.0 - kStrength) +  kStrength * pow(1.0 - fDist, kPower));\\n}\\n\\nvec3 ApplyTonemap( const in vec3 vLinear )\\n{\\n\\tfloat kExposure = 1.0;\\n    \\n\\treturn 1.0 - exp2(vLinear * -kExposure);\\t\\n}\\n\\nvec3 ApplyGamma( const in vec3 vLinear )\\n{\\n\\tconst float kGamma = 2.2;\\n\\n\\treturn pow(vLinear, vec3(1.0/kGamma));\\t\\n}\\n\\nvec3 ApplyBlackLevel( const in vec3 vColour )\\n{\\n    float fBlackLevel = 0.1;\\n    return vColour / (1.0 - fBlackLevel) - fBlackLevel;\\n}\\n\\nvec3 ApplyPostFX( const in vec2 vUV, const in vec3 vInput )\\n{\\n\\tvec3 vTemp = ApplyVignetting( vUV, vInput );\\t\\n\\t\\n\\tvTemp = ApplyTonemap(vTemp);\\n\\t\\n\\tvTemp = ApplyGamma(vTemp);\\t\\t\\n    \\n    vTemp = ApplyBlackLevel(vTemp);\\n    \\n    return vTemp;\\n}\\n\\t\\n// RAYTRACE\\n\\nstruct C_Intersection\\n{\\n\\tvec3 vPos;\\n\\tfloat fDist;\\t\\n\\tvec3 vNormal;\\n\\tvec3 vUVW;\\n\\tfloat fObjectId;\\n};\\n\\nfloat GetCarving2dDistance(const in vec2 vPos )\\n{\\n    if(fCarving < 0.0)\\n        return 10.0;\\n    \\n\\tfloat fMouthDist = length(vPos.xy + vec2(0.0, -0.5)) - 1.5;\\n\\tfloat fMouthDist2 = length(vPos.xy + vec2(0.0, -1.1 - 0.5)) - 2.0;\\n\\t\\n\\tif(-fMouthDist2 > fMouthDist )\\n\\t{\\n\\t\\tfMouthDist = -fMouthDist2;\\n\\t}\\n\\n    float fFaceDist = fMouthDist;\\n\\n    vec2 vNosePos = vPos.xy + vec2(0.0, -0.5);\\n    vNosePos.x = abs(vNosePos.x);\\n    float fNoseDist = dot(vNosePos.xy, normalize(vec2(1.0, 0.5)));\\n    fNoseDist = max(fNoseDist, -(vNosePos.y + 0.5));\\n    if(fNoseDist < fFaceDist)\\n    {\\n        fFaceDist = fNoseDist;\\n    }\\n\\n\\n    vec2 vEyePos = vPos.xy;\\n    vEyePos.x = abs(vEyePos.x);\\n    vEyePos.x -= 1.0;\\n    vEyePos.y -= 1.0;\\n    float fEyeDist = dot(vEyePos.xy, normalize(vec2(-1.0, 1.5)));\\n    fEyeDist = max(fEyeDist, dot(vEyePos.xy, normalize(vec2(1.0, 0.5))));\\n    fEyeDist = max(fEyeDist, -0.5+dot(vEyePos.xy, normalize(vec2(0.0, -1.0))));\\n    if(fEyeDist < fFaceDist)\\n    {\\n        fFaceDist = fEyeDist;\\n    }\\n    \\n    return fFaceDist;\\n}\\n\\nfloat GetCarvingDistance(const in vec3 vPos )\\n{\\n\\tfloat fDist = (length(vPos * vec3(1.0, 1.4, 1.0)) - 2.7) / 1.5;\\n\\n    float fFaceDist = GetCarving2dDistance(vPos.xy);\\n    \\n\\tfloat fRearDist = vPos.z;\\n\\t\\n\\tif(fRearDist > fFaceDist)\\n\\t{\\n\\t\\tfFaceDist = fRearDist;\\n\\t}\\t\\n\\t\\n\\tif(fFaceDist < fDist )\\n\\t{\\n\\t\\tfDist = fFaceDist;\\n\\t}\\n\\n    float fR = length(vPos.xz);\\n    \\n    float fLidDist = dot( vec2(fR, vPos.y), normalize(vec2(1.0, -1.5)));\\n    \\n    fLidDist = abs(fLidDist) - 0.03;\\n\\tif(fLidDist < fDist )\\n\\t{\\n\\t\\tfDist = fLidDist;\\n\\t}\\n    \\n\\treturn fDist;\\n}\\n\\nfloat GetPumpkinDistance( out vec4 vOutUVW_Id, const in vec3 vPos )\\n{\\n    vec3 vSphereOrigin = vec3(0.0, 0.0, 0.0);\\n    float fSphereRadius = 3.0;\\n\\n\\tvec3 vOffset = vPos - vSphereOrigin;\\n\\tfloat fFirstDist = length(vOffset);\\n\\t\\n\\tfloat fOutDist;\\n\\tif(fFirstDist > 3.5)\\n\\t{\\n\\t\\tfOutDist = fFirstDist - fSphereRadius;\\n\\t}\\n\\telse\\n\\t{\\n\\t\\tfloat fAngle1 = atan(vOffset.x, vOffset.z);\\n\\t\\tfloat fSin = sin(fAngle1 * 10.0);\\n\\t\\tfSin = 1.0 - sqrt(abs(fSin));\\n\\t\\tvOffset *= 1.0 + fSin * vec3(0.05, 0.025, 0.05);\\n\\t\\tvOffset.y *= 1.0 + 0.5 * (fSphereRadius - length(vOffset.xz)) / fSphereRadius;\\n\\t\\tfOutDist = length(vOffset) - fSphereRadius;\\n\\t}\\n\\t\\n\\n\\tvec4 vSphere1UVW_Id = vec4(normalize(vPos - vSphereOrigin), 3.0);\\n\\tvOutUVW_Id = vSphere1UVW_Id;\\n\\t\\n\\tvec3 vStalkOffset = vPos;\\n\\tvStalkOffset.x += -(vStalkOffset.y - fSphereRadius) * 0.1;\\n\\tfloat fDist2d = length(vStalkOffset.xz);\\n\\tfloat fStalkDist = fDist2d - 0.2;\\n\\tfStalkDist = max(fStalkDist, vPos.y - 2.5 + vPos.x * 0.25);\\n\\tfStalkDist = max(fStalkDist, -vPos.y);\\n\\tif( fStalkDist < fOutDist )\\n\\t{\\n\\t\\tfOutDist = fStalkDist;\\n\\t\\tvOutUVW_Id = vSphere1UVW_Id;\\n\\t\\tvOutUVW_Id.w = 2.0;\\n\\t}\\n\\n\\treturn fOutDist;\\n}\\n\\nfloat GetSceneDistance( out vec4 vOutUVW_Id, const in vec3 vPos )\\n{\\n\\tfloat fFloorDist = vPos.y + 2.0;\\n\\tvec4 vFloorUVW_Id = vec4(vPos.xz, 0.0, 1.0);\\n\\n\\t\\n\\tvec3 vPumpkinDomain = vPos;\\n\\n#ifdef SCENE_DOMAIN_REPEAT\\n\\tfloat fRepeat = 12.0;\\n\\tfloat fOffset = (fRepeat * 0.5);\\n\\tvPumpkinDomain.xz = fract((vPos.xz + fOffset) / fRepeat) * fRepeat - fOffset;\\n#endif \\n    \\n\\tfloat fOutDist = fFloorDist;\\n\\tvOutUVW_Id = vFloorUVW_Id;\\n\\n\\tvec4 vPumpkinUVW_Id;\\n\\tfloat fPumpkinDist = GetPumpkinDistance( vPumpkinUVW_Id, vPumpkinDomain );\\n\\n\\tfloat fCarvingDist = GetCarvingDistance( vPumpkinDomain );\\n\\t\\n\\tif(-fCarvingDist > fPumpkinDist)\\n\\t{\\n\\t\\tfPumpkinDist = -fCarvingDist;\\n\\t\\tvPumpkinUVW_Id = vec4(4.0);\\n\\t}\\n\\n\\t\\n\\tif(fPumpkinDist < fOutDist)\\n\\t{\\n\\t\\tfOutDist = fPumpkinDist;\\n\\t\\tvOutUVW_Id = vPumpkinUVW_Id;\\n\\t}\\n\\t\\n\\treturn fOutDist;\\n}\\n\\nvec3 GetSceneNormal(const in vec3 vPos)\\n{\\n    const float fDelta = 0.001;\\n\\n    vec3 vDir1 = vec3( 1.0, -1.0, -1.0);\\n    vec3 vDir2 = vec3(-1.0, -1.0,  1.0);\\n    vec3 vDir3 = vec3(-1.0,  1.0, -1.0);\\n    vec3 vDir4 = vec3( 1.0,  1.0,  1.0);\\n\\t\\n    vec3 vOffset1 = vDir1 * fDelta;\\n    vec3 vOffset2 = vDir2 * fDelta;\\n    vec3 vOffset3 = vDir3 * fDelta;\\n    vec3 vOffset4 = vDir4 * fDelta;\\n\\n\\tvec4 vUnused;\\n    float f1 = GetSceneDistance( vUnused, vPos + vOffset1 );\\n    float f2 = GetSceneDistance( vUnused, vPos + vOffset2 );\\n    float f3 = GetSceneDistance( vUnused, vPos + vOffset3 );\\n    float f4 = GetSceneDistance( vUnused, vPos + vOffset4 );\\n\\t\\n    vec3 vNormal = vDir1 * f1 + vDir2 * f2 + vDir3 * f3 + vDir4 * f4;\\t\\n\\t\\t\\n    return normalize( vNormal );\\n}\\n\\nvoid TraceScene( out C_Intersection outIntersection, const in vec3 vOrigin, const in vec3 vDir )\\n{\\t\\n\\tvec4 vUVW_Id = vec4(0.0);\\t\\t\\n\\tvec3 vPos = vec3(0.0);\\n\\t\\n\\tfloat t = 0.01;\\n\\tfor(int i=0; i<kRaymarchMaxIter; i++)\\n\\t{\\n\\t\\tvPos = vOrigin + vDir * t;\\n\\t\\tfloat fDist = GetSceneDistance(vUVW_Id, vPos);\\t\\t\\n\\t\\tt += fDist;\\n\\t\\tif(abs(fDist) < 0.001)\\n\\t\\t{\\n\\t\\t\\tbreak;\\n\\t\\t}\\t\\t\\n\\t\\tif(t > 100.0)\\n\\t\\t{\\n\\t\\t\\tt = kFarClip;\\n\\t\\t\\tvPos = vOrigin + vDir * t;\\n\\t\\t\\tvUVW_Id = vec4(0.0);\\n\\t\\t\\tbreak;\\n\\t\\t}\\n\\t}\\n\\t\\n\\toutIntersection.fDist = t;\\n\\toutIntersection.vPos = vPos;\\n\\toutIntersection.vNormal = GetSceneNormal(vPos);\\n\\toutIntersection.vUVW = vUVW_Id.xyz;\\n\\toutIntersection.fObjectId = vUVW_Id.w;\\n}\\n\\n\\nfloat TraceShadow( const in vec3 vOrigin, const in vec3 vDir, const in float fDist )\\n{\\n    C_Intersection shadowIntersection;\\n\\tTraceScene(shadowIntersection, vOrigin, vDir);\\n\\tif(shadowIntersection.fDist < fDist) \\n\\t{\\n\\t\\treturn 0.0;\\t\\t\\n\\t}\\n\\t\\n\\treturn 1.0;\\n}\\n\\nfloat GetSSS( const in vec3 vPos, const in vec3 vLightPos )\\n{\\n    vec3 vLightToPos = vPos - vLightPos;\\n    vec3 vDir = normalize(vLightToPos);\\n    \\n\\tC_Intersection intersection;\\n\\tTraceScene(intersection, vLightPos, vDir);\\n\\tfloat fOpticalDepth = length(vLightToPos) - intersection.fDist;\\n\\n    fOpticalDepth = max(0.00001, fOpticalDepth);\\n    \\n\\treturn exp2( fOpticalDepth * -8.0 );\\n}\\n\\n// LIGHTING\\n\\nfloat GIV( float dotNV, float k)\\n{\\n\\treturn 1.0 / ((dotNV + 0.0001) * (1.0 - k)+k);\\n}\\n\\nvoid AddLighting(inout vec3 vDiffuseLight, inout vec3 vSpecularLight, const in vec3 vViewDir, const in vec3 vLightDir, const in vec3 vNormal, const in float fSmoothness, const in vec3 vLightColour)\\n{\\n\\tvec3 vH = normalize( -vViewDir + vLightDir );\\n\\tfloat fNDotL = clamp(dot(vLightDir, vNormal), 0.0, 1.0);\\n\\tfloat fNDotV = clamp(dot(-vViewDir, vNormal), 0.0, 1.0);\\n\\tfloat fNDotH = clamp(dot(vNormal, vH), 0.0, 1.0);\\n\\t\\n\\tfloat alpha = 1.0 - fSmoothness;\\n\\talpha = alpha * alpha;\\n\\t// D\\n\\n\\tfloat alphaSqr = alpha * alpha;\\n\\tfloat pi = 3.14159;\\n\\tfloat denom = fNDotH * fNDotH * (alphaSqr - 1.0) + 1.0;\\n\\tfloat d = alphaSqr / (pi * denom * denom);\\n\\n\\tfloat k = alpha / 2.0;\\n\\tfloat vis = GIV(fNDotL, k) * GIV(fNDotV, k);\\n\\n\\tfloat fSpecularIntensity = d * vis * fNDotL;\\n\\tvSpecularLight += vLightColour * fSpecularIntensity;\\n\\n\\tvDiffuseLight += vLightColour * fNDotL;\\n}\\n\\nvoid AddPointLight(inout vec3 vDiffuseLight, inout vec3 vSpecularLight, const in vec3 vViewDir, const in vec3 vPos, const in vec3 vNormal, const in float fSmoothness, const in vec3 vLightPos, const in vec3 vLightColour)\\n{\\n\\tvec3 vToLight = vLightPos - vPos;\\t\\n\\tfloat fDistance2 = dot(vToLight, vToLight);\\n\\tfloat fAttenuation = 100.0 / (fDistance2);\\n\\tvec3 vLightDir = normalize(vToLight);\\n\\t\\n\\tvec3 vShadowRayDir = vLightDir;\\n\\tvec3 vShadowRayOrigin = vPos + vShadowRayDir * 0.01;\\n\\tfloat fShadowFactor = TraceShadow(vShadowRayOrigin, vShadowRayDir, length(vToLight));\\n\\t\\n\\tAddLighting(vDiffuseLight, vSpecularLight, vViewDir, vLightDir, vNormal, fSmoothness, vLightColour * fShadowFactor * fAttenuation);\\n}\\n\\nfloat AddDirectionalLight(inout vec3 vDiffuseLight, inout vec3 vSpecularLight, const in vec3 vViewDir, const in vec3 vPos, const in vec3 vNormal, const in float fSmoothness, const in vec3 vLightDir, const in vec3 vLightColour)\\n{\\t\\n\\tfloat fAttenuation = 1.0;\\n\\n\\tvec3 vShadowRayDir = -vLightDir;\\n\\tvec3 vShadowRayOrigin = vPos + vShadowRayDir * 0.01;\\n\\tfloat fShadowFactor = TraceShadow(vShadowRayOrigin, vShadowRayDir, 10.0);\\n\\t\\n\\tAddLighting(vDiffuseLight, vSpecularLight, vViewDir, -vLightDir, vNormal, fSmoothness, vLightColour * fShadowFactor * fAttenuation);\\t\\n    \\n    return fShadowFactor;\\n}\\n\\nvoid AddDirectionalLightFlareToFog(inout vec3 vFogColour, const in vec3 vRayDir, const in vec3 vLightDir, const in vec3 vLightColour)\\n{\\n\\tfloat fDirDot = clamp(dot(-vLightDir, vRayDir), 0.0, 1.0);\\n\\tfloat kSpreadPower = 4.0;\\n\\tvFogColour += vLightColour * pow(fDirDot, kSpreadPower);\\n}\\n\\n// SCENE MATERIALS\\n\\n#define MOD2 vec2(4.438975,3.972973)\\n\\nfloat Hash( float p ) \\n{\\n    // https://www.shadertoy.com/view/4djSRW - Dave Hoskins\\n\\tvec2 p2 = fract(vec2(p) * MOD2);\\n    p2 += dot(p2.yx, p2.xy+19.19);\\n\\treturn fract(p2.x * p2.y);    \\n\\t//return fract(sin(n)*43758.5453);\\n}\\n\\nfloat SmoothNoise(in vec2 o) \\n{\\n\\tvec2 p = floor(o);\\n\\tvec2 f = fract(o);\\n\\t\\t\\n\\tfloat n = p.x + p.y*57.0;\\n\\n\\tfloat a = Hash(n+  0.0);\\n\\tfloat b = Hash(n+  1.0);\\n\\tfloat c = Hash(n+ 57.0);\\n\\tfloat d = Hash(n+ 58.0);\\n\\t\\n\\tvec2 f2 = f * f;\\n\\tvec2 f3 = f2 * f;\\n\\t\\n\\tvec2 t = 3.0 * f2 - 2.0 * f3;\\n\\t\\n\\tfloat u = t.x;\\n\\tfloat v = t.y;\\n\\n\\tfloat res = a + (b-a)*u +(c-a)*v + (a-b+d-c)*u*v;\\n    \\n    return res;\\n}\\n\\n#define k_fmbSteps 10\\nfloat FBM( vec2 p, float ps ) {\\n\\tfloat f = 0.0;\\n    float tot = 0.0;\\n    float a = 1.0;\\n    for( int i=0; i<k_fmbSteps; i++)\\n    {\\n        f += SmoothNoise( p ) * a;\\n        p *= 2.0;\\n        tot += a;\\n        a *= ps;\\n    }\\n    return f / tot;\\n}\\n\\n\\nvec3 SampleFloorTexture( vec2 vUV )\\n{\\n  return vec3(FBM( vUV * 25.0, 0.5) );\\n}\\n\\nvoid GetSurfaceInfo(out vec3 vOutAlbedo, out vec3 vOutR0, out float fOutSmoothness, out vec3 vOutBumpNormal, const in C_Intersection intersection )\\n{\\n\\tvOutBumpNormal = intersection.vNormal;\\n\\t\\n\\tif(intersection.fObjectId == 1.0)\\n\\t{\\n\\t\\tvec2 vUV = intersection.vUVW.xy * 0.1;\\n\\t\\tvOutAlbedo = SampleFloorTexture(vUV).rgb;\\n\\t\\tfloat fBumpScale = 10.0;\\n\\t\\t\\n\\t\\tvec2 vRes = vec2(256.0); // texture resolution\\n\\t\\tvec2 vDU = vec2(1.0, 0.0) / vRes;\\n\\t\\tvec2 vDV = vec2(0.0, 1.0) / vRes;\\n\\t\\t\\n\\t\\tfloat fSampleW = SampleFloorTexture( vUV - vDU).r;\\n\\t\\tfloat fSampleE = SampleFloorTexture( vUV + vDU).r;\\n\\t\\tfloat fSampleN = SampleFloorTexture( vUV - vDV).r;\\n\\t\\tfloat fSampleS = SampleFloorTexture( vUV + vDV).r;\\n\\t\\t\\n\\t\\tvec3 vNormalDelta = vec3(0.0);\\n\\t\\tvNormalDelta.x += \\n\\t\\t\\t( fSampleW * fSampleW\\n\\t\\t\\t - fSampleE * fSampleE) * fBumpScale;\\n\\t\\tvNormalDelta.z += \\n\\t\\t\\t(fSampleN * fSampleN\\n\\t\\t\\t - fSampleS * fSampleS) * fBumpScale;\\n\\t\\t\\n\\t\\tvOutBumpNormal = normalize(vOutBumpNormal + vNormalDelta);\\n\\n\\t\\tvOutAlbedo = vOutAlbedo * vOutAlbedo;\\t\\n\\t\\tfOutSmoothness = clamp((0.8 - vOutAlbedo.r * 4.0), 0.0, 1.0);\\n\\t\\t\\n\\t\\tvOutR0 = vec3(0.01) * vOutAlbedo.g;\\n\\t}\\n\\telse if(intersection.fObjectId == 2.0)\\n\\t{\\n\\t\\tvOutAlbedo = vec3(0.5, 0.5, 0.2);\\n\\t\\tfOutSmoothness = 0.4;\\n\\t\\tvOutR0 = vec3(0.05);\\n\\t}\\n\\telse if(intersection.fObjectId == 3.0)\\n\\t{\\n        float fAngle = atan(intersection.vUVW.x, intersection.vUVW.z);\\n        vec2 vUV = vec2(fAngle, intersection.vUVW.y) * vec2(1.0, 0.2) * 8.0;\\n\\t\\tvOutAlbedo = vec3(0.5);//texture2D(iChannel1, vUV).rgb;\\n\\t\\tfOutSmoothness = clamp(1.0 - vOutAlbedo.r * vOutAlbedo.r * 2.0, 0.0, 1.0);\\t\\t\\t\\n\\t\\tvec3 vCol1 = vec3(1.0, 0.5, 0.0);\\n\\t\\tvec3 vCol2 = vec3(0.5, 0.06, 0.0);\\n\\t\\tvOutAlbedo = mix(vCol1, vCol2, vOutAlbedo.r * 0.5).rgb;\\n\\t\\tvOutR0 = vec3(0.05);\\n\\t}\\n\\telse if(intersection.fObjectId == 4.0)\\n    {\\n\\t\\tvOutAlbedo = vec3(1.0, 0.824, 0.301);\\n\\t\\tfOutSmoothness = 0.4;\\n\\t\\tvOutR0 = vec3(0.05);\\n\\t}\\n}\\n\\nvec3 GetSkyColour( const in vec3 vDir )\\n{\\t\\n\\tvec3 vResult = mix(vec3(0.02, 0.04, 0.06), vec3(0.1, 0.5, 0.8), abs(vDir.y));\\n\\t\\n\\treturn vResult;\\t\\n}\\n\\nfloat GetFogFactor(const in float fDist)\\n{\\n\\tfloat kFogDensity = 0.025;\\n\\treturn exp(fDist * -kFogDensity);\\t\\n}\\n\\nvec3 GetFogColour(const in vec3 vDir)\\n{\\n\\treturn vec3(0.01);\\t\\t\\n}\\n\\nvec3 vSunLightColour = vec3(0.1, 0.2, 0.3) * 5.0;\\nvec3 vSunLightDir = normalize(vec3(0.4, -0.3, -0.5));\\n\\t\\nvoid ApplyAtmosphere(inout vec3 vColour, const in float fDist, const in vec3 vRayOrigin, const in vec3 vRayDir)\\n{\\t\\t\\n\\tfloat fFogFactor = GetFogFactor(fDist);\\n\\tvec3 vFogColour = GetFogColour(vRayDir);\\t\\t\\t\\n\\tAddDirectionalLightFlareToFog(vFogColour, vRayDir, vSunLightDir, vSunLightColour);\\n\\t\\n\\tvColour = mix(vFogColour, vColour, fFogFactor);\\t\\n}\\n\\n// TRACING LOOP\\n\\n\\t\\nvec3 GetSceneColour( in vec3 _vRayOrigin,  in vec3 _vRayDir, inout float fHitDist, inout vec3 vHitNormal )\\n{\\n    vec3 vRayOrigin = _vRayOrigin;\\n    vec3 vRayDir = _vRayDir;\\n\\tvec3 vColour = vec3(0.0);\\n\\tvec3 vRemaining = vec3(1.0);\\n\\t\\n    float fLastShadow = 1.0;\\n   \\n    \\n\\tfor(int i=0; i<kBounceCount; i++)\\n\\t{\\t\\n\\t\\tvec3 vCurrRemaining = vRemaining;\\n\\t\\tfloat fShouldApply = 1.0;\\n\\t\\t\\n\\t\\tC_Intersection intersection;\\t\\t\\t\\t\\n\\t\\tTraceScene( intersection, vRayOrigin, vRayDir );\\n\\n        if( i == 0 )\\n        {\\n          fHitDist = intersection.fDist;\\n          vHitNormal = intersection.vNormal;\\n        }\\n      \\n\\t\\tvec3 vResult = vec3(0.0);\\n\\t\\tvec3 vBlendFactor = vec3(0.0);\\n\\t\\t\\t\\t\\t\\t\\n\\t\\tif(intersection.fObjectId == 0.0)\\n\\t\\t{\\n\\t\\t\\tvBlendFactor = vec3(1.0);\\n\\t\\t\\tfShouldApply = 0.0;\\n\\t\\t}\\n\\t\\telse\\n\\t\\t{\\t\\t\\n\\t\\t\\tvec3 vAlbedo;\\n\\t\\t\\tvec3 vR0;\\n\\t\\t\\tfloat fSmoothness;\\n\\t\\t\\tvec3 vBumpNormal;\\n\\t\\t\\t\\n\\t\\t\\tGetSurfaceInfo( vAlbedo, vR0, fSmoothness, vBumpNormal, intersection );\\t\\t\\t\\n\\t\\t\\n\\t\\t\\tvec3 vDiffuseLight = vec3(0.0);\\n\\t\\t\\tvec3 vSpecularLight = vec3(0.0);\\n\\n            fLastShadow = AddDirectionalLight(vDiffuseLight, vSpecularLight, vRayDir, intersection.vPos, vBumpNormal, fSmoothness, vSunLightDir, vSunLightColour);\\t\\t\\t\\t\\t\\t\\t\\t\\n\\n            vec3 vPointLightPos = vLightPos;\\n            #ifdef SCENE_DOMAIN_REPEAT\\n                float fRepeat = 12.0;\\n                float fOffset = (fRepeat * 0.5);\\n                vec2 vTile = floor((intersection.vPos.xz + fOffset) / fRepeat);\\n            \\tvPointLightPos.xz += vTile * fRepeat;\\n            #endif             \\n            \\n\\t\\t\\tAddPointLight(vDiffuseLight, vSpecularLight, vRayDir, intersection.vPos, vBumpNormal, fSmoothness, vPointLightPos, vLightColour);\\t\\t\\t\\t\\t\\t\\t\\t\\n\\n            if(intersection.fObjectId >= 3.0)\\n            {\\n                vDiffuseLight += GetSSS(intersection.vPos, vPointLightPos) * vLightColour;\\n            }\\n            else\\n            {\\n                vec3 vToLight = vPointLightPos - intersection.vPos;\\n                float fNdotL = dot(normalize(vToLight), vBumpNormal) * 0.5 + 0.5;\\n\\t\\t\\t\\tvDiffuseLight += max(0.0, 1.0 - length(vToLight)/5.0) * vLightColour * fNdotL;                \\n            }\\n\\n\\t\\t\\tfloat fSmoothFactor = fSmoothness * 0.9 + 0.1;\\n            float fFresnelClamp = 0.25; // too much fresnel produces sparkly artefacts\\n            float fNdotD = clamp(dot(vBumpNormal, -vRayDir), fFresnelClamp, 1.0);\\n\\t\\t\\tvec3 vFresnel = vR0 + (1.0 - vR0) * pow(1.0 - fNdotD, 5.0) * fSmoothFactor;\\n\\n            \\n\\t\\t\\tvResult = mix(vAlbedo * vDiffuseLight, vSpecularLight, vFresnel);\\t\\t\\n\\t\\t\\tvBlendFactor = vFresnel;\\n\\t\\t\\t\\n\\t\\t\\tApplyAtmosphere(vResult, intersection.fDist, vRayOrigin, vRayDir);\\t\\t\\n\\t\\t\\t\\n\\t\\t\\tvRemaining *= vBlendFactor;\\t\\t\\t\\t\\n\\t\\t\\tvRayDir = normalize(reflect(vRayDir, vBumpNormal));\\n\\t\\t\\tvRayOrigin = intersection.vPos;\\n\\t\\t}\\t\\t\\t\\n\\n\\t\\tvColour += vResult * vCurrRemaining * fShouldApply;\\t\\n\\t}\\n\\n\\tvec3 vSkyColor = GetSkyColour(vRayDir);\\n\\t\\n\\tApplyAtmosphere(vSkyColor, kFarClip, vRayOrigin, vRayDir);\\t\\t\\n\\t\\n    // Hack for this scene when using 1 bounce.\\n    // remove final sky reflection when in shadow\\n    vSkyColor *= fLastShadow; \\n    \\n\\tvColour += vSkyColor * vRemaining;\\n\\t\\n    // Face glow\\n    float t = -(_vRayOrigin.z + 2.8) / _vRayDir.z;\\n    \\n    if( t > 0.0 )\\n    {\\n        vec3 vPos = _vRayOrigin + _vRayDir * t;\\n\\n        float fDist = abs(GetCarving2dDistance(vPos.xy * vec2(1.0, 1.0)));\\n        float fDot = max(0.0, _vRayDir.z);\\n        fDot = fDot * fDot;\\n        vColour += exp2(-fDist * 10.0) * fDot * vLightColour * 0.25;\\n    }\\n    \\n    \\n\\treturn vColour;\\n}\\n\\n\\n\\n#define MOD3 vec3(.1031,.11369,.13787)\\n#define MOD4 vec4(.1031,.11369,.13787, .09987)\\n#define TAU 6.283\\n\\nvec2 hash21(float p)\\n{\\n\\tvec3 p3 = fract(vec3(p) * MOD3);\\n\\tp3 += dot(p3, p3.yzx + 19.19);\\n\\treturn fract(vec2((p3.x + p3.y)*p3.z, (p3.x+p3.z)*p3.y));\\n}\\n\\nvec2 Rotate( const in vec2 vPos, const in float fAngle )\\n{\\n    float s = sin(fAngle);\\n    float c = cos(fAngle);\\n    \\n    vec2 vResult = vec2( c * vPos.x + s * vPos.y, -s * vPos.x + c * vPos.y);\\n    \\n    return vResult;\\n}\\n\\n/// radius, angle to x, y\\nvec2 euclidFromRadial(in vec2 rad)\\n{\\n  float s = sin(rad.y * TAU);\\n  float c = cos(rad.y * TAU);\\n  float xf = resolution.y / resolution.x;\\n  float yf = 1.0;\\n  if (xf > 1.0) {yf = 1.0 / xf; xf = 1.0;}\\n  return vec2(rad.x * xf * 0.5 * c + 0.5, rad.x * yf * 0.5 * s + 0.5);\\n}\\n\\nvoid main() \\n{\\n  float fTriangleIndex = floor( vertexId / 3.0 ) + time;\\n  float fTriangleVertexIndex = mod( vertexId, 3.0 );\\n  \\n  vec2 vUV = hash21( fTriangleIndex );\\n  vUV = euclidFromRadial(vUV);\\n  \\n  \\tfloat fSize = 1.0;\\n\\n    float fDist = 7.0;\\n\\n    float fAngle = radians(190.0) + sin(time * 0.25) * 0.2;\\n    float fHeight = 2.0 + sin(time * 0.1567) * 1.5;\\n        \\n\\tvec3 vCameraPos = vec3(sin(fAngle) * fDist, fHeight, cos(fAngle) * fDist);\\n\\tvec3 vCameraTarget = vec3(0.0, -0.5, 0.0);\\n  \\n\\tvec3 vRayOrigin = vCameraPos;\\n\\tvec3 vRayDir = GetCameraRayDir( GetWindowCoord(vUV), vCameraPos, vCameraTarget );\\n\\t\\n  \\tfloat fHitDist = 0.0;\\n  \\tvec3 vHitNormal = vec3(0.0);\\n\\tvec3 vResult = GetSceneColour(vRayOrigin, vRayDir, fHitDist, vHitNormal);\\n\\t    \\n\\tvec3 vFinal = ApplyPostFX( vUV, vResult );\\n\\n\\n  //fSize = 0.05 / fHitDist;\\n  fSize *= 0.01;\\n  fSize *= 0.5 + vFinal.x * vFinal.y * 0.5;\\n  vec2 vOffset = vec2(0.0);\\n  \\n  \\n  if( fTriangleVertexIndex < 0.5 )\\n  {\\n    vOffset.y += fSize;\\n  }\\n  else if( fTriangleVertexIndex < 1.5 )\\n  {\\n    vOffset.x -= fSize;\\n  }\\n  else if( fTriangleVertexIndex < 2.5 )\\n  {\\n    vOffset.x += fSize;\\n  }\\n  \\n  vOffset = Rotate( vOffset, fTriangleIndex );\\n  vUV += vOffset;\\n\\n  vUV.xy = vUV.xy * 2.0 - 1.0;\\n     \\n  gl_Position = vec4(vUV.xy * fHitDist, 0, fHitDist);\\n  v_color = vec4(vFinal, 1.0);\\n\\n}\"}",
  "screenshotURL": "data/images/images-yk73gvuuppe0thfs6-thumbnail.jpg",
  "views": {
    "$numberInt": "575"
  },
  "likes": {
    "$numberInt": "0"
  },
  "revisionId": "cmmaeEooC4kZwiNps",
  "modifiedAt": {
    "$date": {
      "$numberLong": "1446201202201"
    }
  },
  "rank": {
    "$numberDouble": "1.4943990241568306"
  }
}