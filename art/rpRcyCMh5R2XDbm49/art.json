{
  "_id": "rpRcyCMh5R2XDbm49",
  "owner": {
    "_id": "cZNAKnfHAY6mZAn2h",
    "createdAt": {
      "$date": {
        "$numberLong": "1598366337757"
      }
    },
    "username": "morimea",
    "profile": {
      "avatarUrl": "https://secure.gravatar.com/avatar/8ff4b4cacdf52d8d31a020cd244c5269?default=retro&size=200",
      "info": "https://www.shadertoy.com/user/morimea"
    }
  },
  "createdAt": {
    "$date": {
      "$numberLong": "1616536594181"
    }
  },
  "modifiedAt": {
    "$date": {
      "$numberLong": "1616537874893"
    }
  },
  "origId": null,
  "name": "CSG voxels vertex",
  "notes": "CSG template",
  "rank": {
    "$numberDouble": "1.3461836902402706"
  },
  "private": false,
  "unlisted": true,
  "username": "morimea",
  "avatarUrl": "https://secure.gravatar.com/avatar/8ff4b4cacdf52d8d31a020cd244c5269?default=retro&size=200",
  "settings": "{\"num\":60750,\"mode\":\"TRIANGLES\",\"sound\":\"\",\"lineSize\":\"NATIVE\",\"backgroundColor\":[0.043137254901960784,0.0392156862745098,0.03529411764705882,1],\"shader\":\"  //#define vertexId float(gl_InstanceID+gl_VertexID)\\n\\n\\n  // default number of particles 15*15*15*6*3=60750 15 is cube size\\n\\n  const float size=1.; \\n\\n  //out vec4 v_color;\\n\\n  const float PI = 3.1415926535898;\\n\\n  const float VertX = 15.0;\\n  const float VertY = 15.0;\\n\\n  const float tscale = 0.2;\\n  const vec3 obj_pos = vec3(-1.5);\\n\\n  mat3 rotx(float a){float s = sin(a);float c = cos(a);return mat3(vec3(1.0, 0.0, 0.0), vec3(0.0, c, s), vec3(0.0, -s, c));  }\\n  mat3 roty(float a){float s = sin(a);float c = cos(a);return mat3(vec3(c, 0.0, s), vec3(0.0, 1.0, 0.0), vec3(-s, 0.0, c));}\\n  mat3 rotz(float a){float s = sin(a);float c = cos(a);return mat3(vec3(c, s, 0.0), vec3(-s, c, 0.0), vec3(0.0, 0.0, 1.0 ));}\\n\\n\\n  const float degree_to_rad = PI / 180.0;\\n\\n  mat4 perspectiveMatrix(float fovYInRad, float aspectRatio)\\n  {\\n      float yScale = 1.0 / tan(fovYInRad / 2.0);\\n      float xScale = yScale / aspectRatio;\\n      float zf = 100.0;\\n      float zn = 0.3;\\n\\n      float z1 = zf / (zf - zn);\\n      float z2 = -zn * zf / (zf - zn);\\n\\n      mat4 result = mat4(xScale, 0.0, 0.0, 0.0, 0.0, yScale, 0.0, 0.0, 0.0, 0.0, -z1, -1., 0.0, 0.0, z2, 0.0);\\n\\n      return result;\\n  }\\n\\n  mat4 lookat(vec3 eye, vec3 look, vec3 up)\\n  {\\n      vec3 z = normalize(eye - look);\\n      vec3 x = normalize(cross(up, z));\\n      vec3 y = cross(z, x);\\n      return mat4(x.x, y.x, z.x, 0.0, x.y, y.y, z.y, 0.0, x.z, y.z, z.z, 0.0, 0.0, 0.0, 0.0, 1.0) *\\n             mat4(1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, -eye.x, -eye.y, -eye.z, 1.0);\\n  }\\n\\n  vec3 voxelPosToWorld(vec3 vp)\\n  {\\n      return vp * (tscale / (size)) + obj_pos;\\n  }\\n\\n  float sphereSDF(vec3 p, float r)\\n  {\\n      return length(p) - r;\\n  }\\n\\n  float sdBox( vec3 p, vec3 b )\\n  {\\n    vec3 q = abs(p) - b;\\n    return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\\n  }\\n\\n  float sdfUnion( const float a, const float b )\\n  {\\n      return min(a, b);\\n  }\\n\\n  float sdfDifference( const float a, const float b)\\n  {\\n      return max(a, -b);\\n  }\\n\\n  float sdfIntersection( const float a, const float b )\\n  {\\n      return max(a, b);\\n  }\\n\\n  float scene(vec3 p)\\n  {\\n      float d = 0.0;\\n      d = sdfDifference(sphereSDF(p + vec3(0., 0.3, 0.), .8),\\n                        sphereSDF(p + vec3(0., -0.6 + 0.6 * sin(time), 0.), .7));\\n      d = sdfDifference(sdBox(p + vec3(0., 0.3, 0.), vec3(.8)),\\n                        sphereSDF(p + vec3(0., -0.6 + 0.6 * sin(time), 0.), .7));\\n\\n      return d;\\n  }\\n\\n  vec3 sceneNormal(vec3 p)\\n  {\\n      vec3 EPS = vec3(0.01, 0.0, 0.0);\\n      vec3 n;\\n      n.x = scene(p + EPS.xyz) - scene(p - EPS.xyz);\\n      n.y = scene(p + EPS.zxy) - scene(p - EPS.zxy);\\n      n.z = scene(p + EPS.yzx) - scene(p - EPS.yzx);\\n      return normalize(n);\\n  }\\n\\n  vec3 vertexSmooth(vec3 ip)\\n  {\\n      vec3 p = ip;\\n      vec3 n = sceneNormal(p);\\n      for (int i = 0; i < 8; i++)\\n      {\\n          float d = scene(p);\\n          p -= n * d;\\n          if (abs(d) < 0.01)\\n          {\\n              break;\\n          }\\n      }\\n      return p;\\n  }\\n\\n  vec3 phongContribForLight(vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye, vec3 lightPos, vec3 lightIntensity, vec3 N)\\n  {\\n      vec3 L = normalize(lightPos - p);\\n      vec3 V = normalize(eye - p);\\n      vec3 R = normalize(reflect(-L, N));\\n\\n      float dotLN = dot(L, N);\\n      float dotRV = dot(R, V);\\n\\n      if (dotLN < 0.0)\\n      {\\n          return vec3(0.0, 0.0, 0.0);\\n      }\\n\\n      if (dotRV < 0.0)\\n      {\\n          return lightIntensity * (k_d * dotLN);\\n      }\\n      return lightIntensity * (k_d * dotLN + k_s * pow(dotRV, alpha));\\n  }\\n\\n  vec3 phongIllumination(vec3 k_a, vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye, vec3 norm)\\n  {\\n      const vec3 ambientLight = 0.5 * vec3(1.0, 1.0, 1.0);\\n      vec3 color = ambientLight * k_a;\\n\\n      vec3 light1Pos = normalize(vec3(mouse.x, mouse.y, .20));\\n      vec3 light1Intensity = 2. * vec3(0.4, 0.4, 0.4);\\n\\n      color += phongContribForLight(k_d, k_s, alpha, p, eye, light1Pos, light1Intensity, norm);\\n\\n      return color;\\n  }\\n\\n  vec4 color_phong(vec3 p, vec3 ro, vec3 n, vec3 col)\\n  {\\n      vec3 K_a = col;\\n      vec3 K_d = K_a;\\n      vec3 K_s = vec3(1.0, 1.0, 1.0);\\n      float shininess = 12.0;\\n\\n      col = phongIllumination(K_a, K_d, K_s, shininess, p, ro, n);\\n      return vec4(col, 1.);\\n  }\\n\\n  void main()\\n  {\\n      // vertex index in quad face, two triangles\\n      float id_Vert = mod(vertexId, 6.0);\\n      // face index\\n      float id_Face = floor(vertexId / 6.0);\\n      // corner face index\\n      float id_Face_corner = mod(id_Face, 3.0);\\n      // corner edge index\\n      float id_Edge = mod(id_Face, 3.0);\\n      // corner index 1 corner is 3 faces is 3*6 verts\\n      float id_Corner = floor(vertexId / 18.0);\\n      // corner position\\n      vec3 cornerP;\\n      float tVertX = VertX * size;\\n      float tVertY = VertY * size;\\n      cornerP.x = mod(id_Corner, tVertX);\\n      cornerP.y = mod(floor(id_Corner / tVertX), tVertY);\\n      cornerP.z = mod(floor(id_Corner / (tVertX * tVertY)), tVertY);\\n\\n      vec3 faceNorm;\\n      vec3 faceTan;\\n      vec3 faceaTan;\\n      if (id_Edge == 0.0)\\n      {\\n          faceNorm = vec3(1.0, 0.0, 0.0);\\n          faceTan = vec3(0.0, 0.0, -1.0);\\n          faceaTan = vec3(0.0, 1.0, 0.0);\\n      }\\n      else if (id_Edge == 1.0)\\n      {\\n          faceNorm = vec3(0.0, 1.0, 0.0);\\n          faceTan = vec3(1.0, 0.0, 0.0);\\n          faceaTan = vec3(0.0, 0.0, -1.0);\\n      }\\n      else\\n      {\\n          faceNorm = vec3(0.0, 0.0, 1.0);\\n          faceTan = vec3(1.0, 0.0, 0.0);\\n          faceaTan = vec3(0.0, 1.0, 0.0);\\n      }\\n      vec3 aPos = cornerP + faceNorm;\\n\\n      // sampling points\\n      vec3 p0 = voxelPosToWorld(cornerP);\\n      vec3 p1 = voxelPosToWorld(aPos);\\n\\n      // field value\\n      float d0 = scene(p0);\\n      float d1 = scene(p1);\\n\\n      vec3 p;\\n      vec3 vertNorm;\\n\\n      if (d0 * d1 > 0.0)\\n      {\\n          // no face\\n          p = p0;\\n          vertNorm = vec3(1.0, 1.0, 1.0);\\n      }\\n      else\\n      {\\n          // have a face\\n          if (d1 < d0)\\n          {\\n              // 0->1 is standard normal.\\n              // otherwise flip triangle\\n              if (id_Vert == 0.0)\\n              {\\n                  id_Vert = 2.0;\\n              }\\n              else if (id_Vert == 2.0)\\n              {\\n                  id_Vert = 0.0;\\n              }\\n              else if (id_Vert == 3.0)\\n              {\\n                  id_Vert = 5.0;\\n              }\\n              else if (id_Vert == 5.0)\\n              {\\n                  id_Vert = 3.0;\\n              }\\n              faceNorm *= -1.0;\\n          }\\n\\n          /*\\n          face\\n          2 4-5\\n          |\\\\ \\\\|\\n          0-1 3\\n          */\\n          float faceSize = mix(0.45, 0.5, clamp(cos(time * .75) * 4.0 + 0.5, 0.0, 1.0));\\n          vec3 edgeMidP = (cornerP + aPos) * 0.5;\\n          vec3 faceVertP;\\n          if (id_Vert == 0.0)\\n          {\\n              faceVertP = edgeMidP + faceTan * -faceSize + faceaTan * -faceSize;\\n          }\\n          else if (id_Vert == 1.0)\\n          {\\n              faceVertP = edgeMidP + faceTan * faceSize + faceaTan * -faceSize;\\n          }\\n          else if (id_Vert == 2.0)\\n          {\\n              faceVertP = edgeMidP + faceTan * -faceSize + faceaTan * faceSize;\\n          }\\n          else if (id_Vert == 3.0)\\n          {\\n              faceVertP = edgeMidP + faceTan * faceSize + faceaTan * -faceSize;\\n          }\\n          else if (id_Vert == 4.0)\\n          {\\n              faceVertP = edgeMidP + faceTan * -faceSize + faceaTan * faceSize;\\n          }\\n          else if (id_Vert == 5.0)\\n          {\\n              faceVertP = edgeMidP + faceTan * 0.5 + faceaTan * 0.5;\\n          }\\n          p = voxelPosToWorld(faceVertP);\\n\\n          // smoothing\\n          vec3 sp = vertexSmooth(p);\\n          vertNorm = sceneNormal(p);\\n\\n          float vmix = clamp(sin(time * 0.35) * 2.0 + 0.5, 0.0, 1.0);\\n          vmix = 1.;\\n          p = mix(p, sp, vmix);\\n          vertNorm = mix(faceNorm, vertNorm, vmix);\\n      }\\n\\n      vec3 eye = vec3(0.0, 0.0, 3.5) * rotx(clamp(mouse.y, -0.5, 0.5) * 1.5) * roty(-clamp(mouse.x, -0.5, 0.5) * 1.5);\\n      // eye = vec3(0.0, 0.0, 3.0);\\n      mat4 viewMat = lookat(eye, vec3(0.0), vec3(0.0, 1.0, 0.0));\\n      mat4 pMatrix = perspectiveMatrix(60.0 * degree_to_rad, resolution.x / resolution.y);\\n      vec4 viewPos = (viewMat * vec4(p, 1.0));\\n      vec3 viewNorm = normalize((viewMat * vec4(vertNorm, 0.0)).xyz);\\n\\n      gl_Position = (pMatrix * viewPos) * 100.2;\\n      gl_PointSize = 2.0;\\n\\n      v_color = color_phong(viewPos.xyz, eye, viewNorm, 0.5 * (viewNorm + 1.) / 2.);\\n  }\"}",
  "screenshotURL": "data/images/images-h8yoih8lvio846bad-thumbnail.jpg",
  "hasSound": "",
  "views": {
    "$numberInt": "8"
  },
  "likes": {
    "$numberInt": "0"
  },
  "revisionId": "37i6g4xAvMJ4s25N6"
}