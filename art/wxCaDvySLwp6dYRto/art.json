{
  "_id": "wxCaDvySLwp6dYRto",
  "owner": {
    "_id": "B7Kfai5f9h3MxwJcP",
    "createdAt": {
      "$date": {
        "$numberLong": "1445777397953"
      }
    },
    "username": "gman",
    "profile": {
      "info": "&nbsp;&nbsp;contact: [@greggman](http://twitter.com/greggman), [github](http://github.com/greggman), [blog](http://greggman.com)\nnew stuff: [webgl](http://webglfundamentals.com), [twgl](http://twgljs.org), [threejsfundamentals](https://threejsfundamentals.org)\nold stuff: [chrome](http://chromium.org), [locoroco](https://www.youtube.com/watch?v=pFKpyScxv0k), [CTR](https://www.youtube.com/watch?v=3O8FK5d67cM), [Zombie Revenge](https://www.youtube.com/watch?v=Xw8yNik8Q-A), [and others...](http://games.greggman.com/game/games_o_the_greggman/)\n\nSome stuff you might want to look at\n\n*   [A uniform grid based on `vertexCount` and the window dimensions](https://www.vertexshaderart.com/art/NPohkmBgKdTBhML8P)\n*   [Tons of matrix functions](https://www.vertexshaderart.com/art/nr3EiyXWLMpwoouHt)\n\nNote: All the shaders I've posted are licensed [CC0](https://creativecommons.org/publicdomain/zero/1.0/)",
      "avatarUrl": "https://secure.gravatar.com/avatar/dcc0309895c3d6db087631813efaa9d1?default=retro&size=200"
    }
  },
  "createdAt": {
    "$date": {
      "$numberLong": "1448800634470"
    }
  },
  "modifiedAt": {
    "$date": {
      "$numberLong": "1448800634470"
    }
  },
  "origId": null,
  "name": "spang",
  "rank": {
    "$numberDouble": "1.9538071066231233"
  },
  "private": true,
  "username": "gman",
  "settings": "{\"num\":772,\"mode\":\"LINES\",\"sound\":\"\",\"lineSize\":\"NATIVE\",\"backgroundColor\":[0,0,0,1],\"shader\":\"#define PI radians(180.)\\n\\n// Based on code by Nik\\n// http://codepen.io/nikrowell/pen/BNdaKV\\n\\n#define SETTINGS_FRICTION 0.5\\n#define SETTINGS_TRAILS 20.\\n#define SETTINGS_SIZE 50.\\n#define SETTINGS_DAMPENING 0.25\\n#define SETTINGS_TENSION 0.98\\n#define SETTINGS_POINTS_PER_NODE 20.\\n\\t\\n#define SETTINGS_POINTS_PER_TENDRIL (SETTINGS_SIZE * SETTINGS_POINTS_PER_NODE * 2.)\\n\\nvec3 hsv2rgb(vec3 c) {\\n  c = vec3(c.x, clamp(c.yz, 0.0, 1.0));\\n  vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\\n}\\n\\n// hash function from https://www.shadertoy.com/view/4djSRW\\nfloat hash(float p) {\\n\\tvec2 p2 = fract(vec2(p * 5.3983, p * 5.4427));\\n    p2 += dot(p2.yx, p2.xy + vec2(21.5351, 14.3137));\\n\\treturn fract(p2.x * p2.y * 95.4337);\\n}\\n\\nfloat m1p1(float v) {\\n  return v * 2. - 1.;\\n}\\n\\nvec2 getPoint(float pointId) {\\n  return vec2(m1p1(hash(pointId)), m1p1(hash(pointId + 0.37))) * 0.5;\\n}\\n\\n\\nvoid main() {\\n  float pointId   = mod(floor(vertexId / 2.), SETTINGS_POINTS_PER_TENDRIL) + mod(vertexId, 2.);\\n  float cPointId  = floor(pointId / SETTINGS_POINTS_PER_NODE);\\n  float innerId   = mod(pointId, SETTINGS_POINTS_PER_NODE);\\n  float tendrilId = floor(vertexId / SETTINGS_POINTS_PER_TENDRIL);\\n  \\n  vec2 cp0 = getPoint(cPointId);\\n  vec2 cp1 = getPoint(cPointId + 1.);\\n  vec2 cp2 = getPoint(cPointId + 2.);\\n  \\n  float t = innerId / SETTINGS_POINTS_PER_NODE;\\n  float invT = 1. - t;\\n  // B(t) = (1 - t)[(1 - t)p0 + tP1] + t[(1 - t)P1 + tP2]\\n  // B(t) = (1 - t)^2p0 + 2(1-t)tp1 + t^2p2;\\n  //vec2 p = mix(mix(cp0, cp1, v), mix(cp1, cp2, v), v);\\n  //vec2 p = invT * (invT * cp0 + t * cp1) + t * (invT * cp1 + cp2);\\n  vec2 p = pow(invT, 2.) * cp0 + 2. * invT * t * cp1 + pow(t, 2.) * cp2;  \\n\\n  vec2 aspect = vec2(1, resolution.x / resolution.y);\\n  gl_Position = vec4(p * aspect, 0, 1);\\n\\n  float hue = (time * 0.01);\\n  v_color = vec4(hsv2rgb(vec3(hue, 1, 1)), 1);\\n  gl_PointSize = 4.;\\n}\\n\\n/* \\nMath.round(hue.update()) + ',90%,50%,0.25)';\\n\\t\\tctx.lineWidth = 1;\\n\\t\\t\\n\\t\\tfor(var i = 0, tendril; i < settings.trails; i++) {\\n\\t\\t\\ttendril = tendrils[i];\\n\\t\\t\\ttendril.update();\\n\\t\\t\\ttendril.draw();\\n\\t\\t}\\n\\n\\n\\t\\t\\t\\t\\n\\t\\t\\t\\tthis.spring = options.spring + (Math.random() * 0.1) - 0.05; \\n\\t\\t\\t\\tthis.friction = settings.friction + (Math.random() * 0.01) - 0.005;\\n\\t\\t\\t\\tthis.nodes = [];\\n\\t\\t\\t\\t\\n\\t\\t\\t\\tfor(var i = 0, node; i < settings.size; i++) {\\n\\t\\t\\t\\n\\t\\t\\t\\t\\tnode = new Node();\\n\\t\\t\\t\\t\\tnode.x = target.x;\\n\\t\\t\\t\\t\\tnode.y = target.y;\\n\\t\\t\\t\\n\\t\\t\\t\\t\\tthis.nodes.push(node);\\n\\t\\t\\t\\t}\\t\\n\\t\\t\\t},\\n\\t\\t\\t\\n\\t\\t\\tupdate: function() {\\n\\t\\t\\t\\t\\n\\t\\t\\t\\tvar spring = this.spring,\\n\\t\\t\\t\\t\\tnode = this.nodes[0];\\n\\t\\t\\t\\t\\n\\t\\t\\t\\tnode.vx += (target.x - node.x) * spring;\\n\\t\\t\\t\\tnode.vy += (target.y - node.y) * spring;\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\tfor(var prev, i = 0, n = this.nodes.length; i < n; i++) {\\n\\t\\n\\t\\t\\t\\t\\tnode = this.nodes[i];\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\tif(i > 0) {\\n\\t\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t\\tprev = this.nodes[i - 1];\\n\\t\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t\\tnode.vx += (prev.x - node.x) * spring;\\n\\t\\t\\t\\t\\t\\tnode.vy += (prev.y - node.y) * spring;\\n\\t\\t\\t\\t\\t\\tnode.vx += prev.vx * settings.dampening;\\n\\t\\t\\t\\t\\t\\tnode.vy += prev.vy * settings.dampening;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\tnode.vx *= this.friction;\\n\\t\\t\\t\\t\\tnode.vy *= this.friction;\\n\\t\\t\\t\\t\\tnode.x += node.vx;\\n\\t\\t\\t\\t\\tnode.y += node.vy;\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\tspring *= settings.tension;\\n\\t\\t\\t\\t}\\n\\t\\t\\t},\\n\\t\\n\\t\\t\\tdraw: function() {\\n\\t\\t\\t\\n\\t\\t\\t\\tvar x = this.nodes[0].x, \\n\\t\\t\\t\\t\\ty = this.nodes[0].y,\\n\\t\\t\\t\\t\\ta, b;\\n\\t\\t\\t\\t\\n\\t\\t\\t\\tctx.beginPath();\\n\\t\\t\\t\\tctx.moveTo(x, y);\\n\\t\\t\\t\\t\\n\\t\\t\\t\\tfor(var i = 1, n = this.nodes.length - 2; i < n; i++) {\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\ta = this.nodes[i];\\n\\t\\t\\t\\t\\tb = this.nodes[i + 1];\\n\\t\\t\\t\\t\\tx = (a.x + b.x) * 0.5;\\n\\t\\t\\t\\t\\ty = (a.y + b.y) * 0.5;\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\tctx.quadraticCurveTo(a.x, a.y, x, y);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\n\\t\\t\\t\\ta = this.nodes[i];\\n\\t\\t\\t\\tb = this.nodes[i + 1];\\n\\t\\t\\t\\t\\n\\t\\t\\t\\tctx.quadraticCurveTo(a.x, a.y, b.x, b.y);\\n\\t\\t\\t\\tctx.stroke();\\n\\t\\t\\t\\tctx.closePath();\\n\\t\\t\\t}\\n\\t\\t};\\n\\t\\n\\t\\n*/\\n\\n\\n\"}",
  "screenshotURL": "data/images/images-pyuemm0rqvtg1uvbc-thumbnail.jpg",
  "hasSound": "",
  "views": {
    "$numberInt": "3"
  },
  "likes": {
    "$numberInt": "0"
  },
  "revisionId": "YjgkFBsNQ7bmE583r",
  "avatarUrl": "https://secure.gravatar.com/avatar/dcc0309895c3d6db087631813efaa9d1?default=retro&size=200"
}